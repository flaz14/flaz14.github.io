<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Новое, клёвое и хреновое в Java 8. Часть 1. Потоки</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-8-whats-new/java-8-whats-new-part-1.html">
				Новое, клёвое и хреновое в Java 8. Часть 1. Потоки
			</a>
		</h1>
		
		<h3>[2017, Ноябрь]</h3>

		<h3>
			<a href="java-8-whats-new/java-8-whats-new-part-2.html">Часть 2. Unit-тесты</a>
			|
			<a href="java-8-whats-new/java-8-whats-new-part-3.html">Часть 3. Внутренние классы</a>
			|
			<a href="тут будет ссылка на исходный код Maven-проекта">
				Исходный код
			</a>
		</h3>

		<h2>Начало</h2>

		<p>
			В этой ламерской статье мы сосредоточимся на практическом применении Java 8 в энтэрпрайзных приложениях. 
			Спасибо <i>Benjamin Winterberg</i>'у за его офигенный туториал: 
			<a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/">Java 8 Stream Tutorial</a>.
			Неудивительно, что его сайт находится на самой вершине выдачи Гугла.
			
		<h2>Пара замечаний к исходному коду</h2>
		
		<p>
			К каждому примеру есть тест. Тесты нужны для того, чтобы убедиться, что разные подходы к решению одной и той 
			же задачи выдают один и тот же результат. Кстати, код самих тестов написан в стиле Java 7. Это сделано 
			намеренно, чтобы не отвлекать внимание от собственно примеров Java 8.
		
		<p>
			Помешательство на внутренних классах видно невооруженным глазом. Не знаю, как вам, но мне такой способ 
			структурирования программы очень по душе: 
			<a href="http://flaz14.github.io/inner-classes-in-java-are-cool/inner-classes-in-java-are-cool.html">
				Внутренние классы в Java - классные! 
			</a>. Вообще, сегодня грань между кодом и данными постепенно размывается. Нет, это не отменяет концепции 
			дедушки <i>Никлауса Вирта</i> ("Алгоритмы + Структуры данных = Программы"). Наоборот: сплетая алгоритмы в 
			структуры, можно изобретать новые (или хотя бы упорядочивать существующие). Их можно пересылать, словно 
			электронные письма, строить распределенные приложения, в которых между узлами передаются не данные, а код. 
			Что-то подобное уже сделали: 
			<a href="http://swarmframework.org/">The Swarm Framework</a> (про него я узнал в
			<a href="artamonov.ru/2009/10/02/swarm-dpl/">блоге Игоря Артамонова</a>; на главной странице сказано, что 
			сайт закрыт, но ссылки работают).
		
		<p>
			Также я использовал <code>static import</code>'ы везде, где только можно. Да, это нехорошо. Без IDE 
			непонятно, что и откуда импортируется. Но именно короткие имена статически импортированных методов позволяют
			вкусить всю красоту кода на Java 8.
		
		<p>
			Реализация классов предметной области (называйте их как хотите: Entity, DTO и т.д.) - отдельная тема. Сейчас
			модно закладывать неизменяемость в такие классы. Т.е. методы, которые меняют состояние объекта, возвращают 
			при каждом вызове новый объект. У меня немного не так. Я не пытался сделать объекты неизменяемыми. А только 
			избавилс от традиционных getter'ов и setter'ов. По-моему, перегруженные методы, имена которых точь-в-точь 
			повторяют имена соответствующих полей, намного круче. Они нагляднее. И помогают избежать лишней писанины, а 
			именно: пижонские setter'ы справляются с созданием новых объектов не хуже, чем это делают builder'ы (т.е. 
			инициализировать поля цепочкой, включая вложенные поля). А может, и лучше: вместо немного сбивающих с толку 
			фабричных методов вроде <code>aCustomer()</code> мы видим самые настоящие и прямолинейные конструкторы.
		
		<p>
			И еще: в тестах вместо заранее заготовленных наборов тестовых данных везде используются статические 
			вспомогательные методы, которые при каждом вызове возвращают новый набор данных, т.е. новый объект, 
			содержащий одни и те же данные. Зачем это нужно? Чтобы тесты (случайно) не модифицировали тестовые данные и 
			не влияли друг на друга.

		<h2>К делу!</h2>
		
		<p>
			Пожалуй, в каждом корпоративном приложении есть БД, в которой хранятся сведения о клиентах. А для внешнего
			мира эти сведени доступные REST API. У нас есть для олицетворения клиента используется класс 
			<strong>Customer</strong>. Данные о месте проживания клиента представлены в виде класса 
			<strong>Address</strong>. Выглядят они так (в <a href="#listing-1">листинге 1</a> для краткости приведены 
			только поля):

<h4 id="listing-1">Листинг 1 - Классы предметной области</h4>
<pre>
public class Customer {
    private String firstName;
    private String lastName;
    private Address address;
    private List<String> phoneNumbers;
    
    ...
}

public class Address {
    private String country;
    private String town;
    private String street;
    private String buildingNumber;
    
    ...
}   
</pre>
		
		<p>
			Пусть нам дан список клиентов. Наша задача состоит в том, чтобы собрать все страны, в которых проживают 
			клиенты, в другой список. Попробуем сделать это в стиле Java 7 и получим код, приведенный в 
			<a href="#listing-2">листинге 2</a>. Он содержит все необходимое: проверки на <code>null</code>, 
			обертывание результата неизменяемым множеством, 
			рационально расставленные модификаторы <code>final</code>.

<h4 id="listing-2">Листинг 2 - Стиль Java 7</h4>
<pre>
public static Set<String> java7(final List<Customer> customers) {
    final Set<String> countries = new HashSet<>();
    for (final Customer customer : customers) {
        if (customer != null) {
            if (customer.address() != null) {
                String country = customer.address().country();
                countries.add(country);
            }
        }
    }
    return unmodifiableSet(countries);
}
</pre>

		<p>
			Что же мы видим? Привычный цикл <em>foreach</em> и два вложенных <em>if</em>, кроме всего прочего. Попробуем теперь 
			сделать то же самое, но с применением Java 8. В <a href="#listing-3">листинге 3</a> можно видеть "наивный" 
			способ. По сути, от Java 8
			там ничего нет, только новый цикл <em>foreach</em>

<h4 id="listing-3">Листинг 3 - "Наивный" стиль Java 8</h4>
<pre>
static Set<String> trivial(final List<Customer> customers) {
    final Set<String> countries = new HashSet<>();
    customers.forEach(customer -> {
        if (customer != null) {
            if (customer.address() != null) {
                String country = customer.address().country();
                countries.add(country);
            }
        }
    });
    return unmodifiableSet(countries);
}
</pre>

		<p>
			Настоящая Java 8 - это потоки, т.е. <strong>streams</strong>. Это не потоки выполнения. И не потоки ввода-вывода.
			 Что-то среднее. Ибо название
			"конвейер" им тоже не подходит - на конвейере разные операции на разными данными выполняются одновременно. 
			В принципе, <strong>parallel streams</strong> - это уже конвейеры (мне так кажется, исходный код JDK я не 
			смотрел, простите).
			
<h4 id="listing-4">Листинг 3 - Настоящий стиль Java 8</h4>
<pre>
static Set<String> stream(final List<Customer> customers) {
    return customers.
            stream().
            filter(Objects::nonNull).
            filter(customer -> nonNull(customer.address())).
            map(customer -> customer.address().country()).
            collect(collectingAndThen(toSet(), Collections::unmodifiableSet));
}
</pre>

		<h2>Что клёвого?</h2>
		
		
	
Java 7		
<pre>
/usr/local/soft/jdk1.8.0_111/bin/java -ea -Didea.launcher.port=7533 -Didea.launcher.bin.path=/usr/local/soft/idea-IC-139.1603.1/bin -Dfile.encoding=UTF-8 -classpath /usr/local/soft/idea-IC-139.1603.1/lib/idea_rt.jar:/usr/local/soft/idea-IC-139.1603.1/plugins/junit/lib/junit-rt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/resources.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/plugin.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/charsets.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/rt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/deploy.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jfr.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/management-agent.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/javaws.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jsse.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jce.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jfxswt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunpkcs11.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunec.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/nashorn.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/dnsns.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/jaccess.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/jfxrt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/cldrdata.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/zipfs.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/localedata.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunjce_provider.jar:/home/yura/Projects/flaz14.github.io/java-8-whats-new/code/java-8-whats-new/target/test-classes:/usr/local/soft/idea-IC-139.1603.1/lib/junit-4.11.jar:/usr/local/soft/idea-IC-139.1603.1/lib/hamcrest-core-1.3.jar:/usr/local/soft/idea-IC-139.1603.1/lib/hamcrest-library-1.3.jar:/home/yura/.m2/repository/junit/junit/4.12/junit-4.12.jar:/home/yura/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar com.intellij.rt.execution.application.AppMain com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 example.ExtractingNestedFieldTest,java7

java.lang.IllegalStateException: This is workaround for demonstrating nasty Java 8 stacktraces.
	at example.Address.country(ExtractingNestedFieldTest.java:177)
	at example.ExtractingNestedFieldTest$CountriesExtractor.java7(ExtractingNestedFieldTest.java:95)
	at example.ExtractingNestedFieldTest.java7(ExtractingNestedFieldTest.java:21)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)


Process finished with exit code 255
</pre>		
		
		
			
			
			
Java 8		
<pre>
/usr/local/soft/jdk1.8.0_111/bin/java -ea -Didea.launcher.port=7532 -Didea.launcher.bin.path=/usr/local/soft/idea-IC-139.1603.1/bin -Dfile.encoding=UTF-8 -classpath /usr/local/soft/idea-IC-139.1603.1/lib/idea_rt.jar:/usr/local/soft/idea-IC-139.1603.1/plugins/junit/lib/junit-rt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/resources.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/plugin.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/charsets.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/rt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/deploy.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jfr.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/management-agent.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/javaws.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jsse.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jce.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jfxswt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunpkcs11.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunec.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/nashorn.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/dnsns.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/jaccess.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/jfxrt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/cldrdata.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/zipfs.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/localedata.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunjce_provider.jar:/home/yura/Projects/flaz14.github.io/java-8-whats-new/code/java-8-whats-new/target/test-classes:/usr/local/soft/idea-IC-139.1603.1/lib/junit-4.11.jar:/usr/local/soft/idea-IC-139.1603.1/lib/hamcrest-core-1.3.jar:/usr/local/soft/idea-IC-139.1603.1/lib/hamcrest-library-1.3.jar:/home/yura/.m2/repository/junit/junit/4.12/junit-4.12.jar:/home/yura/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar com.intellij.rt.execution.application.AppMain com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 example.ExtractingNestedFieldTest,java8Stream

java.lang.IllegalStateException: This is workaround for demonstrating nasty Java 8 stacktraces.
	at example.Address.country(ExtractingNestedFieldTest.java:177)
	at example.ExtractingNestedFieldTest$CountriesExtractor$Java8.lambda$stream$1(ExtractingNestedFieldTest.java:116)
	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)
	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
	at example.ExtractingNestedFieldTest$CountriesExtractor$Java8.stream(ExtractingNestedFieldTest.java:117)
	at example.ExtractingNestedFieldTest.java8Stream(ExtractingNestedFieldTest.java:33)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)


Process finished with exit code 255
</pre> 


Надо не забыть написать про порядок выполнения операций. Т.е. проверка того, что поле address в объекте класса Customer
не равно null (т.о. мы предотвращаем NullPointerException) с помощью фильтра не приведет к дополнительной итерации по 
списку Customer'ов. Об этой особенности потоков Java 8 написал Бенжамин.


The order of the result might be surprising. A naive approach would be to execute the operations horizontally one after another on all elements of the stream. But instead each element moves along the chain vertically. The first string "d2" passes filter then forEach, only then the second string "a2" is processed. 





TODO написать про то, что в фильтрах можно использовать не только лямбда-выражения, но и ссылки на методы. Но только в том случае,
если требуется проверить сами объекты в потоке, а не какое-либо поле объектов.

TODO написать про то, что потоки имеют важное преимущество по сравнению со старомодным кодом Java 7: не нужно заботится 
о неизменяемости данных. Да, от криво реализованной самописной лямбда-функции никто не застрахован. Но потоки позволяют
забыть про случайную порчу данных, не нужно ставить `final` перед именами переменных (собственно, и переменных-то нету).








		<h4 id="illustration-1-1">
				Рисунок 1.1 - пример отображения несмонтированного раздела на боковой панели Nemo
		</h4>
		<p>
			<img src="illustrations/nemo-sidebar-with-unmounted-drive-visible.png" width="240px"
			alt="здесь изображена фрагмент скриншота программы Nemo">

		<p>
			К сожалению, в Nemo нет возможности скрыть несмонтированные тома. Я облазил все настройки и ничего 
			связанного с этим не нашел. Действительно, судя по исходному коду Nemo (здесь и далее рассматривается версия
			<b>2.4.5</b>, но в последней версии <b>3.0.6</b> то же самое), отвечающему за отображение значков на боковой
			панели, фрагмент которого приведен в <a href="#listing-1-1">листинге 1.1</a> (многие строки опущены для 
			краткости), это поведение никак не настраивается и не отключается. Это подтверждается и комментариями в 
			строках 
<a 
href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c#L992">
№№992-999</a> и 
<a
href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c#L1089">
№1089</a>.

<h4 id="listing-1-1">Листинг 1.1 - фрагмент файла 
<a 
href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c">
nemo-places-sidebar.c
</a>
</h4>
<pre>
   ...
   946	    /* first go through all connected drives */
   947	    drives = g_volume_monitor_get_connected_drives (volume_monitor);
   948	
   949	    for (l = drives; l != NULL; l = l->next) {
   950	        drive = l->data;
   951	
   952	        volumes = g_drive_get_volumes (drive);
   953	        if (volumes != NULL) {
   954	            for (ll = volumes; ll != NULL; ll = ll->next) {
   ...                  ...
   965	                mount = g_volume_get_mount (volume);
   966	                if (mount != NULL) {
   967	                    /* Show mounted volume in the sidebar */
   ...                      ...
   991	                } else {
   992	                    /* Do show the unmounted volumes in the sidebar;
   993	                     * this is so the user can mount it (in case automounting
   994	                     * is off).
   995	                     *
   996	                     * Also, even if automounting is enabled, this gives a visual
   997	                     * cue that the user should remember to yank out the media if
   998	                     * he just unmounted it.
   999	                     */
   ...                      ...
  1014	                }
  1015	                g_object_unref (volume);
  1016	            }
  1017	            g_list_free (volumes);
   ...              ...
  1045	
  1046	    /* add all volumes that is not associated with a drive */
  1047	    volumes = g_volume_monitor_get_volumes (volume_monitor);
  1048	    for (l = volumes; l != NULL; l = l->next) {
   ...          ...
  1066	        mount = g_volume_get_mount (volume);
  1067	        if (mount != NULL) {
   ...              ...
  1088	        } else {
  1089	            /* see comment above in why we add an icon for an unmounted mountable volume */
   ...              ...
  1099	        }
  1100	        g_object_unref (volume);
  1101	    }
  1102	    g_list_free (volumes);
   ...
</pre>

		<h2>Возможное решение 1</h2>

		<p>
			Убираем ненужные строки в исходнике, компилируем доработанную версию Nemo и устанавливаем его в систему.

		<p>
			Достоинства:
			<ul>
				<li>
					очень элегантное решение (объем кода, а следовательно, размер программы уменьшается!);
			
				<li>
					100% будет работать.
			</ul>

		<p>
			Недостатки:
			<ul>
				<li>
					для компиляции и сборки, кроме собственно <em>gcc</em>, <em>make</em> и набора библиотек Gnome для 
					разработчика, придется установить дополнительные утилиты: всякие <em>autotools</em> и т.п. А после 
					того как все заработает, придется еще очистить систему от ненужных более пакетов;

				<li>
					придется всегда хранить на компьютере исходники Nemo, иначе не 	получиться удалить программу 
					(справедливости ради стоит отметить, что можно создать свой <i>.deb</i>-пакет из исходных текстов, 
					затем обращаться с ним так же, как с обычными пакетами);

				<li>
					как только Nemo установлен (неважно, из исходных текстов или из "самопального" пакета), его уже не 
					получиться обновлять из официальных репозиториев (а если и можно было бы, официальная версия Nemo 
					затерла бы нашу, доработанную, и мы пришли бы к тому, с чего начали).
			</ul>

		<h2>Возможное решение 2</h2>

		<p>
			Вносим изменения в конфигурацию 
			<a href="https://git.gnome.org/browse/gvfs/tree/monitor/udisks2/what-is-shown.txt">
			gvfs-udisks2-volume-monitor</a>, чтобы прослойка между Nemo и ядром рапортовала об отсутствии 
			томов, если те не были смонтированы 
			<sup id="footnote-2-top"><a href="#footnote-2-bottom">[2]</a></sup>.

		<p>
			Достоинства:
			<ul>
				<li>
					не придеться трогать Nemo вообще;

				<li>
					скорее всего будет работать.
			</ul>

		<p>
			Недостатки:
			<ul>
				<li>
					изменения затронут не только Nemo, но и другие программы, которые используют возможности GVfs. Что 
					нежелательно (например, для программы записи компакт-дисков).
			</ul>

		<h2>Возможное решение 3</h2>

		<p>
			Перехватываем функцию библиотеки Gnome, которая отвечает за перечисление томов (несмонтированных в том 
			числе), отбрасываем несмонтированные тома и возвращаем отфильтрованный список Nemo. Nemo "увидит" только 
			смонтированные тома. Этому подходу и посвящена 
			<a href="how-to-hide-non-mounted-drives-part-2.html">часть 2</a>.

        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Слово "диск" не совсем уместно. Правильнее было бы сказать "том". Том не обязательно 
						соответствует разделу на физическом диске. Например, несколько физических дисков можно 
						объединить в один большой том посредством RAID. Или же несколько областей на физическом диске 
						можно объединить в том с помощью LVM.

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 
						Я так и не разобрался, что все это значит: <em>udisks</em>, <em>GVfs</em>, 
						<em>volume-monitor</em> и т.д. Возможно, этот пункт стоит выкинуть вообще, но я его оставлю на 
						всякий случай.
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
