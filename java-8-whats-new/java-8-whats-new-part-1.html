<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Новое, клёвое и хреновое в Java 8. Часть 1. Потоки</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-8-whats-new/java-8-whats-new-part-1.html">
				Новое, клёвое и хреновое в Java 8. Часть 1. Потоки
			</a>
		</h1>
		
		<h3>[2017, Ноябрь]</h3>

		<h3>
			<a href="java-8-whats-new/java-8-whats-new-part-2.html">Часть 2. Unit-тесты</a>
			|
			<a href="java-8-whats-new/java-8-whats-new-part-3.html">Часть 3. Внутренние классы</a>
			|
			<a href="тут будет ссылка на исходный код Maven-проекта">
				Исходный код
			</a>
		</h3>

		<h2>Начало</h2>

		<p>
			В этой ламерской статье мы сосредоточимся на практическом применении Java 8 в энтэрпрайзных приложениях. 
			Спасибо <i>Benjamin Winterberg</i>'у за его офигенный туториал: 
			<a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/">Java 8 Stream Tutorial</a>.
			Неудивительно, что его сайт находится на самой вершине выдачи Гугла.
			
		<h2>Пара замечаний к исходному коду</h2>
		
		<p>
			К каждому примеру есть тест. Тесты нужны для того, чтобы убедиться, что разные подходы к решению одной и той 
			же задачи выдают один и тот же результат. Кстати, код самих тестов написан в стиле Java 7. Это сделано 
			намеренно, чтобы не отвлекать внимание от собственно примеров Java 8.
		
		<p>
			Помешательство на внутренних классах видно невооруженным глазом. Не знаю, как вам, но мне такой способ 
			структурирования программы очень по душе: 
			<a href="http://flaz14.github.io/inner-classes-in-java-are-cool/inner-classes-in-java-are-cool.html">
				Внутренние классы в Java - классные! 
			</a>. Вообще, сегодня грань между кодом и данными постепенно размывается. Нет, это не отменяет концепции 
			дедушки <i>Никлауса Вирта</i> ("Алгоритмы + Структуры данных = Программы"). Наоборот: сплетая алгоритмы в 
			структуры, можно изобретать новые (или хотя бы упорядочивать существующие). Их можно пересылать, словно 
			электронные письма, строить распределенные приложения, в которых между узлами передаются не данные, а код. 
			Что-то подобное уже сделали: 
			<a href="http://swarmframework.org/">The Swarm Framework</a> (про него я узнал в
			<a href="artamonov.ru/2009/10/02/swarm-dpl/">блоге Игоря Артамонова</a>; на главной странице сказано, что 
			сайт закрыт, но ссылки работают).
		
		<p>
			Также я использовал <code>static import</code>'ы везде, где только можно. Да, это нехорошо. Без IDE 
			непонятно, что и откуда импортируется. Но именно короткие имена статически импортированных методов позволяют
			вкусить всю красоту кода на Java 8.
		
		<p>
			Реализация классов предметной области (называйте их как хотите: Entity, DTO и т.д.) - отдельная тема. Сейчас
			модно закладывать неизменяемость в такие классы. Т.е. методы, которые меняют состояние объекта, возвращают 
			при каждом вызове новый объект. У меня немного не так. Я не пытался сделать объекты неизменяемыми. А только 
			избавилс от традиционных getter'ов и setter'ов. По-моему, перегруженные методы, имена которых точь-в-точь 
			повторяют имена соответствующих полей, намного круче. Они нагляднее. И помогают избежать лишней писанины, а 
			именно: пижонские setter'ы справляются с созданием новых объектов не хуже, чем это делают builder'ы (т.е. 
			инициализировать поля цепочкой, включая вложенные поля). А может, и лучше: вместо немного сбивающих с толку 
			фабричных методов вроде <code>aCustomer()</code> мы видим самые настоящие и прямолинейные конструкторы.
		
		<p>
			И еще: в тестах вместо заранее заготовленных наборов тестовых данных везде используются статические 
			вспомогательные методы, которые при каждом вызове возвращают новый набор данных, т.е. новый объект, 
			содержащий одни и те же данные. Зачем это нужно? Чтобы тесты (случайно) не модифицировали тестовые данные и 
			не влияли друг на друга.

		<h2>К делу!</h2>
		
		<p>
			Пожалуй, в каждом корпоративном приложении есть БД, в которой хранятся сведения о клиентах. А для внешнего
			мира эти сведени доступные REST API. У нас есть для олицетворения клиента используется класс 
			<strong>Customer</strong>. Данные о месте проживания клиента представлены в виде класса 
			<strong>Address</strong>. Выглядят они так (в <a href="#listing-1">листинге 1</a> для краткости приведены 
			только поля):

<h4 id="listing-1">Листинг 1 - Классы предметной области</h4>
<pre>
public class Customer {
    private String firstName;
    private String lastName;
    private Address address;
    private List<String> phoneNumbers;
    
    ...
}

public class Address {
    private String country;
    private String town;
    private String street;
    private String buildingNumber;
    
    ...
}   
</pre>
		
		<p>
			Пусть нам дан список клиентов. Наша задача состоит в том, чтобы собрать все страны, в которых проживают 
			клиенты, в другой список. Попробуем сделать это в стиле Java 7 и получим код, приведенный в 
			<a href="#listing-2">листинге 2</a>. Он содержит все необходимое: проверки на <code>null</code>, 
			обертывание результата неизменяемым множеством, 
			рационально расставленные модификаторы <code>final</code>.

<h4 id="listing-2">Листинг 2 - Стиль Java 7</h4>
<pre>
public static Set<String> java7(final List<Customer> customers) {
    final Set<String> countries = new HashSet<>();
    for (final Customer customer : customers) {
        if (customer != null) {
            if (customer.address() != null) {
                String country = customer.address().country();
                countries.add(country);
            }
        }
    }
    return unmodifiableSet(countries);
}
</pre>

		<p>
			Что же мы видим? Привычный цикл <em>foreach</em> и два вложенных <em>if</em>, кроме всего прочего. Попробуем теперь 
			сделать то же самое, но с применением Java 8. В <a href="#listing-3">листинге 3</a> можно видеть "наивный" 
			способ. По сути, от Java 8
			там ничего нет, только новый цикл <em>foreach</em>

<h4 id="listing-3">Листинг 3 - "Наивный" стиль Java 8</h4>
<pre>
static Set<String> trivial(final List<Customer> customers) {
    final Set<String> countries = new HashSet<>();
    customers.forEach(customer -> {
        if (customer != null) {
            if (customer.address() != null) {
                String country = customer.address().country();
                countries.add(country);
            }
        }
    });
    return unmodifiableSet(countries);
}
</pre>

		<p>
			Настоящая Java 8 - это потоки, т.е. <strong>streams</strong>. Это не потоки выполнения. И не потоки ввода-вывода.
			 Что-то среднее. Ибо название
			"конвейер" им тоже не подходит - на конвейере разные операции на разными данными выполняются одновременно. 
			В принципе, <strong>parallel streams</strong> - это уже конвейеры (мне так кажется, исходный код JDK я не 
			смотрел, простите).
			
<h4 id="listing-4">Листинг 4 - Настоящий стиль Java 8</h4>
<pre>
static Set<String> stream(final List<Customer> customers) {
    return customers.
            stream().
            filter(Objects::nonNull).
            filter(customer -> nonNull(customer.address())).
            map(customer -> customer.address().country()).
            collect(collectingAndThen(toSet(), Collections::unmodifiableSet));
}
</pre>

		<h2>Что клёвого?</h2>
		
		<p>
			Код, написанный в стиле Java 8, намного проще читать. Никаких вложенных блоков, фигурных скобок и т.п. 
			Вместо них - понятные имена методов, такие как <code>filter()</code>. 
			
			Переменных нет. Заботиться о предотвращении (случайного) изменения промежуточных результатов нужно заметно 
			меньше (и добавлять модификатор <code>final</code> не нужно вообще).  
			
		<p>
			Форматирование исходного кода заметно упрощается
			(т.е. упрощаются настройки средств автоматического форматирования кода, таких как <strong>Eclipse Code Formatter</strong>):
			вызовы соединяются в цепочку посредством точки, отступов нет (разве что внутри лямбда выражений; в любом случае, 
			длинное лямбда-выражение лучше опредилить отдельно, т.е. сделать ее самым обычным методом, а в <code>filter</code>,
			к примеру, передать ссылку на красиво названный метод). В цепочку вызовов можно легко добавлять новые звенья - на форматирование
			существующего кода добавляемый никак не повлияет. Удалять код тоже проще - просто стираем строку, никакие фигурные
			скобки от этого не пострадают. И еще автодополнение IDE работает всегда, на каждом этапе, и с гораздо большей
			эффективностью (не нужно мозговать над именем очередного вспомогательного метода, предлагаемых идиом более чем
			достаточно).
			
		<h2>Что хренового?</h2>
		
		<h3>Стэктрэйсы</h3>
		
		<p>
			Об этом уже писал <i>Tal Weiss</i> в статье 
			<a href="http://blog.takipi.com/the-dark-side-of-lambda-expressions-in-java-8/">
				The Dark Side Of Lambda Expressions in Java 8</a>. От себя могу добавить, что увлекаться лямбда-выражениями
			не стоит еще и потому, что они безымянные. На них нельзя "повесить" аспекты. В принципе, это возможно. Нагородить
			костылей всегда возможно. Ведь на самом деле лямбда-функции имеют во время выполнения имена вроде <i>*lambda$*</i>.
			
		<p>
			С потоками ситуация еще хуже. Добавим в метод <code>country()</code> класса <strong>Address</strong> код для 
			"искусственной" ошибки:
<pre>
if (Objects.equals(country, "USA")) {
    throw new IllegalStateException("This is workaround for demonstrating nasty Java 8 stacktraces.");
}	
</pre>
		<p>
			Запустим тест и получим такой стэктрэйс:
<pre>
java.lang.IllegalStateException: This is workaround for demonstrating nasty Java 8 stacktraces.
	at dto.Address.country(Address.java:18)
	at stream.CountriesExtractor$Java8.lambda$stream$2(ExtractingNestedValueTest.java:112)
	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)
	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)
	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)
	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
	at stream.CountriesExtractor$Java8.stream(ExtractingNestedValueTest.java:113)
	at stream.ExtractingNestedValueTest.java8Stream(ExtractingNestedValueTest.java:37)
</pre>



		<p>
			Запустим тот же тест для реализации на Java 7 и увидим, что в старомодной версии все коротко и ясно:
<pre>
java.lang.IllegalStateException: This is workaround for demonstrating nasty Java 8 stacktraces.
	at dto.Address.country(Address.java:18)
	at stream.CountriesExtractor.java7(ExtractingNestedValueTest.java:85)
	at stream.ExtractingNestedValueTest.java7(ExtractingNestedValueTest.java:25)
</pre>			

		<p>
			Отладчик в Java 8 тоже не радует своим видом. Сравните сами:
		<h4 id="illustration-1">
				Рисунок 1 - Отладка кода на Java 7 и Java 8
		</h4>
		<p>
			<img src="illustrations/" width="px"
			alt="фффффффффффффффффффффффффффффффффффф">
		
		<h3>Отсутствие переменных</h3>
		
		<p>
			Да, промежуточные результаты сохраняются во внуренних переменных (т.е. полях)
			потоков. Но чтобы их посмотреть, надо поставить точку останова <em>внутри</em> исходного кода JDK. Какие имена будут у этих 
			переменных? Правильно, они будут называться так, как это реализовано в JDK. И для каждого экземпляра потока
			будут <em>всегда</em> одинаковыми. Так что эффективность грепанья логов падает... 
			
		<h3>Логгирование</h3>

		<p>
			Проблема проистекает из видимого преимущества цепочки вызовов. Например, потребовалось нам записать 
			промежуточный результат в журнал. Как это сделать? Для этого есть метод 
			<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#peek-java.util.function.Consumer-">
				peek()
			</a>. В документации сказано, что он служит целям отладки:
			<cite>
				This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline: 
			</cite>. Но и ежу понятно, что этот метод может использоваться и для других целей. В принципе, можно любой
			метод использовать не по назначению. Но имя <strong>peek()</strong> слишком общее. Почему бы не назвать "отладочный"
			метод <strong>debug()</strong> или <strong>trace</strong> или <strong>log</strong>? Непонятно...
			
		<p>
			А еще прикол в том, что метод <strong>peek()</strong> возвращает поток. Т.е. чтобы просто записать в лог
			промежуточный результат (т.е. записать его целиком: элементы разделить запятыми, по краям поставить скобки и т.д.)
			придеться этот поток предварительно преобразовать в список. Хотя это уже неактуально: наверняка, в современных
			версия библиотек, таких как <a href="https://logging.apache.org/log4j">Log4j</a>, можно логгировать потоки целиком.
		
			
		 
		

Надо не забыть написать про порядок выполнения операций. Т.е. проверка того, что поле address в объекте класса Customer
не равно null (т.о. мы предотвращаем NullPointerException) с помощью фильтра не приведет к дополнительной итерации по 
списку Customer'ов. Об этой особенности потоков Java 8 написал Бенжамин.


The order of the result might be surprising. A naive approach would be to execute the operations horizontally one after another on all elements of the stream. But instead each element moves along the chain vertically. The first string "d2" passes filter then forEach, only then the second string "a2" is processed. 












		<p>
			К сожалению, в Nemo нет возможности скрыть несмонтированные тома. Я облазил все настройки и ничего 
			связанного с этим не нашел. Действительно, судя по исходному коду Nemo (здесь и далее рассматривается версия
			<b>2.4.5</b>, но в последней версии <b>3.0.6</b> то же самое), отвечающему за отображение значков на боковой
			панели, фрагмент которого приведен в <a href="#listing-1-1">листинге 1.1</a> (многие строки опущены для 
			краткости), это поведение никак не настраивается и не отключается. Это подтверждается и комментариями в 
			строках 
<a 
href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c#L992">
№№992-999</a> и 
<a
href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c#L1089">
№1089</a>.

<h4 id="listing-1-1">Листинг 1.1 - фрагмент файла 
<a 
href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c">
nemo-places-sidebar.c
</a>
</h4>
<pre>
   ...
   946	    /* first go through all connected drives */
   947	    drives = g_volume_monitor_get_connected_drives (volume_monitor);
   948	
   949	    for (l = drives; l != NULL; l = l->next) {
   950	        drive = l->data;
   951	
   952	        volumes = g_drive_get_volumes (drive);
   953	        if (volumes != NULL) {
   954	            for (ll = volumes; ll != NULL; ll = ll->next) {
   ...                  ...
   965	                mount = g_volume_get_mount (volume);
   966	                if (mount != NULL) {
   967	                    /* Show mounted volume in the sidebar */
   ...                      ...
   991	                } else {
   992	                    /* Do show the unmounted volumes in the sidebar;
   993	                     * this is so the user can mount it (in case automounting
   994	                     * is off).
   995	                     *
   996	                     * Also, even if automounting is enabled, this gives a visual
   997	                     * cue that the user should remember to yank out the media if
   998	                     * he just unmounted it.
   999	                     */
   ...                      ...
  1014	                }
  1015	                g_object_unref (volume);
  1016	            }
  1017	            g_list_free (volumes);
   ...              ...
  1045	
  1046	    /* add all volumes that is not associated with a drive */
  1047	    volumes = g_volume_monitor_get_volumes (volume_monitor);
  1048	    for (l = volumes; l != NULL; l = l->next) {
   ...          ...
  1066	        mount = g_volume_get_mount (volume);
  1067	        if (mount != NULL) {
   ...              ...
  1088	        } else {
  1089	            /* see comment above in why we add an icon for an unmounted mountable volume */
   ...              ...
  1099	        }
  1100	        g_object_unref (volume);
  1101	    }
  1102	    g_list_free (volumes);
   ...
</pre>

		<h2>Возможное решение 1</h2>

		<p>
			Убираем ненужные строки в исходнике, компилируем доработанную версию Nemo и устанавливаем его в систему.

		<p>
			Достоинства:
			<ul>
				<li>
					очень элегантное решение (объем кода, а следовательно, размер программы уменьшается!);
			
				<li>
					100% будет работать.
			</ul>

		<p>
			Недостатки:
			<ul>
				<li>
					для компиляции и сборки, кроме собственно <em>gcc</em>, <em>make</em> и набора библиотек Gnome для 
					разработчика, придется установить дополнительные утилиты: всякие <em>autotools</em> и т.п. А после 
					того как все заработает, придется еще очистить систему от ненужных более пакетов;

				<li>
					придется всегда хранить на компьютере исходники Nemo, иначе не 	получиться удалить программу 
					(справедливости ради стоит отметить, что можно создать свой <i>.deb</i>-пакет из исходных текстов, 
					затем обращаться с ним так же, как с обычными пакетами);

				<li>
					как только Nemo установлен (неважно, из исходных текстов или из "самопального" пакета), его уже не 
					получиться обновлять из официальных репозиториев (а если и можно было бы, официальная версия Nemo 
					затерла бы нашу, доработанную, и мы пришли бы к тому, с чего начали).
			</ul>

		<h2>Возможное решение 2</h2>

		<p>
			Вносим изменения в конфигурацию 
			<a href="https://git.gnome.org/browse/gvfs/tree/monitor/udisks2/what-is-shown.txt">
			gvfs-udisks2-volume-monitor</a>, чтобы прослойка между Nemo и ядром рапортовала об отсутствии 
			томов, если те не были смонтированы 
			<sup id="footnote-2-top"><a href="#footnote-2-bottom">[2]</a></sup>.

		<p>
			Достоинства:
			<ul>
				<li>
					не придеться трогать Nemo вообще;

				<li>
					скорее всего будет работать.
			</ul>

		<p>
			Недостатки:
			<ul>
				<li>
					изменения затронут не только Nemo, но и другие программы, которые используют возможности GVfs. Что 
					нежелательно (например, для программы записи компакт-дисков).
			</ul>

		<h2>Возможное решение 3</h2>

		<p>
			Перехватываем функцию библиотеки Gnome, которая отвечает за перечисление томов (несмонтированных в том 
			числе), отбрасываем несмонтированные тома и возвращаем отфильтрованный список Nemo. Nemo "увидит" только 
			смонтированные тома. Этому подходу и посвящена 
			<a href="how-to-hide-non-mounted-drives-part-2.html">часть 2</a>.

        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Слово "диск" не совсем уместно. Правильнее было бы сказать "том". Том не обязательно 
						соответствует разделу на физическом диске. Например, несколько физических дисков можно 
						объединить в один большой том посредством RAID. Или же несколько областей на физическом диске 
						можно объединить в том с помощью LVM.

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 
						Я так и не разобрался, что все это значит: <em>udisks</em>, <em>GVfs</em>, 
						<em>volume-monitor</em> и т.д. Возможно, этот пункт стоит выкинуть вообще, но я его оставлю на 
						всякий случай.
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
