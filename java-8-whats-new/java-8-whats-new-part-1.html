<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Новое, клевое и хреновое в Java 8. Часть 1. Потоки.</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-8-whats-new/java-8-whats-new-part-1.html">
				Новое, клевое и хреновое в Java 8. Часть 1. Потоки.
			</a>
		</h1>
		
		<h3>[2017, Ноябрь]</h3>

		<h3>
			<a href="how-to-hide-non-mounted-drives-part-2.html">Часть 2</a>
			|
			<a href="how-to-hide-non-mounted-drives-part-3.html">Часть 3</a>
			|
			<a href="how-to-hide-non-mounted-drives-epilogue.html">Эпилог</a>
			|
			<a href="https://github.com/flaz14/flaz14.github.io/tree/master/how-to-hide-non-mounted-drives/code">
				Исходный код
			</a>
		</h3>

		<h2>Начало</h2>

		<p>
			Эта ламерская статья проведет вас по пути джедая (это я просто так болтаю, звездные войны смотрел отрывками
			очень давно, так что толком оттуда ничего не знаю) через дебри Java 8. Может сложится впечатление, что в Java 8
			много всего нового. Но это не так. И вообще, в свете последних веяний в области Computer Science (а именно:
			искусственный интеллект) большинство из 
			современных языков программирования недалеко ушли от Pascal и/или C. Так что здесь мы сосредоточимся на 
			практическом применении Java 8 в энтэрпрайзных приложениях.
			
		<h2>Предостережения</h2>
			К каждому из примера. И с помешательством на внутренних классах. Так что не 
			уди
			Тесты написаны с использованием JUnit 4 в стиле Java 7. Просто чтобы заострить внимание на основном коде, а 
			не распылять его на тестовый.
			
			В примерах везде нету getter-ов и setter-ов. Чтобы не захламлять ими код примеров. А вот полные имена импортируемых 
			из JDK классов я оставил для наглядности. 
			
			Проверку вложенных полей на null я намерено пропустил. О ней поговорим в одной из следующих частей. Пока что
			не знаю, в какой.

		<h2>Ссылки на методы и конструкторы</h2>
		
		<p>
			Пожалуй, почти в каждом корпоративном приложении есть БД, в которой хранятся сведения о клиентах. А для 
			внешнего мира они доступны через REST API. Рассмотрим пример, когда у нас есть для представление клиента 
			используется класс Customer. Поскольку данные о месте проживания клиента важны для бизнеса, они представлены
			в виде класса Address. Вместе это выглядит примерно так:
			
		<p>
			Пусть нам дан список клиентов. А задача заключается в том, чтобы поместить улицы, на которых проживают клиенты,
			в другой список.
			Попробуем сделать это в стиле Java 8.
			
			
Java 7		
<pre>
/usr/local/soft/jdk1.8.0_111/bin/java -ea -Didea.launcher.port=7533 -Didea.launcher.bin.path=/usr/local/soft/idea-IC-139.1603.1/bin -Dfile.encoding=UTF-8 -classpath /usr/local/soft/idea-IC-139.1603.1/lib/idea_rt.jar:/usr/local/soft/idea-IC-139.1603.1/plugins/junit/lib/junit-rt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/resources.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/plugin.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/charsets.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/rt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/deploy.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jfr.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/management-agent.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/javaws.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jsse.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jce.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jfxswt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunpkcs11.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunec.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/nashorn.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/dnsns.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/jaccess.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/jfxrt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/cldrdata.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/zipfs.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/localedata.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunjce_provider.jar:/home/yura/Projects/flaz14.github.io/java-8-whats-new/code/java-8-whats-new/target/test-classes:/usr/local/soft/idea-IC-139.1603.1/lib/junit-4.11.jar:/usr/local/soft/idea-IC-139.1603.1/lib/hamcrest-core-1.3.jar:/usr/local/soft/idea-IC-139.1603.1/lib/hamcrest-library-1.3.jar:/home/yura/.m2/repository/junit/junit/4.12/junit-4.12.jar:/home/yura/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar com.intellij.rt.execution.application.AppMain com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 example.ExtractingNestedFieldTest,java7

java.lang.IllegalStateException: This is workaround for demonstrating nasty Java 8 stacktraces.
	at example.Address.country(ExtractingNestedFieldTest.java:177)
	at example.ExtractingNestedFieldTest$CountriesExtractor.java7(ExtractingNestedFieldTest.java:95)
	at example.ExtractingNestedFieldTest.java7(ExtractingNestedFieldTest.java:21)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)


Process finished with exit code 255
</pre>		
		
		
			
			
			
Java 8		
<pre>
/usr/local/soft/jdk1.8.0_111/bin/java -ea -Didea.launcher.port=7532 -Didea.launcher.bin.path=/usr/local/soft/idea-IC-139.1603.1/bin -Dfile.encoding=UTF-8 -classpath /usr/local/soft/idea-IC-139.1603.1/lib/idea_rt.jar:/usr/local/soft/idea-IC-139.1603.1/plugins/junit/lib/junit-rt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/resources.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/plugin.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/charsets.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/rt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/deploy.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jfr.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/management-agent.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/javaws.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jsse.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jce.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/jfxswt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunpkcs11.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunec.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/nashorn.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/dnsns.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/jaccess.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/jfxrt.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/cldrdata.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/zipfs.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/localedata.jar:/usr/local/soft/jdk1.8.0_111/jre/lib/ext/sunjce_provider.jar:/home/yura/Projects/flaz14.github.io/java-8-whats-new/code/java-8-whats-new/target/test-classes:/usr/local/soft/idea-IC-139.1603.1/lib/junit-4.11.jar:/usr/local/soft/idea-IC-139.1603.1/lib/hamcrest-core-1.3.jar:/usr/local/soft/idea-IC-139.1603.1/lib/hamcrest-library-1.3.jar:/home/yura/.m2/repository/junit/junit/4.12/junit-4.12.jar:/home/yura/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar com.intellij.rt.execution.application.AppMain com.intellij.rt.execution.junit.JUnitStarter -ideVersion5 example.ExtractingNestedFieldTest,java8Stream

java.lang.IllegalStateException: This is workaround for demonstrating nasty Java 8 stacktraces.
	at example.Address.country(ExtractingNestedFieldTest.java:177)
	at example.ExtractingNestedFieldTest$CountriesExtractor$Java8.lambda$stream$1(ExtractingNestedFieldTest.java:116)
	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)
	at java.util.Spliterators$ArraySpliterator.forEachRemaining(Spliterators.java:948)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
	at example.ExtractingNestedFieldTest$CountriesExtractor$Java8.stream(ExtractingNestedFieldTest.java:117)
	at example.ExtractingNestedFieldTest.java8Stream(ExtractingNestedFieldTest.java:33)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)


Process finished with exit code 255
</pre> 


Надо не забыть написать про порядок выполнения операций. Т.е. проверка того, что поле address в объекте класса Customer
не равно null (т.о. мы предотвращаем NullPointerException) с помощью фильтра не приведет к дополнительной итерации по 
списку Customer'ов. Об этой особенности потоков Java 8 написал Бенжамин.


The order of the result might be surprising. A naive approach would be to execute the operations horizontally one after another on all elements of the stream. But instead each element moves along the chain vertically. The first string "d2" passes filter then forEach, only then the second string "a2" is processed. 














		<h4 id="illustration-1-1">
				Рисунок 1.1 - пример отображения несмонтированного раздела на боковой панели Nemo
		</h4>
		<p>
			<img src="illustrations/nemo-sidebar-with-unmounted-drive-visible.png" width="240px"
			alt="здесь изображена фрагмент скриншота программы Nemo">

		<p>
			К сожалению, в Nemo нет возможности скрыть несмонтированные тома. Я облазил все настройки и ничего 
			связанного с этим не нашел. Действительно, судя по исходному коду Nemo (здесь и далее рассматривается версия
			<b>2.4.5</b>, но в последней версии <b>3.0.6</b> то же самое), отвечающему за отображение значков на боковой
			панели, фрагмент которого приведен в <a href="#listing-1-1">листинге 1.1</a> (многие строки опущены для 
			краткости), это поведение никак не настраивается и не отключается. Это подтверждается и комментариями в 
			строках 
<a 
href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c#L992">
№№992-999</a> и 
<a
href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c#L1089">
№1089</a>.

<h4 id="listing-1-1">Листинг 1.1 - фрагмент файла 
<a 
href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c">
nemo-places-sidebar.c
</a>
</h4>
<pre>
   ...
   946	    /* first go through all connected drives */
   947	    drives = g_volume_monitor_get_connected_drives (volume_monitor);
   948	
   949	    for (l = drives; l != NULL; l = l->next) {
   950	        drive = l->data;
   951	
   952	        volumes = g_drive_get_volumes (drive);
   953	        if (volumes != NULL) {
   954	            for (ll = volumes; ll != NULL; ll = ll->next) {
   ...                  ...
   965	                mount = g_volume_get_mount (volume);
   966	                if (mount != NULL) {
   967	                    /* Show mounted volume in the sidebar */
   ...                      ...
   991	                } else {
   992	                    /* Do show the unmounted volumes in the sidebar;
   993	                     * this is so the user can mount it (in case automounting
   994	                     * is off).
   995	                     *
   996	                     * Also, even if automounting is enabled, this gives a visual
   997	                     * cue that the user should remember to yank out the media if
   998	                     * he just unmounted it.
   999	                     */
   ...                      ...
  1014	                }
  1015	                g_object_unref (volume);
  1016	            }
  1017	            g_list_free (volumes);
   ...              ...
  1045	
  1046	    /* add all volumes that is not associated with a drive */
  1047	    volumes = g_volume_monitor_get_volumes (volume_monitor);
  1048	    for (l = volumes; l != NULL; l = l->next) {
   ...          ...
  1066	        mount = g_volume_get_mount (volume);
  1067	        if (mount != NULL) {
   ...              ...
  1088	        } else {
  1089	            /* see comment above in why we add an icon for an unmounted mountable volume */
   ...              ...
  1099	        }
  1100	        g_object_unref (volume);
  1101	    }
  1102	    g_list_free (volumes);
   ...
</pre>

		<h2>Возможное решение 1</h2>

		<p>
			Убираем ненужные строки в исходнике, компилируем доработанную версию Nemo и устанавливаем его в систему.

		<p>
			Достоинства:
			<ul>
				<li>
					очень элегантное решение (объем кода, а следовательно, размер программы уменьшается!);
			
				<li>
					100% будет работать.
			</ul>

		<p>
			Недостатки:
			<ul>
				<li>
					для компиляции и сборки, кроме собственно <em>gcc</em>, <em>make</em> и набора библиотек Gnome для 
					разработчика, придется установить дополнительные утилиты: всякие <em>autotools</em> и т.п. А после 
					того как все заработает, придется еще очистить систему от ненужных более пакетов;

				<li>
					придется всегда хранить на компьютере исходники Nemo, иначе не 	получиться удалить программу 
					(справедливости ради стоит отметить, что можно создать свой <i>.deb</i>-пакет из исходных текстов, 
					затем обращаться с ним так же, как с обычными пакетами);

				<li>
					как только Nemo установлен (неважно, из исходных текстов или из "самопального" пакета), его уже не 
					получиться обновлять из официальных репозиториев (а если и можно было бы, официальная версия Nemo 
					затерла бы нашу, доработанную, и мы пришли бы к тому, с чего начали).
			</ul>

		<h2>Возможное решение 2</h2>

		<p>
			Вносим изменения в конфигурацию 
			<a href="https://git.gnome.org/browse/gvfs/tree/monitor/udisks2/what-is-shown.txt">
			gvfs-udisks2-volume-monitor</a>, чтобы прослойка между Nemo и ядром рапортовала об отсутствии 
			томов, если те не были смонтированы 
			<sup id="footnote-2-top"><a href="#footnote-2-bottom">[2]</a></sup>.

		<p>
			Достоинства:
			<ul>
				<li>
					не придеться трогать Nemo вообще;

				<li>
					скорее всего будет работать.
			</ul>

		<p>
			Недостатки:
			<ul>
				<li>
					изменения затронут не только Nemo, но и другие программы, которые используют возможности GVfs. Что 
					нежелательно (например, для программы записи компакт-дисков).
			</ul>

		<h2>Возможное решение 3</h2>

		<p>
			Перехватываем функцию библиотеки Gnome, которая отвечает за перечисление томов (несмонтированных в том 
			числе), отбрасываем несмонтированные тома и возвращаем отфильтрованный список Nemo. Nemo "увидит" только 
			смонтированные тома. Этому подходу и посвящена 
			<a href="how-to-hide-non-mounted-drives-part-2.html">часть 2</a>.

        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Слово "диск" не совсем уместно. Правильнее было бы сказать "том". Том не обязательно 
						соответствует разделу на физическом диске. Например, несколько физических дисков можно 
						объединить в один большой том посредством RAID. Или же несколько областей на физическом диске 
						можно объединить в том с помощью LVM.

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 
						Я так и не разобрался, что все это значит: <em>udisks</em>, <em>GVfs</em>, 
						<em>volume-monitor</em> и т.д. Возможно, этот пункт стоит выкинуть вообще, но я его оставлю на 
						всякий случай.
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
