<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Новое, клёвое и хреновое в Java 8. Часть 2. Unit-тесты</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-8-whats-new/java-8-whats-new-part-2.html">
				Новое, клёвое и хреновое в Java 8. Часть 2. Unit-тесты
			</a>
		</h1>
		
		<h3>[2017, Ноябрь]</h3>

		<h3>
			<a href="java-8-whats-new-part-1.html">Часть 1. Потоки</a>
			|
			<a href="java-8-whats-new-part-3.html">Часть 3. Внутренние классы</a>
			|
			<a href="https://github.com/flaz14/flaz14.github.io/tree/master/java-8-whats-new/code/java-8-whats-new">
				Исходный код
			</a>
		</h3>
		
		<h2></h2>
		
		<p>
			Привычные библиотеки преобразились с выходом Java 8. Так, JUnit 5 стал совсем не похож на JUnit 4. Так, 
			благодаря лямбда-выражениям, отпала необходимость в т.н. <code>Rule</code>'ах (в частности, для проверки
			исключений). Но JUnit 4 рано отправлять на свалку истории. И не только потому, что  
			чрезмерное использование новых возможностей приводит к усложнению тестового кода. И в то же время такие
			"навороченные" тесты недотягивают до полноценной спецификации (а "наворотов" в JUnit 5 полным-полно). 
			Даже до сценариев JBehave им как до Луны. 
			Правило простое: если код тестов получился сложным, это значит, что основной код приложения вышел еще сложнее.
			В этом случае и то, и другое надо рефакторить.
		
		<p>
			Так что JUnit 4 все еще живет и здравствует. А Java 8 способна вдохнуть в привычную библиотеку новую жизнь.
			Да не напрасно эта ламерская заметка будет написана.
			
		<h2>Использование ссылок на методы в теориях</h2>
		
		<p>
			Пусть нам нужно протестировать несколько реализаций одного и того же интерфейса. Возьмем для примера такой
			(все упрощено до предела):
			
<pre>
public interface Calculator {
    int multiplyByTwo(int input);
}
</pre>

		<p>
			Заготовим три реализации:
			
			<ol>
				<li>
					<p>
<pre>
public class UsualCalculator implements Calculator {
    @Override
    public int multiplyByTwo(int input) {
        return input * 2;
    }
}
</pre>

				<li>
					<p>
<pre>
public class SmartCalculator implements Calculator {
    @Override
    public int multiplyByTwo(int input) {
        return input << 1;
    }
}
</pre>

				<li>
					<p>
<pre>
public class StupidCalculator implements Calculator {
    @Override
    public int multiplyByTwo(int input) {
        return input + input;
    }
}
</pre>
			</ol>
		
		<p>	
			Если нужно протестировать эти реализации, то можно поступить так: создать базовый класс и поместить в него 
			тесты. И добавить абстрактный метод, который в качестве возвращаемого значения имеет интерфейс.
			А в классах-наследниках этот метод переопределим таким образом, чтобы он возвращал конкретную реализацию.
			Базовый класс выглядит это примерно так:
<pre>
public abstract class CalculatorJava7TestSupport {

    /**
     * Override this method and initialize certain implementation of the calculator there.
     */
    protected abstract Calculator calculatorImplementation();

    @Test
    public void returnsZero_whenInputIsZero() {
        final int result = calculatorImplementation().multiplyByTwo(0);
        assertThat(result, is(0));
    }

    @Test
    public void returnsTwo_whenInputIsOne() {
        final int result = calculatorImplementation().multiplyByTwo(1);
        assertThat(result, is(2));
    }
}
</pre>

		<p>
			А вот пример теста для реализации <strong>UsualCalculator</strong>:
<pre>
public class UsualCalculatorJava7Test extends CalculatorJava7TestSupport {
    @Override
    protected Calculator calculatorImplementation() {
        return new UsualCalculator();
    }
}
</pre>

		<p>
			Все просто, не так ли?
			
		<p>
			Но как же круто будет избавиться от лишних классов и запихнуть все в один тест. С теориями 
			!!!JUnit 4 здесь будет ссылка!!! это возможно. Получилось так:
			
<pre>
@RunWith(Theories.class)
public class CalculatorJava8NaiveTest {

    @DataPoints
    public static final Calculator[] CALCULATORS = {
            new UsualCalculator(),
            new SmartCalculator(),
            new StupidCalculator()
    };

    @Theory
    public void returnsZero_whenInputIsZero(final Calculator calculator) {
        final int result = calculator.multiplyByTwo(0);
        assertThat(result, is(0));
    }

    @Theory
    public void returnsTwo_whenInputIsOne(final Calculator calculator) {
        final int result = calculator.multiplyByTwo(1);
        assertThat(result, is(2));
    }
}
</pre>

		<p>
			Можно добавить Java 8. Ссылки на методы бесполезны в данном случае, но такой вариант тоже работает:
<pre>
@RunWith(Theories.class)
public class CalculatorJava8NaiveTest {

    @DataPoints
    public static final Calculator[] CALCULATORS = {
            new UsualCalculator(),
            new SmartCalculator(),
            new StupidCalculator()
    };

    @Theory
    public void returnsZero_whenInputIsZero(final Calculator calculator) {
        final int result = calculator.multiplyByTwo(0);
        assertThat(result, is(0));
    }

    @Theory
    public void returnsTwo_whenInputIsOne(final Calculator calculator) {
        final int result = calculator.multiplyByTwo(1);
        assertThat(result, is(2));
    }
}
</pre>		
	
		<p>
			Остается только добавить, что если что-то в теории пойдет не так, сообщение об ошибке будет мало полезным.
			В стэктрэйса мы увидим только индекс параметра теории (т.е. индекс элемента в массиве). А конкретное его 
			значение - нет. Чтобы продемонстрировать это добавим в реализацию <strong>SmartCalculator</strong> такой код:
<pre>
if (input == 1) {
    throw new IllegalStateException(
            "This exception is for demonstrating JUnit's magic error messages."
    );
}
</pre>
		
		<p>
			Запустим и получим:
			<ul>
				<li>
					<p>Для способа с теориями:
<pre>
org.junit.experimental.theories.internal.ParameterizedAssertionError: returnsTwo_whenInputIsOne(CALCULATORS[1])
	at org.junit.experimental.theories.Theories$TheoryAnchor.reportParameterizedError(Theories.java:192)
	at org.junit.experimental.theories.Theories$TheoryAnchor$1$1.evaluate(Theories.java:146)
	at org.junit.experimental.theories.Theories$TheoryAnchor.runWithCompleteAssignment(Theories.java:127)
	at org.junit.experimental.theories.Theories$TheoryAnchor.runWithAssignment(Theories.java:111)
	at org.junit.experimental.theories.Theories$TheoryAnchor.runWithIncompleteAssignment(Theories.java:120)
	at org.junit.experimental.theories.Theories$TheoryAnchor.runWithAssignment(Theories.java:109)
	at org.junit.experimental.theories.Theories$TheoryAnchor.evaluate(Theories.java:96)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runners.Suite.runChild(Suite.java:127)
	at org.junit.runners.Suite.runChild(Suite.java:26)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
Caused by: java.lang.IllegalStateException: This exception is for demonstrating JUnit's magic error messages.
	at calc.SmartCalculator.multiplyByTwo(SmartCalculator.java:7)
	at test.calc.java8.CalculatorJava8PureTest.returnsTwo_whenInputIsOne(CalculatorJava8PureTest.java:33)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.experimental.theories.Theories$TheoryAnchor$2.evaluate(Theories.java:175)
	at org.junit.experimental.theories.Theories$TheoryAnchor$1$1.evaluate(Theories.java:141)
	... 31 more
</pre>

			</ul>
				<p>
					Для примитивного способа:
<pre>
java.lang.IllegalStateException: This exception is for demonstrating JUnit's magic error messages.
	at calc.SmartCalculator.multiplyByTwo(SmartCalculator.java:7)
	at test.calc.java7.CalculatorJava7TestSupport.returnsTwo_whenInputIsOne(CalculatorJava7TestSupport.java:24)
</pre>

		<p>
			Все-таки продвинутое не всегда лучше примитивного. 
			
		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
