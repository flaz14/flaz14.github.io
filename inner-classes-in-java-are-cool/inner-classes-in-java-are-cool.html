<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Внутренние классы в Java - классные!</title>
	</head>
	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
		
		<hr>
		
		<h1>
			<a href="http://flaz14.github.io/inner-classes-in-java-are-cool/inner-classes-in-java-are-cool.html">
				Внутренние классы в Java - классные!
			</a>
		</h1>
		
		<h3>[2017, Февраль]</h3>
		
		Внутренние классы, они же вложенные классы (inner classes, nested classes) появились в Java версии 1.1 (не 
		уверен насчет 1.1,
		знакомые Java-эксперты говорят, что в версии 1.1.8 внутренние классы точно были). 
		Как говорится в 
		<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">
			официальном туториале от Oracle
		</a> внутренние классы (тут немного по-другому сказано, но основные идеи те же):
		
		<ul>
			<li>
				помогают сгруппировать основной класс и его "помощник" в одном месте, т.е. без необходимости оформлять 
				вспомогательный
				класс в виде публичного класса;
			
			<li>
				улучшают инкапсуляцию: вспомогательный можно сделать невидимым за пределами основного класса;
				
			<li>
				придают коду дополнительную удобоваримость.
		</ul>
    
		Посмотрим, на что способны внутренние классы.
		
		<h2>Немного о "песочнице"</h2>

		Все примеры сделаны в виде Maven-проекта (тут будет ссылка на исходный код). Для каждого примера - свой 
		класс/файл/пакет.
		Каждое заметное улучшение кода предствлено в виде нового класса. Все примеры приводятся с тестами, и могут быть 
		выполнены
		из командной строки.
		
		<h2>Группировка констант</h2>
		
		В своей рутинной работе я часто сталкиваюсь с примерно таким кодом (в остовном в тестах):
		
		Листинг 1 - PlainOldConstants_1_Test - примитивный подход к константам в тестах
		
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_1_PlainOldApproach_Test {

    private static final String CUSTOMER_ID = "12345";
    private static final String INVALID_CUSTOMER_ID = "!!!";
    private static final String NON_EXISTING_CUSTOMER_ID = "000";

    @Test
    public void someTest() throws Exception {
        System.out.println(CUSTOMER_ID);
        System.out.println(INVALID_CUSTOMER_ID);
        System.out.println(NON_EXISTING_CUSTOMER_ID);
    }
}
</pre>
		
		Первое, что бросается в глаза и что хотелось бы улучшить - это имена констант. Так, в имени каждой константы 
		повторяются
		слова <tt>CUSTOMER_ID</tt>. Само по себе дублирование кода в тестах - не так уж и плохо. Тем более, что два 
		слова - не пять.
		Но чтобы использовать такие константы в коде, приходится больше печатать. Потому что одна константа начинается со слова
		<tt>CUSTOMER</tt>, вторая - со слова <tt>INVALID</tt>, а третья с другого слова. Т.о. функция автодополнения IDE не сильно 
		помогает. Кроме этого, каждая из констант - самостоятельное, не связанное с другими, поле класса. В зависимости от того, 
		как исходный код отформатирован, логически связанные константы могут быть разбросанными по всему классу. Что ухудшает 
		читаемость кода. Да, можно задействовать formatter и отсортировать константы в алфавитном порядке, но 
		откуда ему знать, что все эти константы имеют отношение к одной сущности? Чтобы учесть логическую связь придется
		 использоватьочень нетривиальные средства форматирования исходного кода. Что, попробуем переделать констатны с 
		 использованием	внутреннего класса.
		
		Листинг 2 - константы сгруппированы с помощью внутреннего класса
		
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_2_InnerClass_Test {

    private static class CustomerId {
        private static final String VALID = "12345";
        private static final String INVALID = "!!!";
        private static final String NON_EXISTING = "000";
    }

    @Test
    public void someTest() throws Exception {
        System.out.println(CustomerId.VALID);
        System.out.println(CustomerId.INVALID);
        System.out.println(CustomerId.NON_EXISTING);
    }
}
</pre>	

		Выглядит лучше. Прежде всего, все константы находятся внутри вспомогательного класса. Т.е. никакое, даже самое 
		дикое форматирование
		исходного текста не сможет разлучить их. Имя вспомогательного класса - говорящее. Так что нет нужды дублировать слова
		CUSTOMER и ID в именах самих констант. И IDE нам поможет: не надо держать в голове все возможные вариации 
		идентификаторов клиента,
		достаточно набрать Cust - IDE предложит дополнить до CustomerId. После набора точки IDE выведет список вариантов - осталось
		только выбрать нужный. Тем не менее, внутренний статический класс выглядит громоздким. И в самом деле, мы уменьшили
		длину имени каждой константы, но добавили строчку <code>private static class CustomerId {</code>. Так что не такое уж 
		изящное получилось решение. Попробуем убрать лишнее.
		
		Листинг 3 - улучшенный класс для группировки констант
		
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_3_EnhancedInnerClass_Test {

    private static class CustomerId {
        static final String VALID = "12345";
        static final String INVALID = "!!!";
        static final String NON_EXISTING = "000";
    }

    @Test
    public void someTest() throws Exception {
        System.out.println(CustomerId.VALID);
        System.out.println(CustomerId.INVALID);
        System.out.println(CustomerId.NON_EXISTING);
    }
}
</pre>
		
		Модификатор <code>private</code> с <code>CustomerId</code> убирать не будем, иначе выставим напоказ константы, 
		которые другие
		классы интересовать не должны. От модификатора <code>static</code> тоже никуда не денешься. А вот модификатор
		<code>private</code> с собственно самих констант можно убрать. Поле вложенного класса всегда доступно из класса, в который
		он вложен (да-да, в листинге 2 сами константы приватные, и тем не менее, их можно прочитать в методе someTest). Так что 
		можно оставить константы с модификатором по-умолчанию, т.е. с доступом package-private. Но, поскольку класс CustomerId
		приватный, то и все, что в нем находится, будет невидимо для внешнего мира, невзирая на структуру пакетов. Продемонстрируем это
		
		Создадим пакет <code>package com.github.flaz14.foo</code>. И добавим в него такой тест:
		
			
		Листинг 4 - приватный вложенный класс виден только в классе, в который он вложен
		
<pre>
package com.github.flaz14.foo;

import org.junit.Test;

public class VisibilityOfInnerClassTest {

    @Test
    public void packagePrivateFieldsOfPrivateInnerClass() throws Exception {
        System.out.println(
                com.github.flaz14.grouping.Constants_3_EnhancedInnerClass_Test.CustomerId.VALID
        );
    }
}
</pre>
		
		Попробуем скомпилировать и получим:
		
<pre>
[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /home/yura/Projects/flaz14.github.io/inner-classes-in-java-are-cool/code/inner-classes/src/test/java/com/github/flaz14/foo/VisibilityOfInnerClassTest.java:[10,79] com.github.flaz14.grouping.Constants_3_EnhancedInnerClass_Test.CustomerId has private access in com.github.flaz14.grouping.Constants_3_EnhancedInnerClass_Test
[INFO] 1 error
[INFO] -------------------------------------------------------------
</pre>		
		
		То же самое будет и при любом модификоре поля, главное, чтобы сам вложенный класс был приватным.
		
		Т.о. образом привиденный в листинге 3 класс оптимально подходит для группировки костант [1].
		
		
		
		<h2>Почему не enum?</h2>
		
		Попробуем сгруппировать константы, но с помощью enum:
		
		Листинг 5 - константы оформленные в виде enum
		
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_3_Enum_Test {

    private enum CustomerId {
        VALID("12345"),
        INVALID("!!!"),
        NON_EXISTING("000");

        public final String id;

        private CustomerId(String id) {
            this.id = id;
        }
    }

    @Test
    public void someTest() throws Exception {
        System.out.println(CustomerId.VALID.id);
        System.out.println(CustomerId.INVALID.id);
        System.out.println(CustomerId.NON_EXISTING.id);
    }
}
</pre>
		
		Очевидно, что использование enum ведет к чрезмерному усложнению при той же функциональности. Да, enum вне конкуренции
		в случаях общедоступных классов, которые повторно используются во многих частях программы. Но если константы релевантны
		только в пределах одного класса, лучше упаковать их во внутренний класс.
		
		
		<h2>Не только константы, но и разнообразные фабрики</h2>
		
		Как часто приходиться использовать в тестах всякого рода DTO, Entity и прочие классы, которые в С++ - просто struct.
		
		Что ж, внутренние классы можно применить и тут. Например,
		
<pre>
package com.github.flaz14.factory;

import org.junit.Test;

public class DtoFactoryTest {

    private static class Customer {
        static CustomerDto withMandatoryFields() {
            return new CustomerDto();
        }

        static class WithBankDetails {
            static CustomerDto apparent() {
                CustomerDto dto = new CustomerDto();
                // set up some credit card number fully
                // ...
                return dto;
            }

            static CustomerDto obscured() {
                CustomerDto dto = new CustomerDto();
                // set up credit card number in the form of XXXX XXXX XXXX 1234
                // ...
                return dto;
            }
        }
    }

    @Test
    public void test() throws Exception {
        CustomerDto expected = Customer.WithBankDetails.obscured();
        // ...
    }
}

class CustomerDto {
    // ...
}
</pre>
		
		Тут все очевидно [2]. Шаблонов (т.е. не шаблонов проектирования, а "маленьких" шаблонов - implementation patterns 
		!!!!!Тут будет ссылка на книгу Kent Beck - Implementation Patterns, может, и не будет!!!!!
		 ) можно привести множество: Exception Factory, Logger Factory, Builder и т.д.
		 
		Внутренние классы не обязательно должны быть статическими. Можно использовать и нестатические классы. С точки зрения
		читаемости будет мозолить глаза только ключевое слово <code>new</code>. Но это не страшно. Тем более, что обычные
		внутренние классы имеют доступ к intance-полям объектов окружающего класса. Что приносит неожиданные преимущества.
		
		В качестве примера !!!Тут будет пример, правда, я его еще не придумал!!!
		
		
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						
						Для пущей константности можно было бы добавить к классу <code>CustomerId</code> модификтор 
						<code>final</code>, но это излишне - класс <code>CustomerId</code> невидим для внешнего мира. Вряд ли
						кому-то придет в голову написать еще один внутренний класс и в новом классе унаследовать 
						<code>CustomerId</code>.

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 					
						Почему мы для использовали всегда статические методы вместо того, чтобы раз и навсегда создать
						объекты-константы. Потому что пример был о factory-методах. Но не только поэтому. Часто классы-сущности 
						не являются неизменяемыми (immutable) объектами. Поэтому в тестах возможна их (случайная) модификация объектов.
						А вот при использовании factory-метода о такого рода ошибках можно забыть (вообще, неизменяемые объекты - 
						отдельная тема, то же можно сказать про порядком поднадоевший модификатор <code>final</code>).
						После описанных выше манипуляций нельзя будет изменить системное время из апплета на панели 
						задач. Но это не проблема: запускаем <code>gksudo cinnamon-settings</code> и меняем что душе 
						угодно (правда, тут надо быть осторожным, чтобы не испортить другие настройки).
						
				<li id="footnote-3-bottom">
					<p>
						<a href="#footnote-3-top" title="Перейти к основному тексту">&uarr;</a> 
						Если в системе все-таки есть пользователь <strong>root</strong> (т.е. если он был добавлен 
						вручную), нужно установить для него сложный (лучше - "невзламываемый", длиной около 50 случайных
						символов) пароль.
			</ol>
			
		<hr>
		
		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
