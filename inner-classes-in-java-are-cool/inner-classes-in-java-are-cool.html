<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Внутренние классы в Java - классные!</title>
	</head>
	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
		
		<hr>
		
		<h1>
			<a href="http://flaz14.github.io/inner-classes-in-java-are-cool/inner-classes-in-java-are-cool.html">
				Внутренние классы в Java - классные!
			</a>
		</h1>
		
		<h3>[2017, Февраль]</h3>
		
		<h2>Немного теории</h2>
			
		<p>
			Внутренние классы (inner classes), они же вложенные классы (nested classes), появились в Java версии 1.1 (не 
			уверен насчет 1.1, знакомые Java-эксперты говорят, что в версии 1.1.8 внутренние классы точно были). Как 
			говорится в 
			<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">
				официальном туториале от Oracle
			</a>
			внутренние классы:
			<ul>
				<li>
					помогают разместить основной класс и его "помощник" в одном месте и избавляют от создания нового 
					файла для вспомогательного класса;
			
				<li>
					улучшают инкапсуляцию: вспомогательный класс можно сделать невидимым за пределами основного класса;
				
				<li>
					придают коду дополнительную удобоваримость.
			</ul>
    
		
		<h2>О "песочнице"</h2>

		<p>
			Все примеры оформлены в виде Maven-проекта (тут будет ссылка на исходный код). Для каждого примера 
			(следовательно, для каждого листинга)- свой класс. Каждое заметное улучшение кода предствлено в виде нового 
			класса. Имена классов нестандартные. Это нужно для того, чтобы файлы отображались в IDE в том же порядке, в 
			каком они упоминаются в статье.
		
		<h2>Группировка констант</h2>
		
		<p>
			В своей рутинной работе я часто сталкиваюсь с примерно таким кодом (в остовном в тестах):
		
		<h4 id="listing-1">Листинг 1 - PlainOldConstants_1_Test - примитивный подход к константам в тестах</h4>	
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_1_PlainOldApproach_Test {

    private static final String CUSTOMER_ID = "12345";
    private static final String INVALID_CUSTOMER_ID = "!!!";
    private static final String NON_EXISTING_CUSTOMER_ID = "000";

    @Test
    public void someTest() throws Exception {
        System.out.println(CUSTOMER_ID);
        System.out.println(INVALID_CUSTOMER_ID);
        System.out.println(NON_EXISTING_CUSTOMER_ID);
    }
}
</pre>

		<p>
			Первое, что бросается в глаза и что хотелось бы улучшить - это имена констант. Так, в имени каждой константы 
			повторяeтся <tt>CUSTOMER_ID</tt>. Само по себе дублирование чего бы то ни было в тестах - не так уж плохо. 
			Тем более, что два слова - не пять.	Но чтобы использовать такие константы в коде, приходиться больше 
			печатать. И функция автодополнения в IDE не силоно помогает. Потому что одна константа начинается со слова
			<tt>CUSTOMER</tt>, вторая - со слова <tt>INVALID</tt>, а третья с совершенно другого слова.	Кроме этого, 
			каждая из констант - самостоятельное, не связанное с другими, поле класса. В зависимости от того, как 
			исходный код отформатирован, логически связанные константы могут быть или собраны в одном месте, или 
			разбросаны по всему файлу (или перемешанными с константами другого рода). Что ухудшает читаемость кода. Да, 
			можно задействовать formatter и отсортировать константы в алфавитном порядке, но откуда ему знать, что все 
			эти константы имеют отношение к одной сущности? Чтобы учесть логическую связь придеться	использоватьочень 
			нетривиальные средства форматирования исходного кода. 
			
		<p>
			Призовем на помощь внутренний класс и получим <a href="#listing-2">листинг 2</a>!
		
		<h4 id="#listing-2">
			Листинг 2 - тут будет имя класса и ссылка на github - константы сгруппированы с помощью внутреннего класса
		</h4>		
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_2_InnerClass_Test {

    private static class CustomerId {
        private static final String VALID = "12345";
        private static final String INVALID = "!!!";
        private static final String NON_EXISTING = "000";
    }

    @Test
    public void someTest() throws Exception {
        System.out.println(CustomerId.VALID);
        System.out.println(CustomerId.INVALID);
        System.out.println(CustomerId.NON_EXISTING);
    }
}
</pre>	

		<p>
			Выглядит лучше. Прежде всего отметим, что все константы находятся внутри вспомогательного класса. Т.е. никакое, 
			даже самое дикое, форматирование исходного текста не сможет разлучить их. Имя же вспомогательного класса говорит
			само за себя. Так что нет нужды дублировать слова <tt>CUSTOMER</tt> и <tt>ID</tt> в именах констант. И IDE нам 
			поможет: не надо держать в голове все возможные вариации, достаточно набрать <tt>Cust</tt> - и IDE предложит 
			дополнить до <tt>CustomerId</tt>. После набора точки IDE отобразит весь список - останется только выбрать. Тем 
			не менее, внутренний класс из <a href="#listing-2">листинга 2</a> выглядит громоздким. И в самом деле: мы 
			уменьшили длину имени каждой константы, но добавили строчку <code>private static class CustomerId {</code>. Так 
			что не такое уж изящное получилось решение. Попробуем убрать лишнее и покажем это в 
			<a href="#listing-3">листинге 3</a>:
		
		<h4 id="listing-3">
			Листинг 3 - тут будет ссылка на Github или просто название класса - 
			улучшенный внутренний класс для группировки констант
		</h4>
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_3_EnhancedInnerClass_Test {

    private static class CustomerId {
        static final String VALID = "12345";
        static final String INVALID = "!!!";
        static final String NON_EXISTING = "000";
    }

    @Test
    public void someTest() throws Exception {
        System.out.println(CustomerId.VALID);
        System.out.println(CustomerId.INVALID);
        System.out.println(CustomerId.NON_EXISTING);
    }
}
</pre>
		
		<p>
			Убирать модификатор <code>private</code> с <code>CustomerId</code> убирать не будем. От модификатора 
			<code>static</code> тоже оставим. А вот модификатор	<code>private</code> с собственно самих констант можно 
			убрать. 
			
		<p>
			Поле вложенного класса всегда доступно из класса, в который	он вложен (да-да, в 
			<a href="#listing-2">листинге 2</a> константы приватные, и тем не менее, их можно прочитать в методе 
			<code>someTest</code>). Так уровень доступа <strong>package-private</strong> сойдет: класс 
			<code>CustomerId</code>	- приватный, и все, что в нем находится, будет невидимо для внешнего мира. 
			Продемонстрируем это, а именно: создадим пакет <code>package com.github.flaz14.foo</code> и добавим в тест,
			приведенный в <a href="#listing-4">листинге 4</a>.
		
		<h4 id="listing-4">
			Листинг 4 - тут будем имя класса-теста - приватный вложенный класс виден только в классе, в который он 
			вложен
		</h4>
<pre>
package com.github.flaz14.foo;

import org.junit.Test;

public class VisibilityOfInnerClassTest {

    @Test
    public void packagePrivateFieldsOfPrivateInnerClass() throws Exception {
        System.out.println(
                com.github.flaz14.grouping.Constants_3_EnhancedInnerClass_Test.CustomerId.VALID
        );
    }
}
</pre>
		
		<p>
			Попробуем скомпилировать и получим ошибку компиляции: 
			<code>
				com.github.flaz14.grouping.Constants_3_EnhancedInnerClass_Test.CustomerId has private access in 
				com.github.flaz14.grouping.Constants_3_EnhancedInnerClass_Test
			</code>. То же самое будет и при любом другом модификоре поля, главное, чтобы сам вложенный класс был 
			приватным.
		
		<p>
			Т.о. образом привиденный в <a href="#listing-3">листинге 3</a> класс оптимально подходит для группировки 
			костант [1].
		
		
		<h2>Почему не enum?</h2>
		
		Попробуем сгруппировать константы, но с помощью enum:
		
		Листинг 5 - константы оформленные в виде enum
		
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_3_Enum_Test {

    private enum CustomerId {
        VALID("12345"),
        INVALID("!!!"),
        NON_EXISTING("000");

        public final String id;

        private CustomerId(String id) {
            this.id = id;
        }
    }

    @Test
    public void someTest() throws Exception {
        System.out.println(CustomerId.VALID.id);
        System.out.println(CustomerId.INVALID.id);
        System.out.println(CustomerId.NON_EXISTING.id);
    }
}
</pre>
		
		Очевидно, что использование enum ведет к чрезмерному усложнению при той же функциональности. Да, enum вне конкуренции
		в случаях общедоступных классов, которые повторно используются во многих частях программы. Но если константы релевантны
		только в пределах одного класса, лучше упаковать их во внутренний класс.
		
		
		<h2>Не только константы, но и разнообразные фабрики</h2>
		
		Как часто приходиться использовать в тестах всякого рода DTO, Entity и прочие классы, которые в С++ - просто struct.
		
		Что ж, внутренние классы можно применить и тут. Например,
		
<pre>
package com.github.flaz14.factory;

import org.junit.Test;

public class DtoFactoryTest {

    private static class Customer {
        static CustomerDto withMandatoryFields() {
            return new CustomerDto();
        }

        static class WithBankDetails {
            static CustomerDto apparent() {
                CustomerDto dto = new CustomerDto();
                // set up some credit card number fully
                // ...
                return dto;
            }

            static CustomerDto obscured() {
                CustomerDto dto = new CustomerDto();
                // set up credit card number in the form of XXXX XXXX XXXX 1234
                // ...
                return dto;
            }
        }
    }

    @Test
    public void test() throws Exception {
        CustomerDto expected = Customer.WithBankDetails.obscured();
        // ...
    }
}

class CustomerDto {
    // ...
}
</pre>
		
		Тут все очевидно [2]. Шаблонов (т.е. не шаблонов проектирования, а "маленьких" шаблонов - implementation patterns 
		!!!!!Тут будет ссылка на книгу Kent Beck - Implementation Patterns, может, и не будет!!!!!
		 ) можно привести множество: Exception Factory, Logger Factory, Builder и т.д.
		 
		Внутренние классы не обязательно должны быть статическими. Можно использовать и нестатические классы. С точки зрения
		читаемости будет мозолить глаза только ключевое слово <code>new</code>. Но это не страшно. Тем более, что обычные
		внутренние классы имеют доступ к intance-полям объектов окружающего класса. Что приносит неожиданные преимущества.
		
		В качестве примера !!!Тут будет пример, правда, я его еще не придумал!!!
		
		
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						
						Для пущей константности можно было бы добавить к классу <code>CustomerId</code> модификтор 
						<code>final</code>, но это излишне - класс <code>CustomerId</code> невидим для внешнего мира. Вряд ли
						кому-то придет в голову написать еще один внутренний класс и в новом классе унаследовать 
						<code>CustomerId</code>.

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 					
						Почему мы для использовали всегда статические методы вместо того, чтобы раз и навсегда создать
						объекты-константы. Потому что пример был о factory-методах. Но не только поэтому. Часто классы-сущности 
						не являются неизменяемыми (immutable) объектами. Поэтому в тестах возможна их (случайная) модификация объектов.
						А вот при использовании factory-метода о такого рода ошибках можно забыть (вообще, неизменяемые объекты - 
						отдельная тема, то же можно сказать про порядком поднадоевший модификатор <code>final</code>).
						После описанных выше манипуляций нельзя будет изменить системное время из апплета на панели 
						задач. Но это не проблема: запускаем <code>gksudo cinnamon-settings</code> и меняем что душе 
						угодно (правда, тут надо быть осторожным, чтобы не испортить другие настройки).
						
				<li id="footnote-3-bottom">
					<p>
						<a href="#footnote-3-top" title="Перейти к основному тексту">&uarr;</a> 
						Если в системе все-таки есть пользователь <strong>root</strong> (т.е. если он был добавлен 
						вручную), нужно установить для него сложный (лучше - "невзламываемый", длиной около 50 случайных
						символов) пароль.
			</ol>
			
		<hr>
		
		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
