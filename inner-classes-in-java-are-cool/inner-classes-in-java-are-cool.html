<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Внутренние классы в Java - классные!</title>
	</head>
	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
		
		<hr>
		
		<h1>
			<a href="http://flaz14.github.io/inner-classes-in-java-are-cool/inner-classes-in-java-are-cool.html">
				Внутренние классы в Java - классные!
			</a>
		</h1>
		
		<h3>[2017, Февраль]</h3>
		
		<h2>Немного теории</h2>
			
		<p>
			Внутренние классы (inner classes), они же вложенные классы (nested classes), появились в Java версии 1.1 (не 
			уверен насчет 1.1, знакомые Java-эксперты говорят, что в версии 1.1.8 внутренние классы точно были). Как 
			говорится в 
			<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html">
				официальном туториале от Oracle
			</a>
			внутренние классы:
			<ul>
				<li>
					помогают разместить основной класс и его "помощник" в одном месте и избавляют от создания нового 
					файла для вспомогательного класса;
			
				<li>
					улучшают инкапсуляцию: вспомогательный класс можно сделать невидимым за пределами основного класса;
				
				<li>
					придают коду дополнительную удобоваримость.
			</ul>
    
		
		<h2>О "песочнице"</h2>

		<p>
			Все примеры оформлены в виде Maven-проекта (тут будет ссылка на исходный код). Для каждого примера 
			(следовательно, для каждого листинга)- свой класс. Каждое заметное улучшение кода предствлено в виде нового 
			класса. Имена классов нестандартные. Это нужно для того, чтобы файлы отображались в IDE в том же порядке, в 
			каком они упоминаются в статье.
		
		<h2>Группировка констант</h2>
		
		<p>
			В своей рутинной работе я часто сталкиваюсь с примерно таким кодом (в остовном в тестах):
		
		<h4 id="listing-1">Листинг 1 - PlainOldConstants_1_Test - примитивный подход к константам в тестах</h4>	
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_1_PlainOldApproach_Test {

    private static final String CUSTOMER_ID = "12345";
    private static final String INVALID_CUSTOMER_ID = "!!!";
    private static final String NON_EXISTING_CUSTOMER_ID = "000";

    @Test
    public void someTest() throws Exception {
        System.out.println(CUSTOMER_ID);
        System.out.println(INVALID_CUSTOMER_ID);
        System.out.println(NON_EXISTING_CUSTOMER_ID);
    }
}
</pre>

		<p>
			Первое, что бросается в глаза и что хотелось бы улучшить - это имена констант. Так, в имени каждой константы 
			повторяeтся <tt>CUSTOMER_ID</tt>. Само по себе дублирование чего бы то ни было в тестах - не так уж плохо. 
			Тем более, что два слова - не пять.	Но чтобы использовать такие константы в коде, приходиться больше 
			печатать. И функция автодополнения в IDE не силоно помогает. Потому что одна константа начинается со слова
			<tt>CUSTOMER</tt>, вторая - со слова <tt>INVALID</tt>, а третья с совершенно другого слова.	Кроме этого, 
			каждая из констант - самостоятельное, не связанное с другими, поле класса. В зависимости от того, как 
			исходный код отформатирован, логически связанные константы могут быть или собраны в одном месте, или 
			разбросаны по всему файлу (или перемешанными с константами другого рода). Что ухудшает читаемость кода. Да, 
			можно задействовать formatter и отсортировать константы в алфавитном порядке, но откуда ему знать, что все 
			эти константы имеют отношение к одной сущности? Чтобы учесть логическую связь придеться	использоватьочень 
			нетривиальные средства форматирования исходного кода. 
			
		<p>
			Призовем на помощь внутренний класс и получим <a href="#listing-2">листинг 2</a>!
		
		<h4 id="listing-2">
			Листинг 2 - тут будет имя класса и ссылка на github - константы сгруппированы с помощью внутреннего класса
		</h4>		
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_2_InnerClass_Test {

    private static class CustomerId {
        private static final String VALID = "12345";
        private static final String INVALID = "!!!";
        private static final String NON_EXISTING = "000";
    }

    @Test
    public void someTest() throws Exception {
        System.out.println(CustomerId.VALID);
        System.out.println(CustomerId.INVALID);
        System.out.println(CustomerId.NON_EXISTING);
    }
}
</pre>	

		<p>
			Выглядит лучше. Прежде всего отметим, что все константы находятся внутри вспомогательного класса. Т.е. никакое, 
			даже самое дикое, форматирование исходного текста не сможет разлучить их. Имя же вспомогательного класса говорит
			само за себя. Так что нет нужды дублировать слова <tt>CUSTOMER</tt> и <tt>ID</tt> в именах констант. И IDE нам 
			поможет: не надо держать в голове все возможные вариации, достаточно набрать <tt>Cust</tt> - и IDE предложит 
			дополнить до <tt>CustomerId</tt>. После набора точки IDE отобразит весь список - останется только выбрать. Тем 
			не менее, внутренний класс из <a href="#listing-2">листинга 2</a> выглядит громоздким. И в самом деле: мы 
			уменьшили длину имени каждой константы, но добавили строчку <code>private static class CustomerId {</code>. Так 
			что не такое уж изящное получилось решение. Попробуем убрать лишнее и покажем это в 
			<a href="#listing-3">листинге 3</a>:
		
		<h4 id="listing-3">
			Листинг 3 - тут будет ссылка на Github или просто название класса - 
			улучшенный внутренний класс для группировки констант
		</h4>
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_3_EnhancedInnerClass_Test {

    private static class CustomerId {
        static final String VALID = "12345";
        static final String INVALID = "!!!";
        static final String NON_EXISTING = "000";
    }

    @Test
    public void someTest() throws Exception {
        System.out.println(CustomerId.VALID);
        System.out.println(CustomerId.INVALID);
        System.out.println(CustomerId.NON_EXISTING);
    }
}
</pre>
		
		<p>
			Убирать модификатор <code>private</code> с <code>CustomerId</code> убирать не будем. От модификатора 
			<code>static</code> тоже оставим. А вот модификатор	<code>private</code> с собственно самих констант можно 
			убрать. 
			
		<p>
			Поле вложенного класса всегда доступно из класса, в который	он вложен (да-да, в 
			<a href="#listing-2">листинге 2</a> константы приватные, и тем не менее, их можно прочитать в методе 
			<code>someTest</code>). Так уровень доступа <strong>package-private</strong> сойдет: класс 
			<code>CustomerId</code>	- приватный, и все, что в нем находится, будет невидимо для внешнего мира. 
			Продемонстрируем это, а именно: создадим пакет <code>package com.github.flaz14.foo</code> и добавим в тест,
			приведенный в <a href="#listing-4">листинге 4</a>.
		
		<h4 id="listing-4">
			Листинг 4 - тут будем имя класса-теста - приватный вложенный класс виден только в классе, в который он 
			вложен
		</h4>
<pre>
package com.github.flaz14.foo;

import org.junit.Test;

public class VisibilityOfInnerClassTest {

    @Test
    public void packagePrivateFieldsOfPrivateInnerClass() throws Exception {
        System.out.println(
                com.github.flaz14.grouping.Constants_3_EnhancedInnerClass_Test.CustomerId.VALID
        );
    }
}
</pre>
		
		<p>
			Попробуем скомпилировать и получим ошибку компиляции: 
			<code>
				com.github.flaz14.grouping.Constants_3_EnhancedInnerClass_Test.CustomerId has private access in 
				com.github.flaz14.grouping.Constants_3_EnhancedInnerClass_Test
			</code>. То же самое будет и при любом другом модификоре поля, главное, чтобы сам вложенный класс был 
			приватным.
		
		<p>
			Т.о. образом привиденный в <a href="#listing-3">листинге 3</a> класс оптимально подходит для группировки 
			костант <sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>.
		
		
		<h2>А почему не <code>enum</code>?</h2>
		
		<p>
			Попробуем сгруппировать константы, но с помощью <code>enum</code>:
		
		<h4>
			Листинг 5 - тут будет имя класса - константы оформленные в виде <code>enum</code>
		</h4>
<pre>
package com.github.flaz14.grouping;

import org.junit.Test;

public class Constants_3_Enum_Test {

    private enum CustomerId {
        VALID("12345"),
        INVALID("!!!"),
        NON_EXISTING("000");

        public final String id;

        private CustomerId(String id) {
            this.id = id;
        }
    }

    @Test
    public void someTest() throws Exception {
        System.out.println(CustomerId.VALID.id);
        System.out.println(CustomerId.INVALID.id);
        System.out.println(CustomerId.NON_EXISTING.id);
    }
}
</pre>
		
		<p>
			Очевидно, что использование <code>enum</code> ведет к чрезмерному усложнению при той же функциональности. 
			Да, <code>enum</code> вне конкуренции в случаях общедоступных классов, которые повторно используются во 
			многих частях программы. Но если константы релевантны только в пределах одного класса, лучше поместить их во
			внутренний класс.
		
		<h2>Не только константы, но и разнообразные фабрики</h2>
		
		<p>
			В реальных приложения (особенно в устаревших корпоративных монстрах) часто приходиться использовать в тестах 
			всякого рода DTO, Entity и прочий хлам.	Что ж, внутренние классы можно применить и тут. Вглянем на 
			<a href="#listing-6">листинг 6</a>:
		
		<h4 id="listing-6">
			Листинг 6 - тут будет имя класса - использование внутренних классов для организации static factory
		</h4>
<pre>
package com.github.flaz14.factory;

import org.junit.Test;

public class DtoFactoryTest {

    private static class Customer {
        static CustomerDto withMandatoryFields() {
            return new CustomerDto();
        }

        static class WithBankDetails {
            static CustomerDto apparent() {
                CustomerDto dto = new CustomerDto();
                // set up some credit card number fully
                // ...
                return dto;
            }

            static CustomerDto obscured() {
                CustomerDto dto = new CustomerDto();
                // set up credit card number in the form of XXXX XXXX XXXX 1234
                // ...
                return dto;
            }
        }
    }

    @Test
    public void test() throws Exception {
        CustomerDto expected = Customer.WithBankDetails.obscured();
        // ...
    }
}

class CustomerDto {
    // ...
}
</pre>
		
		<p>
			Тут все очевидно 
			<sup id="footnote-2-top"><a href="#footnote-2-bottom">[2]</a></sup>. 
			Можно привести еще много примеров: Exception Factory, Logger Factory, Builder и т.д.
		
		<h2>И напоследок...</h2>
		 
		<p>
			Внутренние классы не обязательно должны быть статическими. Можно использовать и нестатические классы. С 
			точки зрения читаемости кода лишь ключевое слово <code>new</code> будет мозолить глаза. Но это не страшно. 
			Тем более, что нестатические внутренние классы имеют доступ к intance-полям объектов окружающего класса. Что
			приносит неожиданные преимущества. 
			
			!!!Тут будет пример, правда, я его еще не придумал!!!
		
		<p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Для пущей константности можно было добавить к классу <code>CustomerId</code> модификтор 
						<code>final</code>. Но это излишне: класс <code>CustomerId</code> спрятан от внешнего мира. И 
						вряд ли	кому-то придет в голову написать еще один внутренний класс и в новом классе унаследовать 
						<code>CustomerId</code>.

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 					
						Почему в <a href="#listing-6">листинге 6</a> мы для использовали статические методы вместо того,
						чтобы раз и навсегда создать объекты-константы? Потому что пример был о factory-методах. Но не 
						только поэтому. Часто классы-сущности не являются неизменяемыми объектами. Поэтому в тестах 
						возможна их (случайная) модификация. А вот при использовании factory-метода о такого рода 
						ошибках можно забыть (вообще-то, неизменяемые объекты - отдельная тема, равно как и порядком 
						надоевший модификатор <code>final</code> возле параметров методов и локальных переменных).
			</ol>
			
		<hr>
		
		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
