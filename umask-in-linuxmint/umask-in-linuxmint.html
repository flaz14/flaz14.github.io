<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Что не так с umask в LinuxMint</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href=
		"http://flaz14.github.io/umask-in-linuxmint/umask-in-linuxmint.html">
				Что не так с umask в LinuxMint
			</a>
		</h1>
		
		<h3>[2017, Июнь]</h3>

		<h2>Замечательные умолчания</h2>
		
		<p>
			Пожалуй, любой популярный дистрибутив GNU/Linux преподносится как система "на все случаи жизни". 
			Применительно к LinuxMint это хорошо: драйверы, кодеки и т.п. проприетарные компоненты есть в комплекте. Но
			с точки зрения защиты информации и безопасной работы (чтобы не выстрелить себе в ногу) эти умолчания никуда
			не годятся <sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>.
			
		<h2>Что происходит?</h2>
	
		<p>
			Нет нужды рассказывать здесь подробно, что такое <strong>umask</strong> в мире Unix-систем. И нет смысла
			пускаться в разговоры о том, в каких конфигурационных файлах и скриптах задается umask, как на маску влияют 
			команды <em>su</em>, <em>sudo</em>, <em>login</em> и т.д. Конечная точка - это файл 
			<strong>.profile</strong>, находящийся в домашней директории пользователя. Именно он будет принят во 
			внимание.
			Правда, есть еще <i>.bashrc</i> и ему подобные. Но они имеют силу только в командной строке и не вляют на
			программы, которые запускаются, скажем, с ярлыка на рабочем столе. Т.о. чтобы гарантированно изменить 
			значение umask нужно править <i>~/.profile</i>). Посмотрим, что интересного там уже имеется:
<pre>
$ less ~/.profile

</pre>
		
		<p>
			Неутешительно. Получается, что каждый файл, созданный данным пользователем, будет виден, т.е. доступен для 
			чтения всем остальным пользователям. Причем не только реальным (т.е. другим людям, работающим за тем же компьютером),
			но и фиктивным, таким как <em>nobody</em>. Ну и какой толк от такой защиты? Да, модифицировать файлы пользователя
			нельзя, но их можно читать. Это особенно расстраивает в случае с профилями таких программа, как Firefox и 
			Thunderbird, которые хранятся в домашнем каталоге пользователя. Хорошо, именим umask c 022 на 027. И перезагрузимся 
			после изменения.
<pre>

</pre>

		<p>
			Естественно, нужно будет изменить права на все файлы и каталоги, которые принадлежат пользователю. Т.е. нужно
			убрать право на чтение для всех, кроме владельца и группы. В данном случае лучше воспользоваться абсолютным
			режимом команды chown (и еще find - мы же защищаем все файлы, принадлежащие пользователю). Тут можно предупредить:
			некоторые файлы, которые находятся в домашнем каталоге пользователя, реально принадлежат суперпользователю.
			Что вовсе не удивительно: если вы запускаете программы с графическим интерфейсом с помощью su или sudo - так
			и будет (для этих целей нужно использовать gksu и gksudo - или их KDE-собратьев kdesu и kdesudo - зависит 
			от окружения рабочего стола) - Подробности см. на 
			<a href="https://help.ubuntu.com/community/RootSudo#Graphical_sudo">Ubuntu Wiki</a>). Но некоторые неграфические
			программы (например, Midnight Commander) грешат тем, что оставляют принадлежащие суперпользователю файлы
			в домашнем каталоге обычного пользователя (например, тут будет подозрительный файл mc).
<pre>
</pre>			
		
		<p>
			
			Уфф, сейчас все вроде бы хорошо. Но мы забыли одну маленькую деталь. После изменения umask в системе начнет 
			твориться вакханалия. Новые установленные программы не будут запускаться, модули Python, установленные через
			Pip, невозможно будет подключить с своему скрипту. И т.д. Вы спросите, откуда ноги растут. Ответ простой:
			sudo. sudo - это же по-правильному. Проведем небольшой эксперимент. Создадим в /tmp простой скрипт 
			с именем <i>test_umask.sh</i>
			следующего содержания (и не забудем сделать его исполняемым):
<pre>
#!/usr/bin/env bash

echo "[$(umask)]"
</pre>

		<p>
			И проверим:
<pre>
$ /tmp/test_umask.sh
[0027]
</pre>			
		<p>
			Как и ожидалось, мы видим заданное нами значение. Попробуем запустить тот же скрипт от имени суперпользователя:
<pre>
$ sudo su
# /tmp/test_umask.sh 
[0022]
</pre>
		<p>
			Как видим, у суперпользователя осталось правильное значение umask. Так и должно быть, ведь мы же не трогали
			<i>.profile</i> суперпользователя. Посмотрим же, как ведет себя sudo:
<pre>
$ sudo /tmp/test_umask.sh
[0022] - это у меня уже исправлено, на "чистой" системе будет umask пользователя.
</pre>
		<p>
			Копнем глубже. Изменим umask на что-нибудь действительно безумное (все равно изменение коснется только
			текущего виртуального терминала) и проверим sudo еще раз:



		<p>
			Вот оно что! sudo принимает во внимание umask запустившего команду пользователя. Т.о. становится очевидной 
			причина появляющихся после изменения umask глюков. Например, исполняемые файл программ принадлежат root, но 
			при этом доступны для чтения и выполнения всем остальным пользователям системы (иначе как бы они могли 
			работать с программами). Наш же "безопасный" umask запрещает доступ другим пользователям, только root может
			работать с программами.
			
		<p>
			Для исправления ситуации лучше всего вообще "выкосить" sudo :) Или же поиграть с ключами командной строки, т.е.
			добиться реального "сброса" значения umask, если программа выполняется через sudo. Но правильным является подход,
			описанный в ответе на вопрос 
			<a href="https://unix.stackexchange.com/questions/265497/set-sudo-umask-apart-from-the-user-calling-it">
				Set sudo umask apart from the user calling it</a>. Остается только залезть в файл <i>/etc/sudoers</i>, 
			и ???расскомментировать или добавить??? заветный umask и дело в шляпе ():
<pre>
# Specify umask explicitly in order to make 'root' account
# working as usual (for more details please look at topic:
# [Set sudo umask apart from the user calling it]
# (https://unix.stackexchange.com/questions/265497/set-sudo-umask-apart-from-the-user-calling-it).
Defaults umask=0022
Defaults umask_override
</pre>			
			
		<p>
			Проверим на всякий случай (для чистоты эксперимента закроем текущий эмулятор терминала и откроем новый):
<pre>
$ sudo /tmp/test_umask.sh
</pre>

			Теперь уж точно можно вздохнуть спокойно.



        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Я не уверен, что это "косяк" LinuxMint. LinuxMint основан на Ubuntu, а Ubuntu - на Debian. Очень
						вероятно, что все вышеназванные дистрибутивы имеют одинаковую проблему.
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
