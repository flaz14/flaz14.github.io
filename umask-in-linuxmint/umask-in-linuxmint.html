<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Что не так с umask в LinuxMint</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href=
		"http://flaz14.github.io/umask-in-linuxmint/umask-in-linuxmint.html">
				Что не так с umask в LinuxMint
			</a>
		</h1>
		
		<h3>[2017, Июнь]</h3>

		<h2>Замечательные умолчания</h2>
		
		<p>
			Пожалуй, любой популярный дистрибутив GNU/Linux преподносится как система "на все случаи жизни". 
			Применительно к LinuxMint это хорошо: драйверы, кодеки и т.п. проприетарные компоненты есть в комплекте. Но
			с точки зрения защиты информации и безопасной работы (чтобы не выстрелить себе в ногу) эти умолчания никуда
			не годятся <sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>.
			
		<h2>Что происходит?</h2>
	
		<p>
			Нет нужды рассказывать здесь подробно, что такое <strong>umask</strong> в мире Unix-систем. И нет смысла
			пускаться в разговоры о том, в каких конфигурационных файлах и скриптах задается umask, как на маску влияют 
			команды <em>su</em>, <em>sudo</em>, <em>login</em> и т.д. Конечная точка - это файл 
			<strong>.profile</strong>, находящийся в домашней директории пользователя. Именно он будет принят во 
			внимание.
			Правда, есть еще <i>.bashrc</i> и ему подобные. Но они имеют силу только в командной строке и не вляют на
			программы, которые запускаются, скажем, с ярлыка на рабочем столе. Т.о. чтобы гарантированно изменить 
			значение umask нужно править <i>~/.profile</i>). Посмотрим, что интересного там уже имеется:
<pre>
$ less ~/.profile
...
# the default umask is set in /etc/profile; for setting the umask
# for ssh logins, install and configure the libpam-umask package.
#umask 022
...
</pre>
		
		<p>
			Посмотрм в <i>/etc/profile</i>:
<pre>
$ less /etc/profile
...
# The default umask is now handled by pam_umask.
# See pam_umask(8) and /etc/login.defs.
...
</pre>

		<p>
			Тааак... Похоже, за umask в современных дистрибутивах отвечает PAM!!!тут будет ссылка на домашнюю страницу 
			LinuxPAM!!!.
<pre>
$ less /etc/login.defs
...
# UMASK is the default umask value for pam_umask and is used by
# useradd and newusers to set the mode of the new home directories.
# 022 is the "historical" value in Debian for UMASK
# 027, or even 077, could be considered better for privacy
# There is no One True Answer here : each sysadmin must make up his/her
# mind.
...
</pre>			
		
		<p>
			Т.о. в LinuxMint явно umask не устанавливается. По-умолчанию используется значение <b>022</b> (что мы и 
			наблюдали ранее). Выглядит неутешительно. Получается, что каждый файл, созданный данным пользователем, будет
			виден, т.е. доступен для 
			чтения всем остальным пользователям. Причем не только реальным (т.е. другим людям, работающим за тем же 
			компьютером),
			но и фиктивным, таким как <em>nobody</em>. Ну и какой толк от такой защиты? Да, модифицировать файлы 
			пользователя
			нельзя, но их можно читать. Это особенно расстраивает в случае с профилями таких программ, как Firefox и 
			Thunderbird, которые хранятся в домашнем каталоге пользователя. Хорошо, изменим umask c 022 на 027. 
			И перезагрузимся после изменения (можно сделать logout и снова login, но мы перезагрузимся на всякий случай).

		<p>
			Естественно, нужно будет изменить права на все файлы и каталоги, которые принадлежат пользователю. 
			Т.е. нужно
			убрать право на чтение для всех, кроме владельца и группы. В данном случае лучше воспользоваться т.н. 
			символическим режимом. Действительно, нам нужно только убрать биты доступа, соответствующие всем остальным
			пользователям. Менять же права владельца и группы не требуется (т.е. если файл, к примеру, был исполняемым,
			то его нужно оставить исполняемым для владельца и группы, а для всех остальных пользователей нужно убрать
			все права).
			режимом команды chmod (и еще find - мы же защищаем все файлы, принадлежащие пользователю, хотя особого смысла
			это не имеет - принадлежащие пользовательские файлы хранятся в домашнем каталоге ползователя, за его 
			пределами они могут находиться разве что в /tmp и в /var). Тут можно 
			предупредить:
			некоторые файлы, которые находятся в домашнем каталоге пользователя, реально принадлежат суперпользователю.
			Что вовсе не удивительно: если вы запускаете программы с графическим интерфейсом с помощью su или sudo - так
			и будет (для этих целей нужно использовать gksu и gksudo - или их KDE-собратьев kdesu и kdesudo - зависит 
			от окружения рабочего стола) - Подробности см. на 
			<a href="https://help.ubuntu.com/community/RootSudo#Graphical_sudo">Ubuntu Wiki</a>). Но некоторые неграфические
			программы (например, Midnight Commander) грешат тем, что оставляют принадлежащие суперпользователю файлы
			в домашнем каталоге обычного пользователя, будучи запущенными через sudo [2]поиск подозрительных файлов - это
			отдельная тема.
<pre>
find . -user user -exec chmod o-rwx '{}' \; 2>/dev/null
</pre>	
		
		<p>
			Уфф, сейчас все вроде бы хорошо. Но мы забыли одну маленькую деталь. После изменения umask в системе начнет 
			твориться вакханалия. Новые установленные программы не будут запускаться, модули Python, установленные через
			Pip, невозможно будет подключить с своему скрипту. И т.д. Вы спросите, откуда ноги растут. Ответ простой:
			sudo. sudo - это же по-правильному. Проведем небольшой эксперимент. Создадим в /tmp простой скрипт 
			с именем <i>test_umask.sh</i>
			следующего содержания (и не забудем сделать его исполняемым):
<pre>
#!/usr/bin/env bash

echo "[$(umask)]"
</pre>

		<p>
			И проверим:
<pre>
$ /tmp/test_umask.sh
[0027]
</pre>			
		<p>
			Как и ожидалось, мы видим заданное нами значение. Попробуем запустить тот же скрипт от имени суперпользователя:
<pre>
$ sudo su
# /tmp/test_umask.sh 
[0022]
</pre>
		<p>
			Как видим, у суперпользователя осталось правильное значение umask. Так и должно быть, ведь мы же не трогали
			<i>.profile</i> суперпользователя. Посмотрим же, как ведет себя sudo:
<pre>
$ sudo /tmp/test_umask.sh
[0027]
</pre>
		<p>
			Копнем глубже. Изменим umask на что-нибудь действительно безумное (все равно изменение коснется только
			текущего виртуального терминала) и проверим sudo еще раз:
<pre>
$ umask 555
$ sudo /tmp/test_umask.sh 
[0577]
$ umask 500
$ sudo /tmp/test_umask.sh 
[0522]
</pre>

		<p>
			Вот оно что! sudo принимает во внимание umask запустившего команду пользователя. Т.е. делает побитовое OR
			"исторической" маски (<b>002</b>) с маской запустившего sudo пользователя! Т.о. становится очевидной 
			причина появляющихся после изменения umask глюков. Например, исполняемые файл программ принадлежат root, но 
			при этом доступны для чтения и выполнения всем остальным пользователям системы (иначе как бы они могли 
			работать с программами). Наш же "безопасный" umask запрещает доступ другим пользователям, только root может
			работать с программами.
			
		<p>
			Для исправления ситуации лучше всего вообще "выкосить" sudo :) Или же поиграть с ключами командной строки, 
			т.е.
			добиться реального "сброса" значения umask, если программа выполняется через sudo. 
			Но правильным является подход,
			описанный в ответе на вопрос 
			<a href="https://unix.stackexchange.com/questions/265497/set-sudo-umask-apart-from-the-user-calling-it">
				Set sudo umask apart from the user calling it</a>. Остается только залезть в файл <i>/etc/sudoers</i>, 
			(естественно, посредство <code>visudo</code>) и ???расскомментировать или добавить??? заветный umask и дело 
			в шляпе (и не забыть добавить подробный
			комментарий, зачем это было сделано):
<pre>
# We specify umask explicitly in order to make `root` account
# working as usual even while user's umask pretends to be
# "secure", e.g. 027 (for more details please look at topic:
# [Set sudo umask apart from the user calling it]
# (https://unix.stackexchange.com/questions/265497/set-sudo-umask-apart-from-the-user-calling-it).
Defaults umask=0022
Defaults umask_override
</pre>			
			
		<p>
			Проверим на всякий случай (для чистоты эксперимента закроем текущий эмулятор терминала и откроем новый):
<pre>
$ sudo /tmp/test_umask.sh
[0022]
</pre>
		
		<p>
			Теперь можно вздохнуть спокойно.

        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Я не уверен, что это "косяк" LinuxMint. LinuxMint основан на Ubuntu, а Ubuntu - на Debian. Очень
						вероятно, что все вышеназванные дистрибутивы имеют одинаковую проблему.
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
