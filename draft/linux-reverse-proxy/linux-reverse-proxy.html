<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Reverse-proxy в Linux своими ногами</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#linux-reverse-proxy" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/netcat-is-too-old/netcat-is-too-old.html">
				Reverse-proxy в Linux своими ногами
			</a>
		</h1>
		
		<h3>[2018, Февраль]</h3>

		<h2>Вспоминаем</h2>
		
		<p>
			Дурацкое название подходит очень хорошо. Давным-давно я настраивал reverse-proxy для сервера
			Tomcat. И сейчас постараюсь вспомнить и рассказать, как это было.
		
		<p>
			Т.е. есть удаленный компьютер (Amazon EC2 instance). На нем запущен сервер приложений Tomcat.
			А мне захотелось сделать так, чтобы каждый, кто обратится к приложению
			на удаленном компьютере на порт 8080, попадал на мой компьютер. Эту задачу можно решить одной строчкой:
			командой <strong>ssh</strong>. Но не все так просто оказалось.
		
		<p>
			На удаленном сервере у меня были права суперпользователя. Так что делать я мог все, что угодно. Проблема была в 
			том, что ssh-демон был настроен так, что не разрешал выставлять порт наружу. Т.е. войти в ssh-туннель можно
			было только с самого удаленного сервера. 
			
		<p>
			Было два варианта: 
			<ol>
				<li>
					Править конфигурационные файлы демона ssh. Это чревато. Во-первых, можно все испортить нафиг одной
					неверной строкой. Во-вторых, у удаленного сервера были админы, которые следили за такого рода
					изменениями.
				
				<li>
					Сделать цепочку из туннелей с помощью какой-нибудь другой программы, кроме ssh. Один конец 
					вспомогательного
					туннеля можно было выставить наружу на порту 8080, а другой - "пристыковать" к обычного ssh-туннелю,
					который слушает на локальном (<em>lo</em>) сетевом интерфейсе.
			</ol>

		<p>
			Я остановился на втором способе как наиболее простом (проще, чем конфиги) и безопасном (перестал быть нужен
			reverse-proxy - нажал в консоли <kbd>Ctrl</kbd> + <kbd>C</kbd>, удалил вспомогательный софт - и все стало, 
			как было).
		
		<h2>Netcat устарел</h2>
		
		<p>
			С помощью netcat (здесь и далее имеется ввиду OpenBSD netcat) возможно сделать двунаправленный туннель
			с помощью именованных каналов. А чтобы туннель оставался рабочим (если клиент закроет TCP-соединение, то
			netcat завершит работу)
			стоит поместить запуск netcat внутрь бесконечного цикла в shell-скрипте. У такого подхода есть
			существенный недостаток: невозможность нескольких одновременных (т.е. по-настоящему параллельных) соединений. 
			Это очень важно для 
			полноценного прокси, особенно,
			если нужно просматривать через него странички в браузере.
		
		<p>
			В новых вариациях netcat (<a href="https://nmap.org/ncat/">Ncat</a> и т.п.) все по-новому. Но стоит обратить
			внимание на еще одну утилиту: <a href="http://www.dest-unreach.org/socat/">socat</a>. Это очень мощная программа, 
			и ее применение не ограничиватся одними лишь сетевыми соединениями. 
			
		<h2>Решаем задачу</h2>
		
		<p>
			<ol>
				<li>
					<p>
						Устанавливаем на удаленном компьютере socat:

<pre>
sudo yum install socat
</pre>

				<li>
					<p>
						Останавливаем на удаленном компьютере Tomcat.
				
				<li>
					<p>
						Запускаем Tomcat на локальном компьютере.
				
				<li>
					<p>
						Открываем ssh-туннель между локальным компьютером и удаленным. На локальном компьютере будем 
						использовать порт 8080 (именно этот порт занимает Tomcat с настройками по умолчанию). На 
						удаленном же компьютере задействуем порт 8079:

<pre>
ssh -R "8079:localhost:8080" -N user@ec2-instance.mycompany.com
</pre>						
						
				<li>
					<p>
						Запускаем socat на удаленном сервере. Даже права суперпользователя не нужны. Особенность здесь в
						том, что открывать порт 8080 нужно по протоколу IPv6. Дело в том, что на серверах Amazon 
						трафик с привычного для внешнего мира порта 80 перебрасывается (через балансировщик нагрузки) 
						на порт 8080 сервера EC2 именно по протоколу IPv6 (т.е. Tomcat вообще не обслуживает
						IPv4, по крайней мере, для приложений. Может, административные задачи, удаленная отладка и т.п. 
						возможны и по IPv4). Т.е. на этом этапе мы на удаленном сервере выставляем наружу, как ни в чем 
						ни бывало, порт 8080:

<pre>
socat TCP6-LISTEN:8080,fork TCP:localhost:8079
</pre>

					<p>
						Параметр <strong>fork</strong> играет ключевую роль. Именно благодаря ему socat не "отваливается",
						как это делает обычный netcat.
					
				<li>
					<p>
						Проверяем со своего компьютера, что перенаправление действительно работает, т.е. 
						опрашиваем удаленный сервер через балансировщик нагрузки и смотрим логи Tomcat'а на локальной 
						машине:
<pre>
curl http://public.mycompany.com/application/version
</pre>
						
					<p>
						Для убедительности можно повторить запрос несколько раз. И глянуть еще раз открытые порты на 
						удаленном сервере, например, так:

<pre>
netstat -ntl | grep 8080	
</pre>
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>
