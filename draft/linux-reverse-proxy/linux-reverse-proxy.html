<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Reverse-proxy в Linux своими ногами</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#linux-reverse-proxy" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/netcat-is-too-old/netcat-is-too-old.html">
				Reverse-proxy в Linux своими ногами
			</a>
		</h1>
		
		<h3>[2018, Февраль]</h3>

<!--
		<h2></h2>
-->
		
		<p>
			<i>
				Дурацкое название. Но оно подходит очень хорошо. Давным-давно я настраивал reverse-proxy для сервера
				Tomcat. Это получилось, но частично. REST-контроллеры работали, но главная страничка Tomcat не 
				открывалась почему-то. Как бы то ни было, я постараюсь вспомнить и рассказать, как примерно это было.
			</i>
		
		<p>
			Понадобилось сделать обратный прокси-сервер . Т.е. есть удаленный компьютер (Amazon EC2 instance). 
			На нем запущен сервер 
			Tomcat. А на сервере - Web-приложение. 
			А мне захотелось сделать так, чтобы каждый, кто обратится к приложению
			на удаленном компьютере на порт 8080, попадал на мой компьютер. Эту задачу можно решить одной строчкой. Но 
			не все так просто оказалось.
		
		<p>
			Ну удаленном сервере у меня были права суперпользователя. Так что делать я мог, что угодно. Проблема была в 
			том, что ssh-демон был настроен так, что не разрешал выставлять порт наружу. Т.е. войти в ssh-туннель можно
			было только с самого удаленного сервера. Очевидно, что так дело не пойдет. 
			
		<p>
			Было два варианта: 
			<ol>
				<li>
					Править конфигурационные файлы демона ssh. Это чревато. Во-первых, можно все испортить нафиг одной
					неверной строчкой. Во-вторых, у удаленного сервера тоже были админы, которые следили за такого рода
					изменениями. Кроме того, пришлось бы перезапустить sshd, чтобы изменения вступили в силу.
					
				<li>
					Сделать цепочку из туннелей с помощью какой-нибудь другой программы, кроме ssh. Вход 
					вспомогательного туннеля
					можно было выставить наружу, а выход поставить как раз напротив входа в собственно ssh-туннель 
					(который, как ни в чем ни бывало, слушает локальный сетевой интерфейс). 
			</ol>

		<p>
			Я остановился на втором способе как наиболее простом (проще, чем конфиги) и безопасном (перестал быть нужен
			reverse-proxy - нажал в консоли <kbd>Ctrl</kbd> + <kbd>C</kbd>, удалил вспомогательный софт - и все стало, 
			как было).
		
		<h2>Netcat устарел</h2>
		
		<p>
			С помощью netcat (здесь и далее имеется ввиду OpenBSD netcat) возможно сделать двунаправленный туннель
			с помощью именованных каналов. А чтобы туннель оставался рабочим (если netcat встретит EOF он завершит работу)
			стоит поместить запуск netcat в бесконечный цикл. Тем не менее, у такого подхода существенный недостаток:
			
			Невозможность нескольких одновременных (т.е. по-настоящему параллельных) соединений. Это очень важно для 
			полноценного прокси, особенно,
			если нужно просматривать через него странички в браузере.
		
		<p>
			В новых вариациях netcat (<a href="https://nmap.org/ncat/">Ncat</a> и т.п.) все по-новому. Но стоит обратить
			внимание на еще одну утилиту: <a href="http://www.dest-unreach.org/socat/">socat</a>. Это очень мощная программа, 
			и ее применение не ограничиватся одними лишь сетевыми соединениями. 
			
		<p>
		---------------------------------------------------------

1. Устанавливаем на удаленном компьютере socat:

sudo yum install socat


2. Останавливаем на удаленном компьютере Tomcat.


3. Запускаем Tomcat у себя


4. Открываем туннель между локальным компютером и удаленным. На локальном компьютере будем использовать порт 8080
(именно этот порт занимает Tomcat с настройками по умолчанию). На удаленном же компьютере задействуем порт 8079. Да, 
хорошо бы было взять порт 8080. И это возможно. Но настройки SSH-демона на удаленном сервере разрешают открывать порты
только на локальном интерфейсе (`lo`). Менять настройки SSH-демона не стоит. Лучше проложим туннель на порт 8079, а уже
на удаленном компьютере свяжем 8080 и 8079 с помощью отдельной программы, а именно, Socat.

ssh -R "8079:localhost:8080" -N user@ec2-instance.mycompany.com


5. Последний штрих: запускаем socat на удаленном сервере. Даже права суперпользователя не нужны. Особенность здесь в
том, что открывать порт 8080 наружу нужно по протоколу IPv6. Дело в том, что на серверах Amazon трафик с привычного для
внешнего мира порта 80 перебрасывается на внутренний 8080 именно по протоколу IPv6 (т.е. Tomcat вообще не обслуживает
IPv4, по крайней мере, для приложений. Может, административные задачи, удаленная отладка и т.п. возможны и по IPv4).

socat TCP6-LISTEN:8080,fork TCP:localhost:8079


6. Проверяем со своего компа, что перенаправление действительно работает, т.е. опрашиваем удаленный сервер, как и 
положено, через load balancer, и смотрим логи Tomcat'а на нашем компе. Для убедительности можно повторить запрос 
несколько раз (на втором разе обычный netcat отваливается, ведь он не знает, что такое fork, т.е. получив команду 
на закрытие TCP-соединения обычный netcat прекращает работу).

curl http://public.mycompany.com/application/version

Еще можно открытые порты проверить на удаленном сервере, например, так:

netstat -ntl | grep 80	

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>
