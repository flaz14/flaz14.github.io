<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Новое, клёвое и хреновое в Java 8. Часть 3. Лямбда-выражения</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#java-8-whats-new" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-8-whats-new/java-8-whats-new-part-3.html">
				Новое, клёвое и хреновое в Java 8. Часть 3. Лямбда-выражения
			</a>
		</h1>
		
		<h3>[2017, Ноябрь]</h3>

		<h3>
			<a href="java-8-whats-new-part-1.html">Часть 1. Потоки</a>
			|
			<a href="java-8-whats-new-part-2.html">Часть 2. Unit-тесты</a>
			|
			<a href="тут будет ссылка на другой каталог исходников">
				Исходный код
			</a>
		</h3>
		
		<h2>Lambda expression != Anonymous inner class</h2>
		
		<p>
			Мы привыкли думать, что лямбда-выражения и анонимные классы - это одно и то же (кроме улучшенных синтаксиса
			и правил выведения типов). Но это не так. 
			
		<p>
			Пусть у нас есть простой функциональный интерфейс <strong>SomeFunction</strong>.

<h4 id="listing-1">Листинг 1 - простой функциональный интерфейс</h4>
<pre>
@FunctionalInterface
interface SomeFunction {
    void func();
}
</pre>
		
		<p>
			Подготовим три реализации этого интерфейса: с использованием лямбда-выражения, с помощью привычного 
			анонимного внутреннего класса и с помощью внешнего класса. Сделаем так, чтобы они вызывались из
			нестатических методов класса <strong>SomeClass</strong> (см. <a href="#listing-2">листинг 2</a>, 
			горизонтальные линейки я добавил для ясности, чтобы результаты работы разных методов не путались).

<h4 id="listing-2">Листинг 2 - Класс для демонстрации реализаций функционального интерфейса</h4>
<pre>
class SomeClass {
    public void doWorkWithLambda() {
        System.out.println("------------------------------------------------------");
        final SomeFunction function = () -> {
            System.out.println("doWorkWithLambda(): " + this.getClass().getName());
            StacktracePrinter.print();
        };
        function.func();
        System.out.println("------------------------------------------------------");
    }

    public void doWorkWithAnonymousInnerClass() {
        System.out.println("------------------------------------------------------");
        final SomeFunction function = new SomeFunction() {
            @Override
            public void func() {
                System.out.println("doWorkWithAnonymousInnerClass(): " + this.getClass().getName());
                StacktracePrinter.print();
            }
        };
        function.func();
        System.out.println("------------------------------------------------------");
    }

    public void doWorkWithStandaloneClass() {
        System.out.println("------------------------------------------------------");
        final SomeFunction function = new StandaloneClass();
        function.func();
        System.out.println("------------------------------------------------------");
    }

    ...
}
</pre>

		<p>
			Ниже приведена реализация метода <code>func()</code> посредством обычного класса.
			
<h4 id="listing-3">Листинг 3 - реализация функционального интерфейса с помощью внешнего класса</h4>
<pre>
class StandaloneClass implements SomeFunction {
    @Override
    public void func() {
        System.out.println("StandaloneClass: " + this.getClass().getName());
        StacktracePrinter.print();
    }
}
</pre>

		<p>
			Все три реализации всего лишь печают имя класса, в котором выполняются, и стэк вызовов. Для распечатки 
			используется вспомогательный класс с единственным статическим методом, ничего особенного.
			
<h4 id="listing-4">Листинг 4 - вспомогательный класс для распечатки стэка вызовов</h4>
<pre>
class StacktracePrinter {
    public static void print() {
        final StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace();
        Stream.of(stacktrace).
                forEach(System.out::println);
    }
}
</pre>

		<p>
			А теперь запустим все это хозяйство. И получим вывод, приведенный в <a href="#listing-5">листинге 5</a>.

<h4 id="listing-5">Листинг 5 - результаты работы разных реализаций</h4>
<pre>
------------------------------------------------------
doWorkWithLambda(): lambda.thiz.SomeClass
java.lang.Thread.getStackTrace(Thread.java:1556)
lambda.thiz.StacktracePrinter.print(LambdaVsAnonymousClass.java:115)
lambda.thiz.SomeClass.lambda$doWorkWithLambda$0(LambdaVsAnonymousClass.java:30)
lambda.thiz.SomeClass.doWorkWithLambda(LambdaVsAnonymousClass.java:32)
lambda.thiz.LambdaVsAnonymousClass.main(LambdaVsAnonymousClass.java:10)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
------------------------------------------------------
------------------------------------------------------
doWorkWithAnonymousInnerClass(): lambda.thiz.SomeClass$1
java.lang.Thread.getStackTrace(Thread.java:1556)
lambda.thiz.StacktracePrinter.print(LambdaVsAnonymousClass.java:115)
lambda.thiz.SomeClass$1.func(LambdaVsAnonymousClass.java:42)
lambda.thiz.SomeClass.doWorkWithAnonymousInnerClass(LambdaVsAnonymousClass.java:45)
lambda.thiz.LambdaVsAnonymousClass.main(LambdaVsAnonymousClass.java:11)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
------------------------------------------------------
------------------------------------------------------
StandaloneClass: lambda.thiz.StandaloneClass
java.lang.Thread.getStackTrace(Thread.java:1556)
lambda.thiz.StacktracePrinter.print(LambdaVsAnonymousClass.java:115)
lambda.thiz.StandaloneClass.func(LambdaVsAnonymousClass.java:97)
lambda.thiz.SomeClass.doWorkWithStandaloneClass(LambdaVsAnonymousClass.java:52)
lambda.thiz.LambdaVsAnonymousClass.main(LambdaVsAnonymousClass.java:12)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
------------------------------------------------------
</pre>

		<p>
			Длинновато получилось. Ну да ладно. Посмотрим, как отработала лямбда-функция. Первое отличие от анонимного
			внутреннего класса заключается в том, что <strong>this</strong> "ведет" в разные места:
<pre>
doWorkWithLambda(): lambda.thiz.SomeClass
doWorkWithAnonymousInnerClass(): lambda.thiz.SomeClass$1
</pre>

		<p>
			В случае с лямбда-выражением <code>this</code> указывает на объект окружающего класса, т.е. на объект того
			класса, внутри которого было определено лямбда-выражение. А в случае с анонимным внутренним классом 
			<code>this</code> указывает на экземпляр самого внутреннего класса. Ну а с отдельно стоящим классом и так 
			все понятно: у него нет ничего общего с тем объектом, в котором был создан его экземпляр. В общем, 
			ничего нового я не открыл. Про эту особенность давным-давно рассказывалось в статье
			<a href="https://habrahabr.ru/post/224593/">Лямбда-выражения в Java 8</a>.
		
		<p>
			Если посмотреть в стэктрэйсы, можно тоже увидеть много интересного. Так, при использовании лямбда-выражения
			реализация метода <code>func()</code> называется <strong>lambda.thiz.SomeClass.lambda$doWorkWithLambda$0</strong>.
			Такое синтетическое имя включает в себя имя метода <code>doWorkWithLambda()</code>, в котором лямбда-выражение
			было определено. Очевидно, что <code>doWorkWithLambda()</code> - это нижележащий элемент стэктрэйса:
<pre>
doWorkWithLambda(): lambda.thiz.SomeClass
java.lang.Thread.getStackTrace(Thread.java:1556)
lambda.thiz.StacktracePrinter.print(LambdaVsAnonymousClass.java:61)
lambda.thiz.SomeClass.lambda$doWorkWithLambda$0(LambdaVsAnonymousClass.java:24)
lambda.thiz.SomeClass.doWorkWithLambda(LambdaVsAnonymousClass.java:26)
lambda.thiz.LambdaVsAnonymousClass.main(LambdaVsAnonymousClass.java:8)
</pre>
	
		<p>
			На первый взгляд, имеет место простое дублирование. Может сложиться впечатление, что разработчики Java 8
			"подстраховались", чтобы лямбда-выражения не пугали своими стэктрэйсами. Ибо в строчке:
<pre>
lambda.thiz.SomeClass.lambda$doWorkWithLambda$0(LambdaVsAnonymousClass.java:24)
</pre>
	
		<p>
			за эпическим словом <em>lambda</em> мы видим знаки <em>$</em> и число на конце. "Старомодный" анонимный
			класс в стрэктрэйсе смотрится проще и понятнее (лишь один <em>$</em> и число):
<pre>
lambda.thiz.SomeClass$1.func(LambdaVsAnonymousClass.java:36)
</pre>

		<p>
			Т.о. в данном конкретном случае лямбда-выражения ничего не выигрывают (но и не проигрывают) по сравнению с
			анонимными внутренними классами в плане читаемости
			стэктрэйсов (а стало быть, и логов на сервере). В целом же можно сказать, что именованное всегда лучше 
			неименованного. Т.е. лучше всего и лямбда-выражение, и анонимный класс вынести в отдельный класс с подходящим 
			и емким названием. И больше не путаться в загадочных значках и циферках. Но так лучше не всегда.
			Яркий пример тому ... многопоточность!
			
		<h2>Lambda expressions + Multithreading = ♥</h2>
		
		<p>
			Добавим в наш многострадальный демонстрационный класс еще три метода метода, которые будут выполняться параллельно. 
			Потоки будем брать из фиксированного пула потоков. Для каждой из реализаций задействуем пул единичного размера 
			(чтобы для каждой реализации использовался персональный поток, на всякий случай). Получившиеся методы
			<em>doWorkWithLambdaInSeparateThread()</em>, <em>doWorkWithAnonymousClassInSeparateThread()</em> и 
			<em>doWorkWithStandaloneClassInSeparateThread()</em>, а также отдельностоящий класс,
			который описывает поток, приведены в <a href="#listing-6">листинге 6</a>.
			
<h4 id="listing-6">Листинг 6 - примеры методов, выполняющихся в разных потоках</h4>
<pre>
class SomeClass {
    ...

    public void doWorkWithLambdaInSeparateThread() {
        Executors.newFixedThreadPool(1).
                submit(
                        () -> {
                            System.out.println("!!! doWorkWithLambdaInSeparateThread()");
                            try {
                                throw new StubException("Some error has been occurred.");
                            } catch (StubException thrownManually) {
                                thrownManually.printStackTrace();
                            }
                        }
                );
    }

    public void doWorkWithAnonymousClassInSeparateThread() {
        Executors.newFixedThreadPool(1).
                submit(
                        new Runnable() {
                            @Override
                            public void run() {
                                System.out.println("!!! doWorkWithAnonymousClassInSeparateThread()");
                                try {
                                    throw new StubException("Some error has been occurred.");
                                } catch (StubException thrownManually) {
                                    thrownManually.printStackTrace();
                                }
                            }
                        }
                );
    }

    public void doWorkWithStandaloneClassInSeparateThread() {
        Executors.newFixedThreadPool(1).
                submit(new StandaloneThreadDefinition());
    }
}

class StandaloneThreadDefinition implements Runnable {
    @Override
    public void run() {
        System.out.println("!!! StandaloneThreadDefinition");
        try {
            throw new StubException("Some error has been occurred.");
        } catch (StubException thrownManually) {
            thrownManually.printStackTrace();
        }
    }
}
</pre>

		<p>
			Суть этих "многопоточных" реализаций заключается в том, чтобы сделать в отдельном потоке полезную работу 
			(напечатать строку), затем выбросить исключение и посмотреть, что будет. Т.е. увидеть стэктрэйс. 
			Всем известно, что стэктрэйс
			метода, выполненного в отдельном потоке (т.е. не в основном потоке приложения, а в потоке, взятом из пула потоков)
			не имеет ничего общего со стэктрэйсом потока, который отправил задачу  на выполнение. 
			А именно: предоставил реализацию интерфейса <strong>Runnable</strong> (на самом деле, вариантов больше
			!!!здесь будет ссылка на Javadoc!!!, просто Runnable - самый простой из них).
			Что ж, посмотрим на стэктрэйсы.
			
<h4 id="listing-7">Листинг 7 - Стэктрэйсы методов, выполнившихся в отдельных потоках</h4>
<pre>
!!! doWorkWithLambdaInSeparateThread()
lambda.thiz.StubException: Some error has been occurred.
	at lambda.thiz.SomeClass.lambda$doWorkWithLambdaInSeparateThread$1(LambdaVsAnonymousClass.java:61)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)


!!! doWorkWithAnonymousClassInSeparateThread()
lambda.thiz.StubException: Some error has been occurred.
	at lambda.thiz.SomeClass$2.run(LambdaVsAnonymousClass.java:76)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)


!!! StandaloneThreadDefinition
lambda.thiz.StubException: Some error has been occurred.
	at lambda.thiz.StandaloneThreadDefinition.run(LambdaVsAnonymousClass.java:103)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
</pre>
			
		<p>
			Строчки, начинающиеся с <tt>!!!</tt> можно проигнорировать (вышеупомянутся "полезная работа"), они были 
			добавлены, чтобы стэктрэйсы не путались в листинге.
			Посмотрим на сами стэктрэйсы. 
			Начнем с самого простого: <em>StandaloneThreadDefinition</em>. Что мы видим? Что в потоке выполнения первыми
			были вызваны методы классов из пакета <em>java.util.concurrent</em>, что не удивительно, ведь мы не создавали
			потоки сами, а использовали ExecutorService - стандартное средство из JDK. Выше в стэктрэйсе мы видим строчку:
<pre>
	at lambda.thiz.StandaloneThreadDefinition.run(LambdaVsAnonymousClass.java:103)
</pre>
		
		<p>
			Тут тоже все понятно: когда задача отправляется на выполнение с помощью метода <code>submit()</code> 
			!!!тут будет ссылка на Javadoc!!!, то вызывается метод <code>run()</code> из переданного экземпляра класса,
			который реализует интерфейс Runnable. Вот мы и видим его в стэктрэйсе. Номер строки исходного кода <b>103</b>,  
			(а именно фрагмент <tt>LambdaVsAnonymousClass.java:103</tt>) соответствует месту в теле метода <em>run()</em>
			класса <strong>StandaloneThreadDefinition</strong>. Выше в стэктрэйсе мы видим только само исключение
			<em>StubException</em>. И все! Больше ничего нет! Т.е. глядя только на стэктрэйс потока, в котором выполнился
			метод <code>run()</code> мы никак не узнаем, кто же выполнение этого метода породил, т.е. мы не узнаем, кто
			приказал ExecutorService'у выполнить данную задачу. И не имеет значение, где определен метод <code>run()</code>,
			в анонимном внутреннем классе, или в отдельном классе.
			
			
		<p>
			Казалось бы, чего нового можно сказать про лямбда-выражения? Все уже и так сказали.
			Например, в статье 
			 (cобственно,
			 оттуда я и взял идею 
			для этой дурацкой заметки). Просто захотелось
			самому закопаться в функции.


		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>
