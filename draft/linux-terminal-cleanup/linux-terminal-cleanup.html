<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Очистка терминала в Linux</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#linux-terminal-cleanup" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/linux-terminal-cleanup/linux-terminal-cleanup.html">
				Очистка терминала в Linux
			</a>
		</h1>
		
		<h3>[2018, Январь]</h3>
	
		<h2>Начало</h2>
		
		<p>
			При работе в ОС Linux приходиться много времени проводить в консоли. Частенько хочеться очистить экран от 
			вывода предыдущих команд, т.е начать с "чистого листа" (но с сохранением истории команд). Ничего сложного в 
			этом нет. Возможно, в конкретном эмуляторе терминала для этих целей даже выделена "горячая клавиша". Но 
			нюансы всегда присутствуют. Ведь дьявол (и не только он), как известно, кроется в деталях.
		
		<p>
			Сия ламерская заметка начинается с рассмотрения типичного эмулятора терминала: 
			<strong>GNOME Terminal</strong> (версии <em>3.6.2</em>). А заканчивается виртуальными консолями.
	
		<h2>clear</h2>
		
		<p>
			Для очистки можно использовать команду с вполне предсказуемым названием: <strong>clear</strong>. Зайдем в 
			каталог <i>/bin</i> (там куча мелких файлов) и выполним команду <code>ls</code>. Затем очистим терминал с 
			помощью <code>clear</code>. Результат вышеописанных действий приведен на 
			<a href="#illustration-1">рисунке 1</a>.

<h4 id="illustration-1">Рисунок 1 - результат работы команды clear в эмуляторе терминала</h4>
	<p>
		<img src="illustrations/clear.png"
		width="640px"
		alt="скриншот окна эмулятора терминала GNOME Terminal">
		
		<p>
			Терминал стал чистым. Но не совсем. Обратим внимание на полосу прокрутки (ползунок оказался бледноват, так 
			что я специально подкрасил его красным баллончиком): результаты выполнения предыдущей команды никуда не 
			исчезли. Просто терминал был промотан так, чтобы приглашение командной строки оказалось в самом его верху. 
			В принципе, такой результат небесполезен, но я хотел добиться другого.
		
		<h2>reset</h2>
		
		<p>
			Команда <code>reset</code> очищает терминал более основательно. А именно: удаляется все его содержимое 
			(ползунок в результате расползаеся на всю полосу прокрутки), приглашение оказывается на первой строчке. И 
			вообще, все выглядит так, как будто эмулятор закрыли и запустили снова (история команд, естественно не 
			теряется). Это можно наблюдать на <a href="#illustration-2">рисунке 2</a>.
			
<h4 id="illustration-2">Рисунок 2 - результат работы команды reset в эмуляторе терминала</h4>
	<p>
		<img src="illustrations/reset.png"
		width="640px"
		alt="скриншот окна эмулятора терминала GNOME Terminal">
		
		<p>
			Но у команды <code>reset</code> есть недостаток: она очищает терминал с некоторой задержкой. Т.е. после 
			нажатия <kbd>Enter</kbd> и перед появлением приглашения командной строки в течение примерно одной секунды
			"висит" полностью пустой терминал. Это приллюстрировано на <a href="#illustration-3">рисунке 3</a>.

<h4 id="illustration-3">Рисунок 3 - задержка при очистке терминала с помощью reset</h4>
	<p>
		<img src="illustrations/reset-black-screen.png"
		width="640px"
		alt="скриншот окна эмулятора терминала GNOME Terminal">
	
		<p>
			Из-за чего возникает задержка? Сложно сказать. Как говорится в <code>man reset</code> (<em>tset</em> и 
			<em>reset</em> - синонимы), <cite>Tset first determines the type of terminal that you are using.</cite>. И 
			еще там написано про всякие порты, боды и т.д. Видимо, <code>reset</code> делает настоящую очистку, что 
			позволяет добиться одинаковых результатов не только в эмуляторах терминала и виртуальных консолях, но и в 
			случае с аппаратными терминалами...
	
		<h2>setterm</h2>
	
		<p>
			Вот эта команда мне по душе больше. Она делает то же самое, что и предыдущие две.
	
		<p>
			<strong>setterm -clear</strong> - это аналог <strong>clear</strong>, об этом прямым текстом сказано в 
			руководстве: <cite>Clears the screen and "homes" the cursor, as clear(1)</cite>. Результат работы 
			<code>setterm -clear</code> приводить смысла нет, поскольку он такой же, как на
			<a href="#illustration-1">рисунке 1</a>.
	
		<p>
			<strong>setterm -reset</strong>, в свою очередь, делает то же самое, что и <code>reset</code>, только быстро 
			(вряд ли обе команды в действительности работают полностью одинаково, но результаты идентичны).
		
		<p>
			Команды <strong>reset</strong> и <strong>setterm -reset</strong> могут стать настоящими 
			палочками-выручалочками в некоторых ситуациях. Например, вы решили вывести содержимое двоичного файла в 
			терминал (либо какая-то программа взяла и напечатала в консоль что попало). В принципе, ничего страшного в 
			этом нет. Но появление определенных символов (т.н. управляющих символов) в терминале приводит к 
			непредсказуемым эффектам, от изменения начертания символов до неистового бибиканья. Самый верный способ 
			избавиться от такого рода последствий - нажать <kbd>Ctrl</kbd> + <kbd>C</kbd> (на всякий случай), затем 
			вслепую (терминал "разрушен", мы ничего не увидим, когда будем печатать) набрать <samp>reset</samp> и 
			жмякнуть <kbd>Enter</kbd>. 
		
		<p>
			В случае с <samp>setterm -reset</samp> придеться дольше печатать, следовательно, больше вероятность 
			совершить ошибку. Да и выигрыша времени, по сравнению с <samp>reset</samp>, не будет. Здесь поможет алиас, 
			например, <code>alias tclear='setterm -reset'</code> (запомнить легко: "Total CLEAR").
	
		<h2>А что же с виртуальными консолями?</h2>
	
		<p>
			Виртуальные консоли не так просты, какими кажутся 
			<sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>. Что мы делаем, если текст не помещается
			на один экран эмулятора терминала? Правильно, "крутим" экран вверх колесом мыши или с помощью полосы 
			прокрутки. Но в виртуальной консоли никаких полос и прочих элементов управления нет (как и мыши). Но 
			прокрутка есть. Чтобы прокрутить консоль на один экран вверх, нужно нажать 
			<kbd>Shift</kbd> + <kbd>Page Up</kbd>, а чтобы прокрутить вниз - <kbd>Shift</kbd> + <kbd>Page Down</kbd>
		
		<p>
			В эмуляторе терминала так тоже можно сделать. Только для этого нужно зажимать 
			<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Page Up</kbd> / <kbd>Page Down</kbd>. Еще в эмуляторе терминала 
			возможно прокручивать текст плавно, т.е. построчно, с помощью комбинаций 
			<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>&uarr;</kbd> / <kbd>&darr;</kbd>. Но в виртуальной консоли такой 
			трюк не прокатит. Ни <kbd>Shift</kbd>, ни <kbd>Ctrl</kbd> + <kbd>Shift</kbd> в сочетании со стрелками не 
			работают. Видимо, стандартного способа прокручивать виртуальную консоль построчно в Linux нет 
			(<strong>tmux</strong> и <strong>screen</strong> - не в счет) <sup id="footnote-2-top">
			<a href="#footnote-2-bottom">[2]</a></sup>.
		
		<p>
			Худо-бедно, но прокручивать текст в виртуальной консоли Linux возможно. Hассмотренные выше команды работают 
			там	точно так же, как и в эмуляторе терминала.
		
		<h2>Конец</h2>
	
		<p>
			Что тут сказать?.. Я выбираю <strong>setterm -reset</strong> :)
		
		<p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Внеший вид виртуальных консолей отличается от дистрибутива к дистрибутиву. В некоторых случаях 
						мы можем надеятся на максимальное разрешение 640x480 (совсем как в DOS). Иногда приходиться 
						сталкиваться с другой крайностью: в виртуальной консоли	действует "родное" разрешение монитора 
						(скажем, 1920x1080). Но шрифты по прежнему растровые, взятые исходя из разрешения 640x480. Буквы 
						получаются настолько маленькие, что приходиься напряженно всматриваться в экран, пытаясь 
						что-либо разобрать. Зато текста на один экран помещается много :) 

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a>
						Если, находясь в виртуальной консоли, активировать  (даа, незаслуженно
						забытая клавиша), то ввод текста в консоль и вывод текста на экран приостановится, консоль
						как будто замрет (но программы продолжат выполнение). В виртуальной консоли Linux применение
						<kbd>Scroll Lock</kbd>, к сожалению, этим и ограничивается. Другое дело FreeBSD: находясь в 
						режиме <kbd>Scroll Lock</kbd> можно прокручивать консоль плавно с помощью клавиш-стрелок.
			</ol>	
	
		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>
