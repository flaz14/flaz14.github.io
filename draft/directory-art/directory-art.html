<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Рисуем с помощью каталогов в Linux (на самом деле нет)</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#directory-art" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/directory-art/directory-art.html">
				Рисуем с помощью каталогов в Linux (на самом деле нет)
			</a>
		</h1>
		
		<h3>[2017, Декабрь]</h3>

		<h3>
			<a 
href="тут будет ссылка на исходный код">
				Исходный код
			</a>
		</h3>
		
		<p>
			Однажды в 17-ом номере журнала <a href="http://dgmag.in/">Downgrade</a> я прочитал статью 
			<strong>Издеваемся над файловой системой</strong> за авторством <em>uav1606</em>. Отличная статья! Так что я решил 
			проделать то же самое, только в Linux. 
			
		<p>
			Как известно, Linux поддерживает <strong>Unicode</strong> "из-коробки", т.е. не только на уровне файловой 
			системы, но и в 
			эмуляторах терминала и т.п. В Unicode символов гораздо больше, чем в таблице ASCII. И выбор их огромен 
			(в частности, псевдографических символов в Unicode навалом). Но это не главное. Рисовать можно и с помощью 
			стандартных 
			символов (т.е. с кодами до 128). Набор символов не принципиален. Возможная проблема, как сказал автор, 
			состоит в том, что нельзя создать два 
			каталога/файла с одним именем. Решить ее в DOS можно за счет использования расширения. Автор говорил, что 
			можно
			использовать в расширении комбинации символов с кодом 255 (пустой символ в таблице ASCII) чтобы они не 
			портили рисунок. Но можно использовать
			и обычные, т.е. видимые символы. По-моему, рисунок они не испортят. А если и испортят, то не сильно. Потому 
			что консольные файловые менеджеры в DOS показывают расширение файла/каталога поодаль от его имени. Так, 
			<i>Volcov/Norton Commander</i> в колонке <b>Name</b> выравнивают собственно имя файла/каталога по левому краю, 
			а расширение - по правому (см <a href="#illustration-1">рисунок 1</a>). 
			А поскольку расширения тусуются отдельно, они не сильно будут мешать восприятию рисунка.ы

<h4>Рисунок 1 - в DOS расширение отображается отдельно от имени</h4>
<img src="illustrations/dos-commanders-names-and-extenstions.png">
			
		<p id="note-about-extensions-in-DOS">
			Если задавать расширение с помощью только цифр, то получится 1000 уникальных комбинаций. Но в расширении 
			можно использовать не только цифры.  Можно взять цифры и буквы квы разных регистров. А затем создавать из
			них тройки. Возможных вариантов хватит на любой ASCII-рисунок (в пределах разумного, конечно).
			
		<p id="note-about-sorting-by-name">
			Вторая проблема (строго говоря, это не проблема, а личное предпочтение): по-умолчанию в большинстве
			файловых менеджеров сортировка листинга каталога осуществляется по имени содержащихся в нем объектов. 
			По-моему,
			"рисованный" каталог, который не требует для своего корректного отображения дополнительного шаманства 
			(т.е. установки вручную режима сортировки по расширению либо по дате модификации и т.д.) - гораздо круче и 
			изящнее. Здесь на сцену и выходит Unicode.
		
		<p>
			Если в ASCII есть только один пустой символ 
			(не считая настоящего пробела с кодом 32) - символ с кодом 255, то в Unicode пробелов гораздо больше. Вгляните
			сами на таблицу <a href="http://jkorpela.fi/chars/spaces.html">Unicode spaces</a>. Да-да, не все Unicode-пробелы
			"хорошие".
			Например, пробел <code>U+1680</code> отображается в терминале в виде закорючки непонятной. Пробел 
			<code>U+180E</code>, как сказано в комментарии к вышеупомянутой таблице, не имеет длины, т.е. отображается 
			в терминале
			как пустое место. А пробел <code>U+3000</code>, наоборот, выглядит в терминале слишком толстым, т.е. занимает
			не одно, а два знакоместа. Некоторые символы, такие как <code>U+200B</code> и <code>U+FEFF</code> вовсе 
			не задумывались
			как визуально различимые, так что их от использования тоже лучше отказаться. Как бы то ни было, можно 
			выбрать действительно хорошие Unicode-пробелы, которые не корежатся в терминале и выглядят все как один 
			(в силу того, что 
			в консоли используется моноширинный шрифт).
			
		<p>
			Кроме пробелов, есть в Unicode символы, которые не являются пробелами, но выглядят пустыми. Например, 
			арабские символы <code>U+0600</code> - <code>U+0604</code> выглядят пустыми в таблице символов 
			(я использовал для их просмотра программу 
			<a href="https://wiki.gnome.org/action/show/Apps/Gucharmap?action=show&redirect=Gucharmap">
			GNOME Character Map</a>, основанной на версии Unicode 6.3.0). 
			Они приведены на <a href="#illustration-2">рисунке 2</a>. 
			
<h4 id="illustration-2">Рисунок 2 - арабские символы в программе GNOME Character Map</h4>	
<img src="illustrations/arabic-characters-in-table.png">
			
		<p>	
			Но  
			появление некоторых из этих символов в терминале приводит к забавным эффектам. Так, следующие за ними 
			символы буквально пишутся поверх арабских (что неудивительно, ведь мы смешали символы из языков, в которых 
			пишут справа налево и слева направо). 
			Я просто попытался вывести на экран (из Python-скрипта) символы, заключив их в квадратные скобки. "Обычный"
			пробел отобразился нормально. А вот арабские символы отобразились в виде иероглифов, а не так, как они выглядели
			в таблице. Кроме того, закрывающие квадратные скобки "наехали" на иероглифы.
			Эту ситуацию можно наблюдать на <a href="#illustration-3">рисунке 3</a>.

<h4 id="illustration-3">Рисунок 3 - арабские символы в эмуляторе терминала</h4>
<img src="illustrations/arabic-characters-in-terminal.png">
			
		<p>
			Так что не все так радужно с Unicode-пробелами на первый взгляд. Как бы то ни было, наскрести в таблице Unicode 
			десяток-другой "хороших" пробелов можно. Естественно, их можно комбинировать, как и в 
			<a href="#note-about-extensions-in-DOS">случае с цифрами и буквами
			в расширениях</a>.  Пробелы уж точно не испортят
			рисунок. Их можно смело добавлять их к каждой строке оригинального рисунка слева и/или справа - никто не заметит.
			
		<p>
			Хорошо, мы набрали команду "хороших" пробелов. Но в зависимости от установленной локали 
			(шрифтов и, может быть, особенностей конкретного эмулятора терминала), "хорошие" пробелы
			могут стать плохими, т.е. кракозябрами (в Windows, насколько 
			я знаю, аналогичная ситуация с растровыми шрифтами в <i>cmd.exe</i>).
			
		<p>
			Итак, проблема уникальности имен файлов/каталогов при неизменном внешнем виде с помощь Unicode-пробелов
			решаема.
			
		<h2>Сортировка</h2>
			
		<p>
			Итак, посмотрим, какие возможности сортировки листинга каталога предоставляет Linux. Стандартная команда 
			<strong>ls</strong>
			по-умолчанию выводит содержимое каталога в несколько столбцов, как показано на 
			<a href="#illustration-4">рисунке 4</a>.

<h4 id="illustration-4">Рисунок 4 - отображение листинга каталога командой ls с параметрами по-умочанию</h4>
<img src="illustrations/ls-with-default-parameters.png">
			
		<p>
			С помощью параметра <em>-1</em> (он же <em>--format=single-column</em>) можно вывести содержимое в один
			столбец, как показано на <a href="#illustration-5">рисунке 5</a>.

<h4 id="illustration-5">Рисунок 5 - отображение листинга командой ls в один столбец</h4>
<img src="illustrations/ls-with-format-parameter.png">

		<p>
			Этого достаточно для красивого представления рисунка в консоли.
		
		<p>
			С сортировкой все то же просто. Достаточно применить параметр <em>--sort=WORD</em>:
			<blockquote>
				<p>sort by WORD instead of name: none -U, extension -X,  size -S, time -t, version -v
			</blockquote>
			
		<p>
			Консольный файловый менеджер <a href="https://midnight-commander.org/">Midnight Commander</a> 
			предоставляет несколько больше
			возможностей для сортировки (см. <a href="#illustration-6">рисунок 6</a>).
			
<h4 id="illustration-6">Рисунок 6 - опции сортировки листинга каталога в Midnight Commander</h4>
<img src="illustrations/mc-sorting-options.png">
			
		<p>Разберем их.
		
		<dl>
			<dt>
				Unsorted
			<dd>
				Можно даже не рассматривать. Порядок элементов в листинге хаотический по определению, что не годится
				для рисунка.
			
			<dt>
				Name
			<dd>
				Сортировка по имени совместно с Unicode - большая и больная тема. Разберемся с ней позднее.
			
			<dt>
				Version
			<dd>
				Примитивное версионирование файлов в Unix. Некоторые сведения можно почерпнуть из 
				<a href="https://midnight-commander.org/ticket/1994">
					cистемы отслеживания ошибок Midnight Commander</a>. Цифры на конце имени сделают рисунок хуже, да и 
				сортировка по версии не сильно лучше сортировки по дате модификации, к примеру.

			<dt>
				Extension
			<dd>
				Расширения в Linux нам не сильно помогут. Дело в том, что расширения файлов - не "родная" концепция
				Unix. И, в отличие от <a href="#illustration-1">консольных файловых менеджеров для DOS</a> 
				в <em>Midnight Commander</em> расширения не 
				отображаются отдельно, а рядом с именем файла (то же самое касается команды <em>ls</em>). Воздержимся от
				их использования.
			
			<dt>
				Size
			<dd>
				Отлично подойдет для файлов (что нам стоит напихать в них нулевые байты). Но с директориями не прокатит:
				их размер всегда равен 4096 байт.
			
			<dt>
				Modify time / Access time / Change time
			<dd>
				Их как нечего можно использовать для сортировки. Особенно если учесть, 
				что <strong>Modify time</strong> выводится в <em>Midnight Commander</em>в отдельной колонке 
				(a комадна <em>ls</em> вообще не показывает время если листинг выводится
				в один столбец. А вариантов тут много - даже точность в одну секунду дает фантастические результаты в 
				плане максимального количества одновременно сортируемых элементов.
			
			<dt>
				Inode
			<dd>
				Не подходят, поскольку их значения непредсказуемы.

			<dt>
				Executable first
			<dd>
				Не подходит ничуть, понятное дело.
				
			<dt>
				Case sensitive
			<dd>
				Cвязано с сортировкой по имени, но об это позже.
			
			<dt>
				Reverse
			<dd>
				Полезно, если только захочется перевернуть рисунок.
		</dl>
			
		<h2>Сортировка по имени</h2>
		
		<p>
			Как уже было сказано <a href="note-about-sorting-by-name">выше</a>, сортировка по имени придаст рисунку 
			заметный плюс в плане его отображения без 
			дополнительных настроек. А если еще устанавливать синхронно с сортировкой по имени дату модификации файла 
			(и прочие атрибуты), то можно будет рисовать так, что как ни сортируй листинг, он все равно будет рисунком
			(разве что перевернутым)! Заманчивая идея задействовать Unicode-пробелы (здесь и далее я имею ввиду 
			"хорошие" пробелы)...  И кроме сортировки, Unicode-пробелы помогу поддерживать уникальности строк в рисунке!
			Ведь коды пробелов разные (в вышеупомянутой таблице пробелов пробелы приведены в порядке возрастания их кодов).
			
		<p>
			Можно поступить следующим образом: к началу каждой строки исходного ASCII-рисунка приклеить по Unicode-пробелу
			в соответствии с порядковым номером строки, т.е. чтобы коды пробелов возрастали в ту же сторону, куда растут 
			номера строк в оригинальном рисунке. Если строк в оригинальном рисунке слишком много (скажем, в нашем распоряжении
			10 пробелов, а строк в рисунке 20), то можно подставлять пробелы парами, тогда максимально возможное количество
			строк возрастает до 100 (10x10).
			
		<h2>Не тут-то было!</h2>
		
		<p>
			Все "можно" из предыдущего абзаца мигом превращаются в "нельзя" на практике. Дело в пресловутых локалях. 
			Но обо все по порядку.
			
		<p>
			Нарисуем превдографическую букву "а" (на самом деле возьмем ее из написанной ранее статьи!!!тут будет ссылка
			на креативные сообщения в skype!!!).  с небольшими изменениями Она приведена в листинге 1
			
		Листинг 1 - буква а
<pre>
       
  ***  
 *   * 
 ***** 
 *   * 
 *   * 
       
</pre>		

		<p>
			Всего 7 строчек. Добавляем к каждой строке по одному Unicode-пробелу из таблицы - и дело в шляпе. Но все не так
			в реальности (см. листинг 2)
			
		Листинг 2 - реальная сортировка имен, содержащих Unicode-пробелы
<pre>
yura@Aspire-ES1-521 ~/Projects/directory-art $ ls -1 /tmp/tmp5q6h_hjr
        
   ***  
  *   * 
  *   * 
  *   * 
  ***** 
        
</pre>	
		
		<p>
			Что же пошло не так? На самом деле, все идет именно так, как нужно. С точки зрения текущей локали (<tt>en_US.UTF-8</tt>)
			все Unicode-пробелы (за исключением, быть может, "обычного пробела" - c кодом 32, hex - U+0020) - одинаковые
			символы. Это как если бы в Java Comparator !!!тут будет ссылка на Javadoc!!! для каждой пары пробелов возвращал
			0. Это значит, что порядок файлов, имена которых начинаются с пробелов, не определен в листинге директории.
			Т.е. наличие/отсутствие пробелов ничего не меняет. Если, например, в исходном рисунке поставить цифры перед каждой
			строкой, как это показано в листинге 3
			
			
			Листинг 3
<pre>
1       
2  ***  
5 *   * 
3 ***** 
4 *   * 
9 *   * 
8       
</pre>
			
		<p>
			то строки в листинге будут осортированы в соответствии с цифрами, как показано на рисунке 10
			
Рисунок 10 - пробелы ни на что не влияют, сортировка осуществляется по цифрам
			
		<p>На рисунке можно заметить, что перед каждой строкой стоит пробел. И все эти пробелы разные, а именно они взяты из группы:
	\u2003 - [ ]
	\u200A - [ ]
	\u2000 - [ ]
	\u202F - [ ]
	\u2005 - [ ]
	\u205F - [ ]
	\u2009 - [ ]
		
		<p>
			Но, поскольку пробелы не вписываются в качестве обычных символов в алфавит локали <tt>en_US.UTF-8</tt>, то
			все они равны.
			
		
		
		
		
		
		
		
		<h2>Lambda expression != Anonymous inner class</h2>
		
		<p>
			Мы привыкли думать, что лямбда-выражения и анонимные внутренние классы - это одно и то же (кроме улучшенных 
			синтаксиса и правил выведения типов). Но это не так. 
		
		<p>
			Пусть у нас есть простой функциональный интерфейс <code>SomeFunction</code>.

<h4 id="listing-1">Листинг 1 - простой функциональный интерфейс</h4>
<pre>
@FunctionalInterface
interface SomeFunction {
    void func();
}
</pre>
		
		<p>
			Подготовим три реализации этого интерфейса: с использованием лямбда-выражения, с помощью привычного 
			анонимного внутреннего класса и с помощью внешнего класса. Сделаем так, чтобы они вызывались из	
			нестатических методов класса <code>SomeClass</code> (см. <a href="#listing-2">листинг 2</a>, горизонтальные 
			линейки я добавил для ясности, чтобы результаты работы разных методов не путались).

<h4 id="listing-2">Листинг 2 - класс для демонстрации реализаций функционального интерфейса</h4>
<pre>
class SomeClass {
    public void doWorkWithLambda() {
        System.out.println("------------------------------------------------------");
        final SomeFunction function = () -> {
            System.out.println("doWorkWithLambda(): " + this.getClass().getName());
            StacktracePrinter.print();
        };
        function.func();
        System.out.println("------------------------------------------------------");
    }

    public void doWorkWithAnonymousInnerClass() {
        System.out.println("------------------------------------------------------");
        final SomeFunction function = new SomeFunction() {
            @Override
            public void func() {
                System.out.println("doWorkWithAnonymousInnerClass(): " + this.getClass().getName());
                StacktracePrinter.print();
            }
        };
        function.func();
        System.out.println("------------------------------------------------------");
    }

    public void doWorkWithStandaloneClass() {
        System.out.println("------------------------------------------------------");
        final SomeFunction function = new StandaloneClass();
        function.func();
        System.out.println("------------------------------------------------------");
    }

    ...
}
</pre>

		<p>
			Ниже приведена реализация метода <code>func()</code> посредством обычного класса.

<h4 id="listing-3">Листинг 3 - реализация функционального интерфейса с помощью внешнего класса</h4>
<pre>
class StandaloneClass implements SomeFunction {
    @Override
    public void func() {
        System.out.println("StandaloneClass: " + this.getClass().getName());
        StacktracePrinter.print();
    }
}
</pre>

		<p>
			Все три реализации всего лишь печают имя класса и стэк вызовов. Для распечатки стэктрэйса используется 
			вспомогательный класс с единственным статическим методом, ничего особенного.
			
<h4 id="listing-4">Листинг 4 - вспомогательный класс для распечатки стэка вызовов</h4>
<pre>
class StacktracePrinter {
    public static void print() {
        final StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace();
        Stream.of(stacktrace).
                forEach(System.out::println);
    }
}
</pre>

		<p>
			Теперь запустим все это хозяйство. И получим вывод, приведенный в <a href="#listing-5">листинге 5</a>.

<h4 id="listing-5">Листинг 5 - результаты работы разных реализаций</h4>
<pre>
------------------------------------------------------
doWorkWithLambda(): lambda.thiz.SomeClass
java.lang.Thread.getStackTrace(Thread.java:1556)
lambda.thiz.StacktracePrinter.print(LambdaVsAnonymousClass.java:115)
lambda.thiz.SomeClass.lambda$doWorkWithLambda$0(LambdaVsAnonymousClass.java:30)
lambda.thiz.SomeClass.doWorkWithLambda(LambdaVsAnonymousClass.java:32)
lambda.thiz.LambdaVsAnonymousClass.main(LambdaVsAnonymousClass.java:10)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
------------------------------------------------------
------------------------------------------------------
doWorkWithAnonymousInnerClass(): lambda.thiz.SomeClass$1
java.lang.Thread.getStackTrace(Thread.java:1556)
lambda.thiz.StacktracePrinter.print(LambdaVsAnonymousClass.java:115)
lambda.thiz.SomeClass$1.func(LambdaVsAnonymousClass.java:42)
lambda.thiz.SomeClass.doWorkWithAnonymousInnerClass(LambdaVsAnonymousClass.java:45)
lambda.thiz.LambdaVsAnonymousClass.main(LambdaVsAnonymousClass.java:11)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
------------------------------------------------------
------------------------------------------------------
StandaloneClass: lambda.thiz.StandaloneClass
java.lang.Thread.getStackTrace(Thread.java:1556)
lambda.thiz.StacktracePrinter.print(LambdaVsAnonymousClass.java:115)
lambda.thiz.StandaloneClass.func(LambdaVsAnonymousClass.java:97)
lambda.thiz.SomeClass.doWorkWithStandaloneClass(LambdaVsAnonymousClass.java:52)
lambda.thiz.LambdaVsAnonymousClass.main(LambdaVsAnonymousClass.java:12)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:498)
com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
------------------------------------------------------
</pre>

		<p>
			Посмотрим, как отработала лямбда-функция. Первое отличие от анонимного внутреннего класса заключается в том,
			что <strong>this</strong> "ведет" в разные места:
<pre>
doWorkWithLambda(): lambda.thiz.SomeClass
doWorkWithAnonymousInnerClass(): lambda.thiz.SomeClass$1
</pre>

		<p>
			В случае с лямбда-выражением <code>this</code> указывает на объект окружающего класса, т.е. на объект того
			класса, внутри которого было определено лямбда-выражение. А в случае с анонимным внутренним классом 
			<code>this</code> указывает на экземпляр самого внутреннего класса. С отдельно же стоящим классом и так все 
			понятно: у него нет ничего общего с тем объектом, в котором был создан его экземпляр. Америку я не открыл. 
			Про эту особенность давным-давно рассказали в статье
			<a href="https://habrahabr.ru/post/224593/">Лямбда-выражения в Java 8</a>.
		
		<p>
			Если посмотреть на стэктрэйсы, можно увидеть много интересного. Так, при использовании лямбда-выражения
			реализация метода <code>func()</code> называется <b>lambda.thiz.SomeClass.lambda$doWorkWithLambda$0</b>.
			Такое синтетическое имя включает в себя имя метода <code>doWorkWithLambda()</code>, в котором 
			лямбда-выражение было определено. Очевидно, что <code>doWorkWithLambda()</code> - это нижележащий элемент 
			стэктрэйса:
<pre>
...
lambda.thiz.SomeClass.lambda$doWorkWithLambda$0(LambdaVsAnonymousClass.java:24)
lambda.thiz.SomeClass.doWorkWithLambda(LambdaVsAnonymousClass.java:26)
...
</pre>
	
		<p>
			На первый взгляд, имеет место простое дублирование. Может сложиться впечатление, что разработчики Java 8
			"подстраховались", чтобы лямбда-выражения не пугали своими стэктрэйсами. Ибо в строчке:
<pre>
lambda.thiz.SomeClass.lambda$doWorkWithLambda$0(LambdaVsAnonymousClass.java:24)
</pre>
	
		<p>
			за эпическим словом <em>lambda</em> мы видим знаки <em>$</em> и число на конце. Старомодный анонимный класс 
			в стрэктрэйсе выглядит проще и понятнее (лишь один <em>$</em> и число):
<pre>
lambda.thiz.SomeClass$1.func(LambdaVsAnonymousClass.java:36)
</pre>

		<p>
			Т.о. в данном конкретном случае лямбда-выражения ничего не выигрывают (но и не проигрывают) по сравнению с
			анонимными внутренними классами в плане читаемости стэктрэйсов (а стало быть, и логов на сервере). Вообще, 
			именованное всегда лучше неименованного. Т.е. лучше всего и лямбда-выражение, и анонимный класс вынести в 
			отдельный класс с подходящим и емким названием. Больше не придеться путаться в загадочных значках и 
			циферках. Но так лучше не всегда. Яркий пример тому... многопоточность!
		
		<h2>Lambda expressions + Multithreading = ♥</h2>
		
		<p>
			Добавим в наш многострадальный демонстрационный класс еще три метода метода, которые будут выполняться 
			параллельно. Потоки будем брать из фиксированного пула потоков единичного размера, чтобы каждая реализация  
			выполнялась в персональном потоке. Получившиеся методы <code>doWorkWithLambdaInSeparateThread()</code>, 
			<code>doWorkWithAnonymousClassInSeparateThread()</code> и 
			<code>doWorkWithStandaloneClassInSeparateThread()</code>, а также отдельностоящий класс, который реализует 
			<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a>, приведены в 
			<a href="#listing-6">листинге 6</a>.

<h4 id="listing-6">Листинг 6 - примеры методов, выполняющихся в разных потоках</h4>
<pre>
class SomeClass {
    ...

    public void doWorkWithLambdaInSeparateThread() {
        Executors.newFixedThreadPool(1).
                submit(
                        () -> {
                            System.out.println("!!! doWorkWithLambdaInSeparateThread()");
                            try {
                                throw new StubException("Some error has been occurred.");
                            } catch (StubException thrownManually) {
                                thrownManually.printStackTrace();
                            }
                        }
                );
    }

    public void doWorkWithAnonymousClassInSeparateThread() {
        Executors.newFixedThreadPool(1).
                submit(
                        new Runnable() {
                            @Override
                            public void run() {
                                System.out.println("!!! doWorkWithAnonymousClassInSeparateThread()");
                                try {
                                    throw new StubException("Some error has been occurred.");
                                } catch (StubException thrownManually) {
                                    thrownManually.printStackTrace();
                                }
                            }
                        }
                );
    }

    public void doWorkWithStandaloneClassInSeparateThread() {
        Executors.newFixedThreadPool(1).
                submit(new StandaloneThreadDefinition());
    }
}

class StandaloneThreadDefinition implements Runnable {
    @Override
    public void run() {
        System.out.println("!!! StandaloneThreadDefinition");
        try {
            throw new StubException("Some error has been occurred.");
        } catch (StubException thrownManually) {
            thrownManually.printStackTrace();
        }
    }
}
</pre>

		<p>
			Суть этих многопоточных реализаций заключается в том, чтобы сделать в отдельном потоке полезную работу 
			(напечатать строку), затем выбросить исключение и посмотреть, что будет. Т.е. увидеть стэктрэйс. Всем 
			известно, что стэктрэйс метода, выполнившегося в отдельном потоке (т.е. не в основном потоке приложения, а в
			потоке, взятом из пула) не имеет ничего общего со стэктрэйсом потока, который отправил задачу на выполнение 
			посредством 
			<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html#submit-java.lang.Runnable-">
				java.util.concurrent.ExecutorService#submit(java.lang.Runnable)</a>. Что ж, посмотрим на стэктрэйсы.

<h4 id="listing-7">Листинг 7 - стэктрэйсы методов, выполнившихся в разных потоках</h4>
<pre>
!!! doWorkWithLambdaInSeparateThread()
lambda.thiz.StubException: Some error has been occurred.
	at lambda.thiz.SomeClass.lambda$doWorkWithLambdaInSeparateThread$1(LambdaVsAnonymousClass.java:62)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)


!!! doWorkWithAnonymousClassInSeparateThread()
lambda.thiz.StubException: Some error has been occurred.
	at lambda.thiz.SomeClass$2.run(LambdaVsAnonymousClass.java:78)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)


!!! StandaloneThreadDefinition
lambda.thiz.StubException: Some error has been occurred.
	at lambda.thiz.StandaloneThreadDefinition.run(LambdaVsAnonymousClass.java:106)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
</pre>
			
		<p>
			Строчки, начинающиеся с <tt>!!!</tt>, можно проигнорировать (это вышеупомянутая "полезная работа"); они были 
			добавлены, чтобы стэктрэйсы не путались в листинге. Начнем с самого простого: 
			<code>StandaloneThreadDefinition</code>. Что мы видим? Что в потоке выполнения первыми были вызваны методы 
			классов из пакета <em>java.util.concurrent</em>, что неудивительно, ведь мы не создавали потоки сами, а 
			использовали 
			<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">
				ExecutorService</a> - стандартное средство JDK. Непосредственно за строкой, соответствующей возникшему 
			исключению, в стэктрэйсе мы видим строчку:
<pre>
	at lambda.thiz.StandaloneThreadDefinition.run(LambdaVsAnonymousClass.java:103)
</pre>
		
		<p>
			Тут тоже все понятно: когда задача отправляется на выполнение с помощью метода 
			<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html#submit-java.lang.Runnable-">
				java.util.concurrent.ExecutorService#submit(java.lang.Runnable)</a>, вызывается метод 
			<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html#run--">
				java.lang.Runnable#run</a>, из переданного экземпляра класса, который реализует интерфейс 
			<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a>. Вот мы и видим его
			в стэктрэйсе. 
			Номер строки исходного кода <b>106</b> (<tt>LambdaVsAnonymousClass.java:106</tt>) соответствует месту в теле
			метода <code>run()</code> класса <code>StandaloneThreadDefinition</code> (см. 
			<a href="#illustration-1">рисунок 1</a>).
			
<h4 id="illustration-1">Рисунок 1 - исходный кода класса StandaloneThreadDefinition</h4>
<p>
	<img src="illustrations/StandaloneThreadDefinition.png" 
	width="480px"
	alt="фрагмент исходного кода с номерами строк, открытого в IDE IntelliJ IDEA">
			
		<p>
			Выше в стэктрэйсе мы видим только само исключение <code>StubException</code>. И все! Больше ничего нет! Т.е.
			глядя только на стэктрэйс потока, в котором выполнился метод <code>run()</code>, мы никак не узнаем, кто же 
			породил выполнение этого метода в отдельном потоке.
		
		<p>
			Теперь рассмотрим ситуацию с анонимным внутренним классом. Строчка
<pre>
	at lambda.thiz.SomeClass$2.run(LambdaVsAnonymousClass.java:78)
</pre>

		<p>
			недвусмысленно говорит, что исключение возникло в методе <code>run()</code> анонимного внутреннего класса.
			По номеру строки исходного текста <b>78</b> найдем местоположение проблемного кода:
			
<h4 id="illustration-2">Рисунок 2 - исходный код анонимного внутреннего класса, реализующего Runnable</h4>
<p>
	<img src="illustrations/doWorkWithAnonymousClassInSeparateThread().png"
	width="640px"
	alt="фрагмент исходного кода с номерами строк, открытого в IDE IntelliJ IDEA">
			
		<p>
			Это уже лучше, чем в случае с отдельностоящим классом. Анонимный внутренний класс может быть отправлен на 
			обработку в отдельном потоке только из того места, где этот анонимный класс был определен. Что заметно
			сужает область поиска причины ошибки.
			
		<p>
			И наконец, разберем ситуацию с лямбда-выражением. Мы не увидим в стэктрэйсе упоминание о выполнении метода
			<code>run()</code>, как будто наша лямбда-функция и не реализует интерфейс 
			<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a>. Кроме одинаковых с
			предыдующими двумя случаями строк, мы найдем в стэктрэйсе (непосредственно перед самим исключением) вот эту:
<pre>
	at lambda.thiz.SomeClass.lambda$doWorkWithLambdaInSeparateThread$1(LambdaVsAnonymousClass.java:62)
</pre>

		<p>
			О чем она говорит, и что в ней особенного? Номер строки исходного текста <b>62</b> как обычно указывает на 
			место возникновения исключения (см. <a href="#illustration-3">рисунок 3</a>).

<h4 id="illustration-3">Рисунок 3 - исходный текст лямбда-выражения, реализующего Runnable</h4>
<p>
	<img src="illustrations/doWorkWithLambdaInSeparateThread().png" 
	width="640px"
	alt="фрагмент исходного кода с номерами строк, открытого в IDE IntelliJ IDEA">

		<p>
			Так же, как и в случае с анонимным внутренним классом, лямбда-выражение "привязано" к методу, в котором оно 
			определено. Но есть одна особенность: в стэктрэйсе мы видим, кроме номера строки исходного кода, имя 
			синтетического метода, соответствующего лямбда-выражению: 
			<tt>lambda$doWorkWithLambdaInSeparateThread$1</tt>. А в нем мы видим <b>имя метода, в котором было 
			определено лямбда-выражение</b>, т.е. <tt>doWorkWithLambdaInSeparateThread()</tt> в нашем примере.
		
		<p>
			Т.о. в случае возникновения исключения в лямбда-выражении, выполняющемся в отдельном потоке, мы получим не 
			только номер строки исходного текста, в котором возникло исключение, но и имя метода, который отправил 
			задачу на выполнение. Это не такой уж большой плюс по сравнению со старомодным анонимным внутренним классом.
			Тем не менее, дополнительная зацепка всегда кстати. Ведь кроме поиска по номеру строки в исходниках эти 
			самые исходники можно будет быстренько "грепнуть" на предмет метода, имя которого было с заботой приклеено к
			синтетическому имени автоматически. Конечно, в реальных приложениях лучше сохранять трассировку стэка 
			клиента полностью, как об этом рассказано в статье 
			<a href="https://habrahabr.ru/post/260953/">10 советов по использованию ExecutorService</a>. Но боятся 
			лямбда-выражений в многопоточном программировании точно не стоит.
			
		<h2>Итог</h2>
		
		<p>
			Лямбда-выражения - это больше, чем синтаксический сахар. Указатель <strong>this</strong> ведет туда, куда 
			надо, а не в синтетический класс какой-нибудь. И лямбда-выражения ничем не уступают своим традиционным 
			собратьям - анонимным внутренним классам. Даже выигрывают у них немного. Что же касается отдельностоящих 
			классов, то в многопоточном программировании лямбда-выражения уделывают именнованных особ.
		
		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>
