<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Как начать программировать на Java без использования IDE</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#java-without-ide" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-without-ide/java-without-ide.html">
				Как начать программировать на Java без использования IDE
			</a>
		</h1>
		
		<h3>[2018, Май]</h3>
		
		<h2>Введение</h2>
		
		<p>
			В этой статье не пойдет речь о том, что IDE - это плохо, и что нужно отказаться от помощи сред разработки.
			И ничего не будет сказано, как сделать свою IDE, например, нашпиговать Vim плагинами. И дело не только в том, 
			что автор не знаком с Vim на достаточном для серьезного редактирования текста, а стало быть, и написания кода, 
			уровне ("ключевое" время в жизни, т.е. время привыкания, прошло под знаменем Turbo Pascal
			и MS-DOS). Просто настройка текстового редактора "под себя" - это создание все той же среды разработки. Что
			не приносит ничего нового. Попробуем же обратиться к истокам - командной строке и соответствующим утилитам.
			
		<h2>Версия JDK</h2>
		
		<p>
			В качестве примера возьмем Java 8 от компании Oracle:
<pre>
$ java -version

java version "1.8.0_162"
Java(TM) SE Runtime Environment (build 1.8.0_162-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)
</pre>

		<p>
			В Java 9 структура каталогов JDK другая, лень с ней разбираться. Да и зачем все эти новые технологии? Еще восьмую 
			версию не полностью исследовали.
		
		<h2>Установка JDK</h2>
		
		<p>
			В ламерской заметке 
			(<a href="http://flaz14.github.io/once-again-about-jdk-installation/once-again-about-jdk-installation.html">
			Еще раз об установке JDK</a>) вскользь упоминалось о важности присутствия исходных текстов в каталоге с 
			собственно JDK. 
			
			Программы не стоит устанавливать в домашний каталог. Конечно, для тех из них, которые обновляются автоматически
			в обход системы управления пакетами, иного выбора нет. В случае же с JDK автоматическое обновление не представляет
			затруднений, потому что его просто нет. Да и нет смысла перезатирать предыдущую версию. Мало ли, понадобиться
			запустить что-нибудь на конкретной версии. Тем более, что даже в распакованном виде JDK занимает сравнительно
			немного места. Так, версия JDK, упомянутая в предыдущем абзаце, в распакованном виде занимает на диске
			всего лишь 472 Мегабайт, что даже меньше, чем объем оперативной памяти, потребляемой современные 
			прикладными программами (привет, новый Skype for Linux).
			
			Так вот, установка программ куда-нибудь в /opt в первую очередь, более безопасна: никто, кроме root, не сможет
			подменить исполняемый файл программы. Хотя это и не нужно на самом деле: тот, кто может выполнять команды
			от имени обычного пользователя, без труда получит права root, достаточно лишь подсунуть настоящему пользователю
			свою версию sudo. В общем, совсем не трудно замутить что-нибудь эдакое.
			
			Стоит в большей степени опасаться неумышленного повреждения файлов установленной программы законным пользователем.
			
		<p>
			Пусть мы распаковали дистрибутив JDK в каталог <i>/usr/local/soft</i>. В комплект поставки JDK входят исходные
			тексты, они хранятся в файле src.zip. Создадим директорию с именем <i>src</i> и распакуем в нее архив.
			Каталоги выглядят следующим образом:
<pre>
$ ls -l

total 25940
drwxr-xr-x 2 root root     4096 Dec 20 08:24 bin
-r--r--r-- 1 root root     3244 Dec 20 08:24 COPYRIGHT
drwxr-xr-x 4 root root     4096 Dec 20 08:24 db
drwxr-xr-x 3 root root     4096 Dec 20 08:24 include
-rw-r--r-- 1 root root  5203041 Dec 20 01:57 javafx-src.zip
drwxr-xr-x 5 root root     4096 Dec 20 08:24 jre
drwxr-xr-x 5 root root     4096 Dec 20 08:24 lib
-r--r--r-- 1 root root       40 Dec 20 08:24 LICENSE
drwxr-xr-x 4 root root     4096 Dec 20 08:24 man
-r--r--r-- 1 root root      159 Dec 20 08:24 README.html
-rw-r--r-- 1 root root      424 Dec 20 08:24 release
drwxr-xr-x 7 root root     4096 Apr 17 17:47 src
-rw-r--r-- 1 root root 21096465 Dec 20 08:24 src.zip
-rw-r--r-- 1 root root    63933 Dec 20 01:57 THIRDPARTYLICENSEREADME-JAVAFX.txt
-r--r--r-- 1 root root   145180 Dec 20 08:24 THIRDPARTYLICENSEREADME.txt
</pre>			

			Теперь у нас есть исходные тексты в удобном для обозревания и чтения виде:
<pre>
$ tree src

src
├── com
│   └── sun
│       ├── corba
...
│       ├── image
│       │   └── codec
│       │       └── jpeg
│       │           ├── ImageFormatException.java
│       │           ├── JPEGCodec.java
│       │           ├── JPEGDecodeParam.java
│       │           ├── JPEGEncodeParam.java
│       │           ├── JPEGHuffmanTable.java
│       │           ├── JPEGImageDecoder.java
│       │           ├── JPEGImageEncoder.java
│       │           ├── JPEGQTable.java
│       │           └── TruncatedFileException.java
│       ├── imageio
│       │   ├── plugins
...
│       ├── java
│       │   └── swing
...
│   ├── io
│   │   ├── Bits.java
│   │   ├── BufferedInputStream.java
│   │   ├── BufferedOutputStream.java
│   │   ├── BufferedReader.java
│   │   ├── BufferedWriter.java
...
│   ├── lang
│   │   ├── AbstractMethodError.java
│   │   ├── AbstractStringBuilder.java
│   │   ├── annotation
│   │   │   ├── AnnotationFormatError.java
│   │   │   ├── Annotation.java
│   │   │   ├── AnnotationTypeMismatchException.java
│   │   │   ├── Documented.java
│   │   │   ├── ElementType.java
...

487 directories, 7729 files
</pre>		

		<h2>И что же делать с исходниками?</h2>
		
		<p>
			Ответ прост: читать :) Поскольку обычные пользователи имеют право только читать содержимое установленного 
			нами JDK (а именно этого мы и добивались в предыдущем абзаце), можно смело открывать исходники в любимом текстовом
			редакторе, и, наслаждаясь подсветкой синтаксиса, неспешно читать их. Можно даже "редактировать" их, делать пометки,
			стирать ненужное (естественно, изменения сохранены не будут) и т.д. А поскольку файлы .java разложены в строгом
			соответствии со структурой пакетов, то посмотреть исходный код класса, например, Integer совсем несложно будет
<pre>
$ less java/lang/Integer.java
</pre>

		!!!!
		Сноска: именно так, т.е. через <code>/</code> и ссылается на классы JVM, т.е. имена пакетов, разделенные точкой - 
		всего лишь условность. Во время выполнения есть лишь некая Unix-подобная файловая система. Но с этим вопросом я 
		не разбирался. Написал эту сноску просто так, на всякий случай.
		!!!!

		<h2>find...</h2>
		
		<p>
			Пусть мы знаем имя класса, например, ByteArrayOutputStream, но не знаем имя пакета, в котором он находится.
			То ли это <code>java.io</code>, то ли <code>java.nio</code>...
			Текстовый редактор нам не поможет (мы же договорились не использовать IDE). Остается только искать. Это просто:
<pre>
$ find src -name 'ByteArrayOutputStream.java'
</pre>

		<p>
			Другой пример. Пусть нас интересует содержимое некоторого пакета, но мы сами толком не знает, что ищем. В этом
			случае для "обзора" пакетов можно обойтись без утилит комадной строки. Лишь бы Bash (или другая горячо любимая оболочка)
			показвала содержимое каталога при нажатии <kbd>Tab</kbd>. Так можно путешествовать по дереву исходников, просматривать
			содержимое пакетов, возвращаться назад при необходимости (достаточно лишь стереть символы до последнего слэша).
				
		<h2>grep</h2>
		
		<p>
			Пусть мы знаем имя метода, но не знаем, в каком классе этот метод находится. Воспользуемся grep для получения
			подробной информации на примере метода :
<pre>
$ grep -R 'String substring(' src

src/java/lang/StringBuffer.java:    public synchronized String substring(int start) {
src/java/lang/StringBuffer.java:    public synchronized String substring(int start, int end) {
src/java/lang/String.java:    public String substring(int beginIndex) {
src/java/lang/String.java:    public String substring(int beginIndex, int endIndex) {
src/java/lang/AbstractStringBuilder.java:    public String substring(int start) {
src/java/lang/AbstractStringBuilder.java:    public String substring(int start, int end) {
src/java/net/URI.java:        private String substring(int start, int end) {
src/com/sun/org/apache/xerces/internal/impl/xpath/regex/REUtil.java:    static final String substring(CharacterIterator iterator, int begin, int end) {
src/com/sun/org/apache/regexp/internal/StringCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/StringCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/StreamCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/StreamCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/CharacterIterator.java:    String substring(int beginIndex, int endIndex);
src/com/sun/org/apache/regexp/internal/CharacterIterator.java:    String substring(int beginIndex);
src/com/sun/org/apache/regexp/internal/ReaderCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/ReaderCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/CharacterArrayCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/CharacterArrayCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/xml/internal/utils/XMLString.java:  public abstract XMLString substring(int beginIndex);
src/com/sun/org/apache/xml/internal/utils/XMLString.java:  public abstract XMLString substring(int beginIndex, int endIndex);
src/com/sun/org/apache/xml/internal/utils/XMLStringDefault.java:  public XMLString substring(int beginIndex)
src/com/sun/org/apache/xml/internal/utils/XMLStringDefault.java:  public XMLString substring(int beginIndex, int endIndex)
src/com/sun/org/apache/xpath/internal/objects/XString.java:  public XMLString substring(int beginIndex)
src/com/sun/org/apache/xpath/internal/objects/XString.java:  public XMLString substring(int beginIndex, int endIndex)
src/com/sun/org/apache/xpath/internal/objects/XStringForFSB.java:  public XMLString substring(int beginIndex)
src/com/sun/org/apache/xpath/internal/objects/XStringForFSB.java:  public XMLString substring(int beginIndex, int endIndex)
</pre>

		<p>
			Что ж, работает. Но мы видим слишком много мусора. Надо искать точнее. Это легко сделать, поскольку все исходные коды отформатированы 
			по одинаковым правилам. Так, мы знаем тип возвращаемого значения. После модификатора доступа 
			(или другого модификатора, такого как final, следуем пробел). Но если модификатор доступа package-private, то пробела перед типом возвращаемого 
			значения нет. На самом деле, он есть. Поскольку все методы, находящиеся в классе, начинаются с отступов. 
			Так что точный поиск метода может выглядеть так:
			
<pre>
yura@Desktop /usr/local/soft/jdk1.8.0_162 $ grep -R '[[:space:]]String substring(' src

src/java/lang/StringBuffer.java:    public synchronized String substring(int start) {
src/java/lang/StringBuffer.java:    public synchronized String substring(int start, int end) {
src/java/lang/String.java:    public String substring(int beginIndex) {
src/java/lang/String.java:    public String substring(int beginIndex, int endIndex) {
src/java/lang/AbstractStringBuilder.java:    public String substring(int start) {
src/java/lang/AbstractStringBuilder.java:    public String substring(int start, int end) {
src/java/net/URI.java:        private String substring(int start, int end) {
src/com/sun/org/apache/xerces/internal/impl/xpath/regex/REUtil.java:    static final String substring(CharacterIterator iterator, int begin, int end) {
src/com/sun/org/apache/regexp/internal/StringCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/StringCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/StreamCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/StreamCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/CharacterIterator.java:    String substring(int beginIndex, int endIndex);
src/com/sun/org/apache/regexp/internal/CharacterIterator.java:    String substring(int beginIndex);
src/com/sun/org/apache/regexp/internal/ReaderCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/ReaderCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/CharacterArrayCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/CharacterArrayCharacterIterator.java:    public String substring(int beginIndex)	
</pre>
		
		<p>
			Конечно, этот способо не всегда сработает. Сопоставление осуществляется только по именам. 
			Никто не запрещает определить собственный класс с именем <em>String</em>. 
			Да-да, приведенный ниже пример компилируется и работает:
<pre>
public class StringStringTest {
	public static void main(String[] args) { 
		new Runnable() {
			class String {}

			public String substring() { 
				return null; 
			}
			
			@Override
			public void run() {}
		};
	}
}
</pre>		
		
		<p>
			Поиск в таком классе приведет нас к совершенно нерелевантному методу <code>substring()</code>:
<pre>
$ grep -R '[[:space:]]String substring(' StringStringTest.java 

			public String substring() { 
</pre>
	
		<p>
			Теперь предположим, что нам нужно получить JavaDoc по некоторому классу с известным именем 
			(часть JavaDoc'а опущена ради экономии места): 
		
<pre>
$ grep -B 999 'class String' src/java/lang/String.java | grep -A 999 '/\*\*'

/**
 * The {@code String} class represents character strings. All
 * string literals in Java programs, such as {@code "abc"}, are
 * implemented as instances of this class.
 * <p>
 * Strings are constant; their values cannot be changed after they
...
 *
 * @author  Lee Boynton
 * @author  Arthur van Hoff
 * @author  Martin Buchholz
 * @author  Ulf Zibis
 * @see     java.lang.Object#toString()
 * @see     java.lang.StringBuffer
 * @see     java.lang.StringBuilder
 * @see     java.nio.charset.Charset
 * @since   JDK1.0
 */

public final class String
</pre>
	
		<p>
			<i>999</i> - всего лишь ограничители на максимальное количество строк. Вряд ли JavaDoc содержит большее 999
			строчек для одного класса.
		
		<h2>Парочка приколов напоследок</h2>
		
		<p>
			Поимщем интересные (т.е. ругательные) слова в исходниках JDK (выведем по две строчки до и после совпадения, 
			чтобы понимать контекст, в котором употребляется ругательство. 
			А то <i>scraping</i>, вполне приличное слово, путается под ногами):
<pre>
$ grep -C 2 -i -R 'crap' src

src/javax/xml/bind/DatatypeConverterImpl.java-            // uri can never be null according to javadoc,
src/javax/xml/bind/DatatypeConverterImpl.java-            // but some users reported that there are implementations that return null.
src/javax/xml/bind/DatatypeConverterImpl.java:            if (uri == null || uri.length() == 0) // crap. the NamespaceContext interface is broken.
src/javax/xml/bind/DatatypeConverterImpl.java-            // error: unbound prefix
src/javax/xml/bind/DatatypeConverterImpl.java-            {
</pre>			

		<p>
			<cite>the NamespaceContext interface is broken.</cite> Ничего не поделаешь :)

		<p></p>
			
<pre>
$ grep -C 2 -i -R 'fuck' src

src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java-     * current position is cached in the following 4 variables and will
src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java-     * help speed up a sequence of next() call in an index iterator. This
src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java:     * method is a mess, but it is fast and it works, so don't fuck with it.
src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java-     */
src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java-    private int _pos = Integer.MAX_VALUE;
</pre>		







-----------------

-----------------

		<p>
			В одной из своих предыдущих ламерских статей 
			(<a href="http://flaz14.github.io/java-8-whats-new/java-8-whats-new-part-3.html">Новое, клёвое и хреновое в 
			Java 8. Часть 3. Лямбда-выражения</a>) я коснулся темы стэктрэйсов. Чтение стэка вызовов - это, пожалуй, 
			основное занятие Java-разработчика. Порой оно отнимает времени больше, чем чтение собственно исходного кода 
			и документации (особенно, если код запускается под управлением очередной версии новороченного фреймворка). 
			Так что красота стэктрэйсов - залог успеха.
			
		<p>
			Как уже было сказано, лямбда-выражения не во всем повторяют анонимные внутренние классы. Рассмотрим простой 
			пример вызова лямбда-функций из разных мест программы. В <a href="#listing-1">листинге 1</a> я пронумеровал 
			строки для ясности. Ах да, сопоставление строк из стэка вызовов со строками исходного кода - самая 
			"приятная" часть в деле разгребания логов.

<h4 id="listing-1">Листинг 1 - примеры вызовов лямбда-выражений</h4>
<pre>
     1	public class TestLambdaStacktraces {
     2		public static void main(String ignored[]) {
     3			final SampleClass sampleObject = new SampleClass();
     4			sampleObject.someInstanceMethod();
     5			
     6			System.out.println("---   Inside main method of the application - instanceFieldLambda      ----");
     7			sampleObject.instanceFieldLambda.print();
     8			System.out.println("---------------------------------------------------------------------------");
     9			
    10			System.out.println("---   Inside main method of the application - staticFieldLambda        ----");		
    11			sampleObject.staticFieldLambda.print();
    12			System.out.println("---------------------------------------------------------------------------");
    13			
    14			System.out.println("---   Inside main method of the application - localVariableLambda      ----");
    15			final StackTracePrinter localVariableLambda = () -&gt; {
    16				StackTracePrinter.printNicely();
    17			};
    18			localVariableLambda.print();
    19			System.out.println("---------------------------------------------------------------------------");
    20		}
    21	}
    22	
    23	class SampleClass {
    24		public final StackTracePrinter instanceFieldLambda = () -&gt; {
    25			StackTracePrinter.printNicely();
    26		};
    27		
    28		public static final StackTracePrinter staticFieldLambda = () -&gt; {
    29			StackTracePrinter.printNicely();
    30		};
    31		
    32		public SampleClass() {
    33			System.out.println("---   Inside constructor of the enclosing class - instanceFieldLambda   ---");
    34			instanceFieldLambda.print();
    35			System.out.println("---------------------------------------------------------------------------");
    36			
    37			System.out.println("---   Inside constructor of the enclosing class - staticFieldLambda     ---");
    38			staticFieldLambda.print();
    39			System.out.println("---------------------------------------------------------------------------");
    40			
    41			System.out.println("---   Inside constructor of the enclosing class - localVariableLambda   ---");
    42			final StackTracePrinter localVariableLambda = () -&gt; { 
    43				StackTracePrinter.printNicely();
    44			};
    45			localVariableLambda.print();
    46			System.out.println("---------------------------------------------------------------------------");
    47		}
    48		
    49		public void someInstanceMethod() {
    50			System.out.println("---   Inside instance method of the enclosing class - instanceFieldLambda -");
    51			instanceFieldLambda.print();
    52			System.out.println("---------------------------------------------------------------------------");
    53			
    54			System.out.println("---   Inside instance method of the enclosing class - staticFieldLambda ---");
    55			staticFieldLambda.print();
    56			System.out.println("---------------------------------------------------------------------------");
    57			
    58			System.out.println("---   Inside instance method of the enclosing class - localVariableLambda -");
    59			final StackTracePrinter localVariableLambda = () -&gt; { 
    60				StackTracePrinter.printNicely();
    61			};
    62			localVariableLambda.print();
    63			System.out.println("---------------------------------------------------------------------------");
    64		}
    65		
    66		public static void someStaticMethod() {
    67			System.out.println("---   Inside static method of the enclosing class - staticFieldLambda   ---");
    68			staticFieldLambda.print();
    69			System.out.println("---------------------------------------------------------------------------");
    70			
    71			System.out.println("---   Inside static method of the enclosing class - localVariableLambda ---");
    72			final StackTracePrinter localVariableLambda = () -&gt; { 
    73				StackTracePrinter.printNicely();
    74			};
    75			localVariableLambda.print();
    76			System.out.println("---------------------------------------------------------------------------");	
    77		}
    78	}
    79	
    80	@FunctionalInterface
    81	interface StackTracePrinter {
    82		void print();
    83		
    84		static void printNicely() {
    85			final StackTraceElement[] stacktrace = Thread.currentThread().getStackTrace();
    86			java.util.stream.Stream.
    87				of(stacktrace).
    88				forEach(System.out::println);
    89		}
    90	}
</pre>
			
		<p>
			Запустим программу и получим распечатку стэка вызовов.
			
<h4 id="listing-2">Листинг 2 - распечатка стэка вызовов</h4>
<pre>
---   Inside constructor of the enclosing class - instanceFieldLambda   ---
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$new$0(TestLambdaStacktraces.java:25)
SampleClass.&lt;init&gt;(TestLambdaStacktraces.java:34)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:3)
---------------------------------------------------------------------------
---   Inside constructor of the enclosing class - staticFieldLambda     ---
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$static$1(TestLambdaStacktraces.java:29)
SampleClass.&lt;init&gt;(TestLambdaStacktraces.java:38)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:3)
---------------------------------------------------------------------------
---   Inside constructor of the enclosing class - localVariableLambda   ---
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$new$2(TestLambdaStacktraces.java:43)
SampleClass.&lt;init&gt;(TestLambdaStacktraces.java:45)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:3)
---------------------------------------------------------------------------
---   Inside instance method of the enclosing class - instanceFieldLambda -
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$new$0(TestLambdaStacktraces.java:25)
SampleClass.someInstanceMethod(TestLambdaStacktraces.java:51)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:4)
---------------------------------------------------------------------------
---   Inside instance method of the enclosing class - staticFieldLambda ---
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$static$1(TestLambdaStacktraces.java:29)
SampleClass.someInstanceMethod(TestLambdaStacktraces.java:55)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:4)
---------------------------------------------------------------------------
---   Inside instance method of the enclosing class - localVariableLambda -
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$someInstanceMethod$3(TestLambdaStacktraces.java:60)
SampleClass.someInstanceMethod(TestLambdaStacktraces.java:62)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:4)
---------------------------------------------------------------------------
---   Inside main method of the application - instanceFieldLambda      ----
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$new$0(TestLambdaStacktraces.java:25)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:7)
---------------------------------------------------------------------------
---   Inside main method of the application - staticFieldLambda        ----
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$static$1(TestLambdaStacktraces.java:29)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:11)
---------------------------------------------------------------------------
---   Inside main method of the application - localVariableLambda      ----
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
TestLambdaStacktraces.lambda$main$0(TestLambdaStacktraces.java:16)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:18)
---------------------------------------------------------------------------
</pre>

		<h2 id="Inside_constructor_of_the_enclosing_class_-_instanceFieldLambda">
			Вызов лямбда-выражения из конструктора класса через поле класса
		</h2>
		
		<p>
<pre>			
---   Inside constructor of the enclosing class - instanceFieldLambda   ---
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$new$0(TestLambdaStacktraces.java:25)
SampleClass.&lt;init&gt;(TestLambdaStacktraces.java:34)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:3)
---------------------------------------------------------------------------
</pre>

		<p>
			Первым делом вызывается конструктор класса. В стэке вызовов он выглядит как 
			<strong>ИмяКласса.&lt;init&gt;</strong>. Далее, в строке 25 выполняется собственно тело лямбда-выражения. 
			Как видим, лямбда-выражению соответствует в стэктрэйсе (кроме привычного <em>lambda</em>) слово 
			<strong>new</strong>. <code>new</code> в данном случае означает, что лямбда-выражение было определено либо 
			непосредственно в конструкторе, либо в блоке инициализации, либо в месте определения поля. А циферка 
			<strong>0</strong>, как всегда, играет роль счетчика.
		
		<h2>Вызов лямбда-выражения из конструктора класса через статическое поле</h2>

		<p>
			Этот случай ничем не отличается от предыдущего.
<pre>
---   Inside constructor of the enclosing class - staticFieldLambda     ---
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$static$1(TestLambdaStacktraces.java:29)
SampleClass.&lt;init&gt;(TestLambdaStacktraces.java:38)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:3)
---------------------------------------------------------------------------
</pre>
			
		<p>
			Вместо <code>new</code> мы видим слово <strong>static</strong>. Т.е. вместо
<pre>
SampleClass.lambda$new$...
</pre>

		<p>
			получаем
<pre>
SampleClass.lambda$static$...
</pre>

		<p>
			Слово <code>static</code> в стэктрэйсе означает, что лямбда-выражение было определено как статическая
			переменная или в статическом блоке.
			
		<h2>Вызов лямбда-выражения из конструктора класса через локальную переменную</h2>
		
		<p>
			Стэктрэйс не отличается от 
			<a href="#Inside_constructor_of_the_enclosing_class_-_instanceFieldLambda">рассмотренного ранее</a>. 
			Только номера строк и значения счетчика разные:
<pre>
---   Inside constructor of the enclosing class - localVariableLambda   ---
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$new$2(TestLambdaStacktraces.java:43)
SampleClass.&lt;init&gt;(TestLambdaStacktraces.java:45)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:3)
---------------------------------------------------------------------------
</pre>

		<h2>Вызов лямбда-выражения из метода класса через поле</h2>

		<p>
			Здесь все то же самое, что и в случае с конструктором. Только вместо <code>SampleClass.&lt;init&gt;</code> 
			мы видим метод экземляра: <code>SampleClass.someInstanceMethod</code>.
<pre>
---   Inside instance method of the enclosing class - instanceFieldLambda -
java.lang.Thread.getStackTrace(Thread.java:1556)
StackTracePrinter.printNicely(TestLambdaStacktraces.java:85)
SampleClass.lambda$new$0(TestLambdaStacktraces.java:25)
SampleClass.someInstanceMethod(TestLambdaStacktraces.java:51)
TestLambdaStacktraces.main(TestLambdaStacktraces.java:4)
---------------------------------------------------------------------------
</pre>


		<h2>Заключение</h2>
		
		<p>
			Не будем рассматривать оставшиеся случаи. Беглого взгляда на них достаточно, чтобы понять, что вызов 
			лямбда-выражения порождает в стэктрэйсе не только номер строки исходного кода, но и вспомогательное слово, 
			если так можно выразиться. Это вспомогательное слово дает дополнительную информацию о происхождении
			лямбда-выражения, что несколько повышает эффективность поиска ошибки. Неважно, где лямбда-выражение было 
			использовано (в конце концов, ссылки значений не содержат, только "адреса"). Важно то место, в котором оно 
			было определено. 
			
		<p>
			Правила таковы:
			
			<ol>
				<li>
					Если лямбда-выражение было определено как поле экземпляра класса или в блоке инициализации или как 
					локальная переменная в конструкторе, то в стэктрэйс добавится вспомогательное слово 
					<strong>new</strong>.
				
				<li>
					Если лямбда-выражение было определено как статическое поле класса или в статическом блоке 
					инициализации, то в стэктрэйс добавится слово <strong>static</strong>.
				
				<li>
					В остальных случаях в качестве вспомогательного слова будет взято имя метода, в котором было 
					определено лямбда-выражение. Например, если лямбда-выражение было определено в методе 
					<code>main()</code>	класса <code>TestLambdaStacktraces</code>, то в стэктрэйсе мы увидим 
					<code>TestLambdaStacktraces.lambda$main$...</code>. Если же выражение было определено в методе
					<code>someInstanceMethod</code> класса <code>SampleClass</code>, то в стэке вызовов это породит 
					строчку	<code>SampleClass.lambda$someInstanceMethod$...</code>
			</ol>
			
		<p>
			Все!
		
		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>
