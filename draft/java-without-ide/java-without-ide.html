<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Как начать программировать на Java без использования IDE</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#java-without-ide" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-without-ide/java-without-ide.html">
				Как начать программировать на Java без использования IDE
			</a>
		</h1>
		
		<h3>[2018, Май]</h3>
		
		<h2>Введение</h2>
		
		<p>
			В этой статье не пойдет речь о том, что IDE - это плохо, и что нужно отказаться от помощи сред разработки.
			И ничего не будет сказано, как сделать свою IDE, например, нашпиговать Vim плагинами. И дело не только в том, 
			что автор не знаком с Vim на достаточном для серьезного редактирования текста, а стало быть, и написания кода, 
			уровне ("ключевое" время в жизни, т.е. время привыкания, прошло под знаменем Turbo Pascal
			и MS-DOS). Просто настройка текстового редактора "под себя" - это создание все той же среды разработки. Что
			не приносит ничего нового. Попробуем же обратиться к истокам - командной строке и соответствующим утилитам.
			
		<h2>Версия JDK</h2>
		
		<p>
			В качестве примера возьмем Java 8 от компании Oracle:
<pre>
$ java -version

java version "1.8.0_162"
Java(TM) SE Runtime Environment (build 1.8.0_162-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.162-b12, mixed mode)
</pre>

		<p>
			В Java 9 структура каталогов JDK другая, лень с ней разбираться. Да и зачем все эти новые технологии? Еще восьмую 
			версию не полностью исследовали.
		
		<h2>Установка JDK</h2>
		
		<p>
			В ламерской заметке 
			(<a href="http://flaz14.github.io/once-again-about-jdk-installation/once-again-about-jdk-installation.html">
			Еще раз об установке JDK</a>) вскользь упоминалось о важности присутствия исходных текстов в каталоге с 
			собственно JDK. 
			
			Программы не стоит устанавливать в домашний каталог. Конечно, для тех из них, которые обновляются автоматически
			в обход системы управления пакетами, иного выбора нет. В случае же с JDK автоматическое обновление не представляет
			затруднений, потому что его просто нет. Да и нет смысла перезатирать предыдущую версию. Мало ли, понадобиться
			запустить что-нибудь на конкретной версии. Тем более, что даже в распакованном виде JDK занимает сравнительно
			немного места. Так, версия JDK, упомянутая в предыдущем абзаце, в распакованном виде занимает на диске
			всего лишь 472 Мегабайт, что даже меньше, чем объем оперативной памяти, потребляемой современные 
			прикладными программами (привет, новый Skype for Linux).
			
			Так вот, установка программ куда-нибудь в /opt в первую очередь, более безопасна: никто, кроме root, не сможет
			подменить исполняемый файл программы. Хотя это и не нужно на самом деле: тот, кто может выполнять команды
			от имени обычного пользователя, без труда получит права root, достаточно лишь подсунуть настоящему пользователю
			свою версию sudo. В общем, совсем не трудно замутить что-нибудь эдакое.
			
			Стоит в большей степени опасаться неумышленного повреждения файлов установленной программы законным пользователем.
			
		<p>
			Пусть мы распаковали дистрибутив JDK в каталог <i>/usr/local/soft</i>. В комплект поставки JDK входят исходные
			тексты, они хранятся в файле src.zip. Создадим директорию с именем <i>src</i> и распакуем в нее архив.
			Каталоги выглядят следующим образом:
<pre>
$ ls -l

total 25940
drwxr-xr-x 2 root root     4096 Dec 20 08:24 bin
-r--r--r-- 1 root root     3244 Dec 20 08:24 COPYRIGHT
drwxr-xr-x 4 root root     4096 Dec 20 08:24 db
drwxr-xr-x 3 root root     4096 Dec 20 08:24 include
-rw-r--r-- 1 root root  5203041 Dec 20 01:57 javafx-src.zip
drwxr-xr-x 5 root root     4096 Dec 20 08:24 jre
drwxr-xr-x 5 root root     4096 Dec 20 08:24 lib
-r--r--r-- 1 root root       40 Dec 20 08:24 LICENSE
drwxr-xr-x 4 root root     4096 Dec 20 08:24 man
-r--r--r-- 1 root root      159 Dec 20 08:24 README.html
-rw-r--r-- 1 root root      424 Dec 20 08:24 release
drwxr-xr-x 7 root root     4096 Apr 17 17:47 src
-rw-r--r-- 1 root root 21096465 Dec 20 08:24 src.zip
-rw-r--r-- 1 root root    63933 Dec 20 01:57 THIRDPARTYLICENSEREADME-JAVAFX.txt
-r--r--r-- 1 root root   145180 Dec 20 08:24 THIRDPARTYLICENSEREADME.txt
</pre>			

			Теперь у нас есть исходные тексты в удобном для обозревания и чтения виде:
<pre>
$ tree src

src
├── com
│   └── sun
│       ├── corba
...
│       ├── image
│       │   └── codec
│       │       └── jpeg
│       │           ├── ImageFormatException.java
│       │           ├── JPEGCodec.java
│       │           ├── JPEGDecodeParam.java
│       │           ├── JPEGEncodeParam.java
│       │           ├── JPEGHuffmanTable.java
│       │           ├── JPEGImageDecoder.java
│       │           ├── JPEGImageEncoder.java
│       │           ├── JPEGQTable.java
│       │           └── TruncatedFileException.java
│       ├── imageio
│       │   ├── plugins
...
│       ├── java
│       │   └── swing
...
│   ├── io
│   │   ├── Bits.java
│   │   ├── BufferedInputStream.java
│   │   ├── BufferedOutputStream.java
│   │   ├── BufferedReader.java
│   │   ├── BufferedWriter.java
...
│   ├── lang
│   │   ├── AbstractMethodError.java
│   │   ├── AbstractStringBuilder.java
│   │   ├── annotation
│   │   │   ├── AnnotationFormatError.java
│   │   │   ├── Annotation.java
│   │   │   ├── AnnotationTypeMismatchException.java
│   │   │   ├── Documented.java
│   │   │   ├── ElementType.java
...

487 directories, 7729 files
</pre>		

		<h2>И что же делать с исходниками?</h2>
		
		<p>
			Ответ прост: читать :) Поскольку обычные пользователи имеют право только читать содержимое установленного 
			нами JDK (а именно этого мы и добивались в предыдущем абзаце), можно смело открывать исходники в любимом текстовом
			редакторе, и, наслаждаясь подсветкой синтаксиса, неспешно читать их. Можно даже "редактировать" их, делать пометки,
			стирать ненужное (естественно, изменения сохранены не будут) и т.д. А поскольку файлы .java разложены в строгом
			соответствии со структурой пакетов, то посмотреть исходный код класса, например, Integer совсем несложно будет
<pre>
$ less java/lang/Integer.java
</pre>

		!!!!
		Сноска: именно так, т.е. через <code>/</code> и ссылается на классы JVM, т.е. имена пакетов, разделенные точкой - 
		всего лишь условность. Во время выполнения есть лишь некая Unix-подобная файловая система. Но с этим вопросом я 
		не разбирался. Написал эту сноску просто так, на всякий случай.
		!!!!

		<h2>find...</h2>
		
		<p>
			Пусть мы знаем имя класса, например, ByteArrayOutputStream, но не знаем имя пакета, в котором он находится.
			То ли это <code>java.io</code>, то ли <code>java.nio</code>...
			Текстовый редактор нам не поможет (мы же договорились не использовать IDE). Остается только искать. Это просто:
<pre>
$ find src -name 'ByteArrayOutputStream.java'
</pre>

		<p>
			Другой пример. Пусть нас интересует содержимое некоторого пакета, но мы сами толком не знает, что ищем. В этом
			случае для "обзора" пакетов можно обойтись без утилит комадной строки. Лишь бы Bash (или другая горячо любимая оболочка)
			показвала содержимое каталога при нажатии <kbd>Tab</kbd>. Так можно путешествовать по дереву исходников, просматривать
			содержимое пакетов, возвращаться назад при необходимости (достаточно лишь стереть символы до последнего слэша).
				
		<h2>grep</h2>
		
		<p>
			Пусть мы знаем имя метода, но не знаем, в каком классе этот метод находится. Воспользуемся grep для получения
			подробной информации на примере метода :
<pre>
$ grep -R 'String substring(' src

src/java/lang/StringBuffer.java:    public synchronized String substring(int start) {
src/java/lang/StringBuffer.java:    public synchronized String substring(int start, int end) {
src/java/lang/String.java:    public String substring(int beginIndex) {
src/java/lang/String.java:    public String substring(int beginIndex, int endIndex) {
src/java/lang/AbstractStringBuilder.java:    public String substring(int start) {
src/java/lang/AbstractStringBuilder.java:    public String substring(int start, int end) {
src/java/net/URI.java:        private String substring(int start, int end) {
src/com/sun/org/apache/xerces/internal/impl/xpath/regex/REUtil.java:    static final String substring(CharacterIterator iterator, int begin, int end) {
src/com/sun/org/apache/regexp/internal/StringCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/StringCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/StreamCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/StreamCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/CharacterIterator.java:    String substring(int beginIndex, int endIndex);
src/com/sun/org/apache/regexp/internal/CharacterIterator.java:    String substring(int beginIndex);
src/com/sun/org/apache/regexp/internal/ReaderCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/ReaderCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/CharacterArrayCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/CharacterArrayCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/xml/internal/utils/XMLString.java:  public abstract XMLString substring(int beginIndex);
src/com/sun/org/apache/xml/internal/utils/XMLString.java:  public abstract XMLString substring(int beginIndex, int endIndex);
src/com/sun/org/apache/xml/internal/utils/XMLStringDefault.java:  public XMLString substring(int beginIndex)
src/com/sun/org/apache/xml/internal/utils/XMLStringDefault.java:  public XMLString substring(int beginIndex, int endIndex)
src/com/sun/org/apache/xpath/internal/objects/XString.java:  public XMLString substring(int beginIndex)
src/com/sun/org/apache/xpath/internal/objects/XString.java:  public XMLString substring(int beginIndex, int endIndex)
src/com/sun/org/apache/xpath/internal/objects/XStringForFSB.java:  public XMLString substring(int beginIndex)
src/com/sun/org/apache/xpath/internal/objects/XStringForFSB.java:  public XMLString substring(int beginIndex, int endIndex)
</pre>

		<p>
			Что ж, работает. Но мы видим слишком много мусора. Надо искать точнее. Это легко сделать, поскольку все исходные коды отформатированы 
			по одинаковым правилам. Так, мы знаем тип возвращаемого значения. После модификатора доступа 
			(или другого модификатора, такого как final, следуем пробел). Но если модификатор доступа package-private, то пробела перед типом возвращаемого 
			значения нет. На самом деле, он есть. Поскольку все методы, находящиеся в классе, начинаются с отступов. 
			Так что точный поиск метода может выглядеть так:
			
<pre>
yura@Desktop /usr/local/soft/jdk1.8.0_162 $ grep -R '[[:space:]]String substring(' src

src/java/lang/StringBuffer.java:    public synchronized String substring(int start) {
src/java/lang/StringBuffer.java:    public synchronized String substring(int start, int end) {
src/java/lang/String.java:    public String substring(int beginIndex) {
src/java/lang/String.java:    public String substring(int beginIndex, int endIndex) {
src/java/lang/AbstractStringBuilder.java:    public String substring(int start) {
src/java/lang/AbstractStringBuilder.java:    public String substring(int start, int end) {
src/java/net/URI.java:        private String substring(int start, int end) {
src/com/sun/org/apache/xerces/internal/impl/xpath/regex/REUtil.java:    static final String substring(CharacterIterator iterator, int begin, int end) {
src/com/sun/org/apache/regexp/internal/StringCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/StringCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/StreamCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/StreamCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/CharacterIterator.java:    String substring(int beginIndex, int endIndex);
src/com/sun/org/apache/regexp/internal/CharacterIterator.java:    String substring(int beginIndex);
src/com/sun/org/apache/regexp/internal/ReaderCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/ReaderCharacterIterator.java:    public String substring(int beginIndex)
src/com/sun/org/apache/regexp/internal/CharacterArrayCharacterIterator.java:    public String substring(int beginIndex, int endIndex)
src/com/sun/org/apache/regexp/internal/CharacterArrayCharacterIterator.java:    public String substring(int beginIndex)	
</pre>
		
		<p>
			Конечно, этот способо не всегда сработает. Сопоставление осуществляется только по именам. 
			Никто не запрещает определить собственный класс с именем <em>String</em>. 
			Да-да, приведенный ниже пример компилируется и работает:
<pre>
public class StringStringTest {
	public static void main(String[] args) { 
		new Runnable() {
			class String {}

			public String substring() { 
				return null; 
			}
			
			@Override
			public void run() {}
		};
	}
}
</pre>		
		
		<p>
			Поиск в таком классе приведет нас к совершенно нерелевантному методу <code>substring()</code>:
<pre>
$ grep -R '[[:space:]]String substring(' StringStringTest.java 

			public String substring() { 
</pre>
	
		<p>
			Теперь предположим, что нам нужно получить JavaDoc по некоторому классу с известным именем 
			(часть JavaDoc'а опущена ради экономии места): 
		
<pre>
$ grep -B 999 'class String' src/java/lang/String.java | grep -A 999 '/\*\*'

/**
 * The {@code String} class represents character strings. All
 * string literals in Java programs, such as {@code "abc"}, are
 * implemented as instances of this class.
 * <p>
 * Strings are constant; their values cannot be changed after they
...
 *
 * @author  Lee Boynton
 * @author  Arthur van Hoff
 * @author  Martin Buchholz
 * @author  Ulf Zibis
 * @see     java.lang.Object#toString()
 * @see     java.lang.StringBuffer
 * @see     java.lang.StringBuilder
 * @see     java.nio.charset.Charset
 * @since   JDK1.0
 */

public final class String
</pre>
	
		<p>
			<i>999</i> - всего лишь ограничители на максимальное количество строк. Вряд ли JavaDoc содержит большее 999
			строчек для одного класса.
		
		<h2>Парочка приколов напоследок</h2>
		
		<p>
			Поимщем интересные (т.е. ругательные) слова в исходниках JDK (выведем по две строчки до и после совпадения, 
			чтобы понимать контекст, в котором употребляется ругательство, и не путать его с обычыми словами. 
			А то <i>scraping</i>, вполне приличное слово, путается под ногами):
<pre>
$ grep -C 2 -i -R 'crap' src

src/javax/xml/bind/DatatypeConverterImpl.java-            // uri can never be null according to javadoc,
src/javax/xml/bind/DatatypeConverterImpl.java-            // but some users reported that there are implementations that return null.
src/javax/xml/bind/DatatypeConverterImpl.java:            if (uri == null || uri.length() == 0) // crap. the NamespaceContext interface is broken.
src/javax/xml/bind/DatatypeConverterImpl.java-            // error: unbound prefix
src/javax/xml/bind/DatatypeConverterImpl.java-            {
</pre>			

		<p>
			<cite>crap. the NamespaceContext interface is broken.</cite>  :)

<pre>
$ grep -C 2 -i -R 'fuck' src

src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java-     * current position is cached in the following 4 variables and will
src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java-     * help speed up a sequence of next() call in an index iterator. This
src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java:     * method is a mess, but it is fast and it works, so don't fuck with it.
src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java-     */
src/com/sun/org/apache/xalan/internal/xsltc/dom/BitArray.java-    private int _pos = Integer.MAX_VALUE;
</pre>
	
		<p>
			<cite>it is fast and it works, so don't fuck with it</cite> :D

		<h2>Заключение</h2>
		
		<p>
			Конечно, программировать без IDE на реальном проекте невозможно. Но главное - это начать. Совсем по-другому
			себя чувствуешь, когда знаешь, что ответы на основные вопросы всегда есть под рукой, не нужно лезть в Интернет.
			Имена классов и соответствующих им пакетов запоминаются сами собой, выстраиваются в некую целостную систему.
			Не то что обрывки листингов, которые напрашиваются на copy-and-paste.
		
		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>
