<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Фигурные скобки - не проклятие</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#curly-braces-are-not-damnation" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/curly-braces-are-not-damnation/curly-braces-are-not-damnation.html">
				Фигурные скобки - не проклятие
			</a>
		</h1>
		
		<h3>[2018, Февраль]</h3>

		<h2>Начало</h2>

		<p>
			Недавно я прочитал статью <a href="https://habrahabr.ru/post/258391/">«Проклятие» фигурных скобочек</a> и 
			комментарии к ней. Обсуждение там развернулось нешуточное. Я надеялся найти мнение, созвучное с моими 
			собственными ламерскими измышлениями, но тщетно. Поэтом и написал эту статью.
			
		<p>
			Опыта работы с Oberon у меня нет. И с Rust тоже. Я знаю только Pascal, да и то лишь из школы и университета.
			
		<h2>Маленькое отступление насчет скобочек</h2>

		<p>
			Я видел отрывки кода на Rust, Ruby, Perl, PHP. Что мне не понравилось в этих языках, так это засилье всяких
			закорочек, таких как <code>=></code>, <code>$</code>, <code>::</code>, <code>||</code> и т.п. По-моему, 
			обилие такого рода лексем ухудшает читаемость кода. Но восприятие исходников - понятие субъективное. Кому-то
			больше по душе закорючки, кому-то - обычные английские слова (в этом смысле очень хорош Python, заковыристых
			операторов там совсем немного). Объективно то, что обычные слова (хоть они и занимают больше знакомест на
			экране) проще печатать: не нужно нажимать <kbd>Shift</kbd> и лезть в дальние углы клавиатуры (хотя 
			прагматичные раскладки вроде Dvorak и Colemak смягчают эту проблему). Да и "грепнуть" исходник, написанный
			словами, проще, чем специальными знаками.
		
		<h2>Области видимости - вот истинное проклятие C-подобных языков</h2>

		<p>
			Нет, в самих областях видимости (равно как и в пространствах имен), нет ничего плохого. Но в C-подобных 
			языках (по стечению обстоятельств в них как раз используются фигурные скобочки) области видимости возведены
			в абсолют. Из-за перебора с этой концепцией страдает язык в целом.
		
		<p>
			Чтобы было понятнее, попробуем зайти издалека. Люди всегда стремились к чему-то совершенному. В мире физики,
			к примеру, обожествлена сфера как идеальное вместилище материи. В прошлом-позапрошлом веке атом был загадкой.
			Но к настоящему моменту наука и способы постановки экспериментов значительно продвинулись. Тем не менее, 
			сегодня атомы и элементарные частицы 
			изображают именно в виде шариков. Просто никто (за редким исключением
			!!!тут будет ссылка на книгу Паленко!!!) в наши дни не смеет покушаться на несовершенство кирпичиков мироздания
			и придавать им некрасивые формы.
		
		<p>
			Еще один пример из мира физики - Теории Великого Объединения. Но почему в природе должен быть только один 
			вид взаимодействия материи? Чем числа 2 или 3 или N хуже, чем единица? Ничем, просто человеку хочется 
			идеального !!! будет ссылка на главу из книги Computer viruses, artificial life and evolution)!!!
			
		<p>
			Вообще, аналогия - вещь ненадежная. А годится она только для того, чтобы запудрить оппоненту мозги и доказать 
			свою бредовую версию. Но что-то в ней есть. Ибо аналогичная ситуация наблюдается в языках программирования.

		<p>
			В C-подобных языках проявляется непрестанное стремление к минимизации области видимости переменных. 
			Переменная должна быть объявлена как можно ближе к месту ее непосредственного использования (заодно можно
			сразу объявить и инициализировать переменную, присвоив ей значение в той же строчке исходника). 
			Обоснований такого подхода можно выдвинуть несколько:
			<ul>
				<li>
					Переменную нельзя будет по ошибке использовать за пределами ее "родного" блока.
					
				<li>
					В разных подблоках в пределах одного блока можно называть переменные одинаково, и они не будут 
					пересекаться.
				
				<li>
					Блок с локальными по отношению к нему переменными проще вынести в отдельный метод.
					
				<li>
					и т.д.
			</ul>

		<p>
			Все эти доводы верные. Но у каждой медали есть обратная сторона. Посмотрим, почему же минимизация области
			видимости приносит больше вреда, чем пользы (с поправкой на наши дни, естественно).
		
		<h2></h2>
		
		<p>
			В конце 70-x - начале 80-ых ЯП высокого уровня только начинали входить в моду. Мало кто тогда имел богатый
			опыт разработки на такого рода языках. Коллективы программистов были относительно небольшие. Отдельно взятый
			разработчик чувствовал себя едва лишь не владыкой Вселенной. Ведь коммуникации и популярных нынче Code Review
			в те времена не было и в помине. Следовательно, обмен опытом происходил с черепашьей (по сегодняшним меркам)
			скоростью.
		
		<p>
			Clean Code того времени - это функции-простыни на 100 строчек и больше. Даже в конце 90-ых это считалось
			нормой. Для примера посмотрим на исходный текст модуля Linux PAM (релиз Linux-PAM-1.3.0). 
			Я специально взял модуль <em>pam_userdb</em>. Он не обновлялся с середины 90-ых годов, так что вполне отражает
			дух прошлого.
			
		<p>
			Рассмотрим процедуру 
<a href="https://github.com/linux-pam/linux-pam/blob/1cad9fb2a0d729c5b5e5aa7297c521df7d5a2d33/modules/pam_userdb/pam_userdb.c#L151">
user_lookup()</a> (номера строк я поставил, чтобы добавить драматизма). 
			Ее начало и конец приведены в <a href="#listing-1">листинге 1</a>. А всего она занимает 182 строки исходного кода! Да, следует
			сделать скидку на имеющие в процедуре макросы для условной компиляции, а также на форматирование (например, 
			сигнатура расположена на трех строках из соображений удобочитамости). Фрагменты, снабженные
			комментариями вроде <cite>/* dump out the database contents for debugging */</cite>, так и просятся быть
			вынесенными в отдельную процедуру. Но нет, все слеплено вместе.

<h4 id="listing-1">Листинг 1 - фрагмент процедуры user_lookup() из Linux PAM</h4>
<pre>
   151	static int
   152	user_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,
   153		     const char *user, const char *pass, int ctrl)
   154	{
   155	    DBM *dbm;
   156	    datum key, data;
   157	
   158	    /* Open the DB file. */
   159	    dbm = dbm_open(database, O_RDONLY, 0644);
   160	    if (dbm == NULL) {
   161		pam_syslog(pamh, LOG_ERR,
   162			   "user_lookup: could not open database `%s': %m", database);
   163		return -2;
   164	    }

   ...

   325		if (saw_user)
   326		    return -1; /* saw the user, but password mismatch */
   327		else
   328		    return 1; /* not found */
   329	    }
   330	
   331	    /* NOT REACHED */
   332	    return -2;
   333	}
</pre>
			
		<p>
			В такого рода огромных процедурах без дробления областей видимости не обойтись никак. 
			Но в соответствии с современным
			взглядом на Clean Code большая процедура была бы разбита на небольшие. А в маленькой процедуре все переменные
			на виду. Неважно, объявлена ли переменная в самом начале, либо непосредственно в месте использования - 
			надежности кода это не повредит, а читабельности - даже прибавит (но об этом позже).
			
		<p>
			Рассмотрим еще один пример: файловый менеджер Nemo (версия 2.4.5). Фрагмент процедуры 
<a href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c#L691">
update_places()</a> приведен в <a href="#listing-2">листинге 2</a>. 484 строки кода! Даже с учетом красивого форматирования
(как видим, переменные одного типа, но разного назначения, объявлены в разных строках), и с учетом того, что программирование
GUI на С - это вам не какой-нибудь CRUD на Java, это очень много. 

<h4 id="listing-2">Листинг 2 - фрагмент процедуры update_places() из файлового менеджера Nemo</h4>
<pre>
   691	static void
   692	update_places (NemoPlacesSidebar *sidebar)
   693	{
   694		NemoBookmark *bookmark;
   695		GtkTreeSelection *selection;
   696		GtkTreeIter last_iter, cat_iter;
   697		GtkTreeModel *model;
   698		GVolumeMonitor *volume_monitor;
   699		GList *mounts, *l, *ll;
   700		GMount *mount;
   701		GList *drives;
   702		GDrive *drive;
   703		GList *volumes;
   704		GVolume *volume;
   705		int bookmark_count, bookmark_index;
   706		char *location, *mount_uri, *name, *desktop_path, *last_uri, *identifier;
   707		const gchar *bookmark_name;
   708		GIcon *icon;
   709		GFile *root;
   710		NemoWindowSlot *slot;
   711		char *tooltip;
   712	    gchar *tooltip_info;
   713		GList *network_mounts, *network_volumes;
   714		NemoFile *file;
   715	    gint full;
   716	
   717		DEBUG ("Updating places sidebar");
   718	
   719	    sidebar->updating_sidebar = TRUE;
   720	
   721		model = NULL;
   722		last_uri = NULL;
   723	
   724		selection = gtk_tree_view_get_selection (sidebar->tree_view);
   725		if (gtk_tree_selection_get_selected (selection, &model, &last_iter)) {
   726			gtk_tree_model_get (model,
   727					    &last_iter,
   728					    PLACES_SIDEBAR_COLUMN_URI, &last_uri, -1);
   729		}
   
   ...
  
  1166	
  1167		/* restore selection */
  1168	    restore_expand_state (sidebar);
  1169		sidebar_update_restore_selection (sidebar, location, last_uri);
  1170	
  1171	    sidebar->updating_sidebar = FALSE;
  1172	
  1173		g_free (location);
  1174		g_free (last_uri);
  1175	}
</pre>

		<p>
			Если присмотреться повнимательнее, можно замететить, что все (по крайней мере, большая часть) объявлены
			в самом начале процедуры, а не в местах их непосредственного использования! 
			Мне кажется, что автор сознательно так сделал. Возможно, потому что так проще следить за освобождением памяти
			(Nemo построен на библиотеке GTK, так что везде используются соответствующие библиотечные средства)?.. 
			Этот стиль сильно смахивает на паскалевский. Опять-таки, в небольшой процедуре можно
			безболезненно разместить объявление переменных в самом ее начале.
			
		<h2>Pascal рулит!</h2>
		
		<p>
			Я уже не очень хорошо помню Pascal, так что вместо реальных исходников буду приводить псевдокод.
			Пусть у нас есть унылое финансовое приложение. А в этом приложении - функция, которая вычисляет зарплату работника
			с учетом стажа работы.
			Напишем ее на псевдо-С и получим <a href="#listing-3">листинг 3</a>.
			
<h4 id="listing-3">Листинг 3 - функция вычисления зарплаты на псевдо-C</h4>
<pre>
function double salary(double base_salary, int experience) {
	if (experience &lt; 2)
		return base_salary;
	double bonus = base_salary * 0.1;
	return base_salary + bonus; 
}
</pre>
		
		<p>
			Да, некоторые моменты в моем примере неоптимальны, можно написать лучше. Но речь не об этом. А чтобы понять, 
			о чем я хотел сказать, взглянем на <a href="#listing-4">листинг 4</a>.
			
<h4 id="listing-4">Листинг 4 - функция вычисления зарплаты на псевдо-Pascal</h4>
<pre>
FUNCTION salary(base_salary: DOUBLE, experience: INTEGER): DOUBLE
VAR
	bonus: DOUBLE;
BEGIN
	IF experience &lt; > 2 
		salary := base_salary; 
	ELSE BEGIN
		bonus := base_salary * 0.1;
		salary := base_salary + bonus;
	END
	salary;
END
</pre>

		<p>
			По-моему, Pascal-стиль лучше (хотя меня самого бесят эти пяти- и трехбуквенные BEGIN и END). Регистрозависимость - 
			вещь более чем спорная. Мне, например, больше нравится Pascal, когда зарезервированные слова пишутся заглавными
			буквами, а все остальное - строчными. Перейдем лучше к более объективным темам.
			
		<p>
			
			Объявлена ли переменная bonus непосредственно в месте использования или же в отдельном разделе для такой
			маленькой функции роли не играет. Именно из-за небольшого объема функции. А если функция получается
			большой, то не нужно хвататься за возможности дробления областей видимости. Следует разбить функцию на небольшие
			функции, и тогда все станет намного понятнее.

			
		<p>
			<ol>
				<li>
					Pascal-код легче читать. Дело в том, что большая часть времени программиста уходит на чтение чужого
					кода. C-подобных языках для знакомства с функцией (даже в общих чертах - сигнатуры не всегда
					достаточно) нужно смотреть ее тело.
					А в Pascal рядом с сигнатурой функции находятся разделы CONST и VAR. В них переменные просто объявлены,
					лаконично. Это позволяет беглым взглядом 
					оценить, что же делает функция.
					
				<li>
					В Pascal проще вести лог. Опять-таки, в силу того, что количество и имена переменных известны заранее,
					их можно логгировать в любом месте процедуры. Я часто видел, как в коде на Java, вместо того, чтобы 
					объявить переменную внутри блока (выражения if-else), ее специально выносили за его пределы, чтобы
					занести в журнал результат. 

				<li>
					Код на Pascal проще отлаживать. Как и в предыдущем пункте, переменные известны заранее.
					В отладчика в окошке Watches будет фиксированное количество строчек - по одной на каждую переменную. 
					А не то, что в Java: переменные то появляются, то исчезают из вида.
			</ol>
			
		<h2>Пара слов о неизменяемости</h2>
		
		<p>
			В некоторых языка (Java) можно наблюдать оксюморон: неизменяемая переменная (т.е. final). Что касается 
			локальных переменных, можно сказать одно: неизменяемость не нужна. Да, именно так. Если у вас есть класс,
			то его поля нужно делать неизменяемыми. Или если у вас метод-простыня на 200 строк, то без final тоже не обойтись.
			Но в небольших методах final или не final - значения не имеет. Недаром же в последних версиях языка появилось
			понятие effective final (переменная не объявлена неизменяемой явно, но фактически значение ей присваивается 
			лишь один раз).
			
		<h2>О сборке мусора</h2>
		
		<p>
			Я в этой теме не разбираюсь. Говорят, что final - это хорошо для сборки мусора. Но чем раздел переменных хуже?
			Заранее известно, столько и чего будет. Выходим из процедуры - освобождаем все переменные (т.е. выделенную
			для них память) скопом, кроме тех, что были переданы во "внешний мир".
			
		
			
			
Давным-давно (по нашим меркам) создатели языка программирования С (и не только они, просто кроме Кернигана, Ричи и Вирта
я не знаю других "отцов-основателей") приняли мудрое решение: минимизировать область видимости (scope) переменных настолько, 
насколько это возможно. Если переменная объявлена и используется только в цикле или блоке условного оператора, то нечего
выставлять ее наружу. Для окружающего кода такой переменной просто нет. Сюда же можно отнести еще один эффект: переменная
более узкой области видимости "затеняет" переменную более широкой области видимости. Это верный подход. Но он 
приносит богатый урожай только в случае, если функции огромные. 

Сегодня никому не придет в голову писать функцию на 100 строк (а в конце 90-х начале 2000-ых функции писали поистине 
гигантскими, по крайней мере, в модулях Linux PAM - некоторые из них не обновлялись с тех давних времен - 
именно такие простыни и можно наблюдать). Еще один пример - файловый менеджер Nemo. В нем, как ни странно, используется
такой подход: в самом начале функции объявляются переменные, штук пять. И эти переменные используются на протяжении всей
функции. Хотя часть их них можно было бы объявить внутри блоков поменьше. Вызвано ли это особенностями библиотеки GTK 
(упрощение управления памятью, чтобы не удалять переменные в каждом блоке?), или это такой стиль автора я не знаю - так
глубоко не закапывался в исходники.

Ну а если функция помещается на 10 строчек, то дробление ее на блоки (по сути более мелкие области видимости) не играет
решающего значения. В конце концов, функция маленькая, делает строго определенную задачу. Если функция получается сложная
и большая, то лучше разбить ее на две-три поменьше, а не пытаться ухватиться за возможности локальных по отношению к блоку
переменных. Более того, C-подобный стиль даже вредит. Это проще проиллюстрировать на примере.

Возьмем банальную предметную область: финансы. Сейчас же большинство программ обслуживают бизнес в духе "купи-продай",
космические корабли - лишь малая часть от всего объема ПО в мире.

Пусть у нас есть функция, которая вычисляет премию сотрудника. Попробуем реализовать ее в псеводокоде в стиле C и в 
стиле Pascal. И посмотрим, что лучше для рядового программиста, которому нужно внедрить новую фичу, а не наслаждаться
красотами того или иного ЯП.








У Паскалевского стиля есть неоспоримое преимущество над Си (как правильно заметил автор 
упомянутой в самом начале статьи) - отсутствие областей видимости как таковых. Т.е. областью
видимости в Паскале может быть только модуль, функция и процедура. Никаких блоков, никаких "перекрытий" и т.п. Запомнить
очень легко. И возможности совершить ошибку меньше. 


Что же касается неизменяемости, то тут я ничего не знаю. Но если рассуждать логически, то с точки зрения программиста
неизменяемость переменных (как final в Java) - это способ повышения надежности - неизменяемую переменную сложно использовать
не по назначению (хотя само по себе понятие неизменяемой переменнйо странное). Но с другой стороны, если процедуры в 
программе небольшие, неизменяемость не играет ключевой роли. Ведь код процедуры вполне обозрим. Что же касается 
неизменяемых переменных, то в Паскале нового поколения можно просто добавить отдельный (в дополнение к имеющимся
CONST и VAR) раздел, только назвать его нужно "одноразовые переменные".

А сборщику мусора, я думаю, будет даже проще: после выхода из процедуры все, что объявлено в CONST и VAR можно удалить
нафиг. Но я не уверен. :)

Так а что насчет скобочек?

В свете уменьшения значимости scope'а операторные скобки не играют никакой роли. { и } ничуть не хуже, чем BEGIN и END.
Ибо процедуры у нас маленькие, обозримые, не нужно проматывать исходник в поисках закрывающей скобки.
Так же BEGIN и END ничуть не хуже, чем PROCEDURE_NAME и END PROCEDURE_NAME (так принято в языке Basic). Ну и оступы 
очень даже ничего.

И напоследок логи. В паскалевском стиле писать в журнал очень легко. Потому что все переменные объявлены заранее. Ситуации, 
когда запись в лог пишется за пределами блока, в Паскале невозможна.

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>





