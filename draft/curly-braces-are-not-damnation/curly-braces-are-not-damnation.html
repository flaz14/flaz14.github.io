<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Фигурные скобки - не проклятие</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#curly-braces-are-not-damnation" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/curly-braces-are-not-damnation/curly-braces-are-not-damnation.html">
				Фигурные скобки - не проклятие
			</a>
		</h1>
		
		<h3>[2018, Февраль]</h3>

		<h2>Начало</h2>

		<p>
			Недавно я прочитал статью <a href="https://habrahabr.ru/post/258391/">«Проклятие» фигурных скобочек</a> и 
			комментарии к ней. Обсуждение там развернулось нешуточное. Я пытался найти мнение, созвучное моим 
			собственным ламерским измышлениям, но тщетно. Поэтому и написал эту заметку.
			
		<h2>Маленькое отступление насчет скобочек</h2>

		<p>
			Я видел отрывки кода на Rust, Ruby, Perl, PHP. Что мне не понравилось в этих языках, так это засилье всяких
			закорючек, таких как <b><code>=></code></b>, <b><code>$</code></b>, <b><code>::</code></b>, 
			<b><code>||</code></b> и т.п. По-моему,
			обилие такого рода лексем ухудшает читаемость кода. Но восприятие исходников - понятие субъективное. Кому-то
			больше по душе закорючки, кому-то - английские слова (в этом смысле очень хорош Python: заковыристых
			операторов там совсем немного). Объективно то, что обычные слова (хоть они и занимают больше знакомест на
			экране) проще печатать: не нужно зажимать <kbd>Shift</kbd> и лезть в дальние углы клавиатуры (к слову, 
			прагматичные раскладки вроде Dvorak и Colemak смягчают эту проблему). Да и "грепнуть" исходник, написанный
			словами, попроще будет.
		
		<h2>Области видимости - вот истинное проклятие C-подобных языков!</h2>

		<p>
			В самих областях видимости (равно как и в пространствах имен) нет ничего плохого. Но в C-подобных
			языках (по стечению обстоятельств в них как раз используются фигурные скобочки) области видимости возведены
			в абсолют. Из-за перебора с этой концепцией страдают C-подобные языки в целом.
		
		<p>
			Чтобы стало понятнее, попробуем зайти издалека. Люди всегда стремились к чему-то совершенному. В мире физики,
			к примеру, обожествлена сфера как идеальное вместилище материи. В прошлом-позапрошлом веке атом был 
			загадкой. Но к настоящему моменту наука и способы постановки экспериментов значительно продвинулись. Тем не 
			менее, и сегодня атомы и элементарные частицы изображают именно в виде шариков. Просто никто, за редким 
			исключением <sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>, в наши дни не смеет 
			покушаться на несовершенство кирпичиков мироздания и придавать им некрасивые формы.
		
		<p>
			Еще один пример из мира физики - Теории Великого Объединения. Но почему в природе должен быть только один 
			вид взаимодействия материи? Чем числа 2 или 3 или N хуже, чем единица? Ничем, просто человеку хочется 
			идеального <sup id="footnote-2-top"><a href="#footnote-2-bottom">[2]</a></sup>.
			
		<p>
			Вообще, аналогия - вещь ненадежная. А годится она только для того, чтобы запудрить оппоненту мозги и доказать 
			свою бредовую версию. Но что-то в ней есть. Ибо похожая ситуация наблюдается в языках программирования.

		<p>
			В C-подобных языках проявляется непрестанное стремление к минимизации области видимости переменных. 
			Переменная должна быть объявлена как можно ближе к месту ее непосредственного использования (и,
			по возможности, проиницилизирована). 
			Обоснований такого подхода несколько:
			
			<ul>
				<li>
					Переменную нельзя будет по ошибке использовать за пределами ее "родного" блока.
					
				<li>
					В разных подблоках в пределах одного блока можно называть переменные одинаково, и они не будут 
					пересекаться.
				
				<li>
					Блок с локальными по отношению к нему переменными проще вынести в отдельную процедуру.
					
				<li>
					и т.д.
			</ul>

		<p>
			Все эти доводы верные. Но у каждой медали есть обратная сторона. Посмотрим, почему же минимизация области
			видимости приносит больше вреда, чем пользы (с поправкой на наши дни, естественно).
		
		<h2>Clean Code or not Clean Code?</h2>
		
		<p>
			В конце 70-x - начале 80-ых ЯП высокого уровня только начинали входить в моду. Мало кто тогда имел богатый
			опыт разработки на такого рода языках. Коллективы программистов были относительно небольшие. Отдельно взятый
			разработчик чувствовал себя едва ли не владыкой Вселенной. Ведь Инернета и популярных нынче Code Review
			в те времена не было и в помине. Следовательно, обмен опытом происходил с черепашьей (по сегодняшним меркам)
			скоростью.
		
		<p>
			Clean Code того времени - это процедуры-простыни на 100 строчек и больше. Даже в 90-ых это считалось
			нормой. Для примера посмотрим на исходный текст <strong>Linux PAM</strong> (релиз <i>Linux-PAM-1.3.0</i>). 
			Я специально взял модуль <em>pam_userdb</em>. Он был написан в 1996 году, так что вполне отражает
			дух прошлого.
			
		<p>
			Рассмотрим процедуру 
<a href="https://github.com/linux-pam/linux-pam/blob/1cad9fb2a0d729c5b5e5aa7297c521df7d5a2d33/modules/pam_userdb/pam_userdb.c#L151">
user_lookup()</a> 
			(номера строк я поставил специально, чтобы добавить драматизма). 
			Ее начало и конец приведены в <a href="#listing-1">листинге 1</a>. А всего она занимает 182 строки 
			исходного кода! Да, следует
			сделать скидку на имеющиеся в процедуре макросы для условной компиляции, а также на форматирование (например, 
			сигнатура расположена на трех строках из соображений удобочитамости). Фрагменты, снабженные
			комментариями вроде <cite>/* dump out the database contents for debugging */</cite>, так и просятся быть
			вынесенными в отдельные процедуры. Но нет, все слеплено вместе.

<h4 id="listing-1">Листинг 1 - фрагмент процедуры user_lookup() из Linux PAM</h4>
<pre>
   151	static int
   152	user_lookup (pam_handle_t *pamh, const char *database, const char *cryptmode,
   153		     const char *user, const char *pass, int ctrl)
   154	{
   155	    DBM *dbm;
   156	    datum key, data;
   157	
   158	    /* Open the DB file. */
   159	    dbm = dbm_open(database, O_RDONLY, 0644);
   160	    if (dbm == NULL) {
   161		pam_syslog(pamh, LOG_ERR,
   162			   "user_lookup: could not open database `%s': %m", database);
   163		return -2;
   164	    }

   ...

   325		if (saw_user)
   326		    return -1; /* saw the user, but password mismatch */
   327		else
   328		    return 1; /* not found */
   329	    }
   330	
   331	    /* NOT REACHED */
   332	    return -2;
   333	}
</pre>
			
		<p>
			В такого рода огромных процедурах без дробления областей видимости не обойтись никак. 
			Но в соответствии с современным
			взглядом на Clean Code большая процедура была бы разбита на небольшие. А в маленькой процедуре все переменные
			на виду. Неважно, объявлена ли переменная в самом начале, либо непосредственно в месте использования - 
			надежности кода это не повредит, а читабельности - даже прибавит (но об этом 
			<a href="#note-about-pascal-readability">позже</a>).
		
		<p>
			Рассмотрим еще один пример: файловый менеджер <strong>Nemo</strong> (версия <i>2.4.5</i>). Фрагмент 
			процедуры 
<a href="https://github.com/linuxmint/nemo/blob/751bacba6f9e4730241d1b69536e2934b1fa6c81/src/nemo-places-sidebar.c#L691">
update_places()</a> 
			приведен в <a href="#listing-2">листинге 2</a>. 484 строки кода! Даже с учетом красивого форматирования
			(как видим, объявления переменных одного типа, но разного назначения, размещены на разных строках), 
			и с учетом того, 
			что программирование
			GUI на С - это вам не какой-нибудь CRUD на Java, это очень много. 

<h4 id="listing-2">Листинг 2 - фрагмент процедуры update_places() из файлового менеджера Nemo</h4>
<pre>
   691	static void
   692	update_places (NemoPlacesSidebar *sidebar)
   693	{
   694		NemoBookmark *bookmark;
   695		GtkTreeSelection *selection;
   696		GtkTreeIter last_iter, cat_iter;
   697		GtkTreeModel *model;
   698		GVolumeMonitor *volume_monitor;
   699		GList *mounts, *l, *ll;
   700		GMount *mount;
   701		GList *drives;
   702		GDrive *drive;
   703		GList *volumes;
   704		GVolume *volume;
   705		int bookmark_count, bookmark_index;
   706		char *location, *mount_uri, *name, *desktop_path, *last_uri, *identifier;
   707		const gchar *bookmark_name;
   708		GIcon *icon;
   709		GFile *root;
   710		NemoWindowSlot *slot;
   711		char *tooltip;
   712	    gchar *tooltip_info;
   713		GList *network_mounts, *network_volumes;
   714		NemoFile *file;
   715	    gint full;
   716	
   717		DEBUG ("Updating places sidebar");
   718	
   719	    sidebar->updating_sidebar = TRUE;
   720	
   721		model = NULL;
   722		last_uri = NULL;
   723	
   724		selection = gtk_tree_view_get_selection (sidebar->tree_view);
   725		if (gtk_tree_selection_get_selected (selection, &model, &last_iter)) {
   726			gtk_tree_model_get (model,
   727					    &last_iter,
   728					    PLACES_SIDEBAR_COLUMN_URI, &last_uri, -1);
   729		}
   
   ...
  
  1166	
  1167		/* restore selection */
  1168	    restore_expand_state (sidebar);
  1169		sidebar_update_restore_selection (sidebar, location, last_uri);
  1170	
  1171	    sidebar->updating_sidebar = FALSE;
  1172	
  1173		g_free (location);
  1174		g_free (last_uri);
  1175	}
</pre>

		<p>
			Если присмотреться повнимательнее, можно замететить, что почти все переменные объявлены
			в самом начале процедуры, а не в местах их непосредственного использования! 
			Мне кажется, втор сознательно так сделал. Возможно, потому что так проще следить за освобождением памяти
			(Nemo построен на библиотеке GTK, так что везде используются соответствующие библиотечные средства 
			управления памятью)?..
			
		<h2>Pascal рулит!</h2>
		
		<p>
			Я уже не очень хорошо помню Pascal и C, так что вместо реальных исходников буду приводить псевдокод.
			Пусть у нас есть унылое финансовое приложение. А в этом приложении - функция, которая вычисляет зарплату 
			работника
			с учетом стажа работы.
			Напишем ее на псевдо-С и получим <a href="#listing-3">листинг 3</a>.

<h4 id="listing-3">Листинг 3 - функция вычисления зарплаты на псевдо-C</h4>
<pre>
function double salary(double base_salary, int experience) {
	if (experience &lt; 2)
		return base_salary;
	double bonus = base_salary * 0.1;
	return base_salary + bonus; 
}
</pre>
		
		<p>
			Да, некоторые моменты в моем примере неоптимальны, можно написать лучше. Но речь не об этом. А чтобы понять, 
			о чем я хотел сказать, взглянем на <a href="#listing-4">листинг 4</a>.
			
<h4 id="listing-4">Листинг 4 - функция вычисления зарплаты на псевдо-Pascal</h4>
<pre>
FUNCTION salary(base_salary: DOUBLE, experience: INTEGER): DOUBLE
VAR
	bonus: DOUBLE;
BEGIN
	IF experience &lt; 2 
		salary := base_salary; 
	ELSE BEGIN
		bonus := base_salary * 0.1;
		salary := base_salary + bonus;
	END
END
</pre>

		<p>
			По-моему, Pascal-стиль лучше (хотя меня самого бесят эти пяти- и трехбуквенные BEGIN и END). Регистрозависимость - 
			вещь более чем спорная. Мне, например, больше нравится Pascal, когда зарезервированные слова пишутся заглавными
			буквами, а все остальное - строчными.
			
		<p>			
			Суть заключается вот в чем. 
			Объявлена ли переменная <code>bonus</code> непосредственно в месте использования или же в отдельном разделе, 
			для маленькой функции роли не играет. Именно из-за небольшого объема функции. А если функция получается
			большой, то не нужно хвататься за возможности дробления областей видимости. Следует разбить функцию на небольшие
			функции, и тогда все станет на свои места. Итак:
			
		<p id="note-about-pascal-readability">
			<ol>
				<li>
					<p>
						Pascal-код легче читать. C-подобных языках для знакомства с функцией (сигнатуры редко бывает 
						достаточно) нужно смотреть ее тело.
						А в Pascal рядом с сигнатурой функции находятся разделы <strong>CONST</strong> и 
						<strong>VAR</strong>, в которых константы и переменные просто лаконично перечислены.
						Это позволяет даже беглым взглядом получить достаточно сведений о том, что делает функция.
					
					<p>
						Объявление переменных в отдельном разделе приносит еще одно преимущество: типы данных не путаются
						в основном коде. Читать <code>bonus := base_salary * 0.1;</code> все же проще, чем
						<code>double bonus = base_salary * 0.1;</code>. В C#, как сказал 
						<a href="https://habrahabr.ru/post/258391/#comment_8432435">akastargazer</a>, 
						<blockquote>
							Поток управления перемешан с объявлением переменных, читать такое крайне тяжко. 
							Конечно, можно объявить переменные раньше, одним блоком 
							(специального места для объявления нет, поэтому объявлять можно где угодно, 
							повышая вероятность неаккуратного использования). 
							Но зачем, ведь язык попустительствует, надо пользоваться возможностями.
						</blockquote>
				
				<li>
					<p>
						В Pascal проще вести лог. Опять-таки, в силу того, что количество и имена переменных всегда
						известны заранее,
						их можно логгировать в любом месте процедуры. Я часто видел, как в коде на Java, вместо того, чтобы 
						объявить переменную внутри блока (выражения if-else), ее специально выносили за его пределы, чтобы
						занести в журнал результат. 

				<li>
					<p>
						Код на Pascal проще отлаживать. Как было сказано в предыдущем пункте, объявление 
						переменных предшествует выполнению процедуры.
						В отладчике в окошке Watches будет фиксированное количество строчек - по одной на каждую переменную. 
						А не то, что в Java: переменные то появляются, то исчезают из вида.
					
				<li>
					<p>
						В мире Pascal есть только один scope: модуль/процедура/функция/метод. Все, никаких блоков. 
						Концептуально это просто, можно забыть обо всяких перекрытиях одноименных переменных.
			</ol>
			
		<h2>О неизменяемости</h2>
		
		<p>
			В некоторых языках (Java) наблюдается оксюморон: неизменяемые, т.е. <em>final</em>, переменные. 
			Что касается локальных переменных, можно сказать смело: неизменяемость не нужна.
			Да, именно так. 
			Но если у вас метод-простыня занимает 100 строк исходника, то без <code>final</code> не обойтись.
			Но в небольших методах <code>final</code> или нет - значения не имеет. 
			Недаром же в последних версиях Java появилось
			понятие <em>effective final</em> переменной (переменная не объявлена неизменяемой явно, но фактически 
			значение ей присваивается лишь один раз).
		
		<h2>О сборке мусора</h2>
		
		<p>
			Я в этой теме не разбираюсь. Говорят, что <em>final</em> - это хорошо для сборки мусора. 
			Но чем раздел объявления переменных хуже? Ведь благодаря ему заранее известно, столько и чего будет. 
			Выходим из процедуры - освобождаем все переменные (т.е. выделенную
			для них память) скопом, кроме тех, что были переданы во "внешний мир".
		
		<h2>Что же насчет скобочек?</h2>

		<p>
			Нет здесь никакого проклятия. Отступы не хуже, чем <b>{</b> и <b>}</b>. А фигурные скобочки не хуже, 
			чем BEGIN и END. А BEGIN и END не 
			проигрывают ни в чем именованным собратьям, таким как END IF, END FOR, END &lt;procedure_name&gt;.
			
		<h2>Конец</h2>
		
		<p>
			Идея статьи в том, что считавшееся эталоном несколько десятков лет назад, не является примером для
			подражания сегодня. Время вносит свои коррективы: что-то отмирает, а что-то, наоборот, выходит на новый 
			виток развития. Что же касается новомодных языков программирования - это не лучшее из старого и нового.
			Это дьявольские смеси концепций, предназначенные для добывания денег 
			(техподдержка, книжки, курсы - все это уже проходили). Такова моя теория заговора :)
			
		<p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Не могу не прорекламировать книгу 
						<a href="https://www.ozon.ru/context/detail/id/7287912/">
							Физика гравитации и структура атомного ядра. Просто о сложном</a> 
						за авторством <em>Николая Паленко</em>. Нетривиальные и в то же время простые идеи. Ничуть не 
						хуже 
						многочисленных теорий струн.
					
				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 
						По этой теме хорошо прошелся <em>Mark A. Ludwig</em> в книге 
						<a href="https://www.amazon.com/Computer-Viruses-Artificial-Life-Evolution/dp/1440491984">
							Computer Viruses, Artificial Life And Evolution</a>.
			</ol>	
			
		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>





