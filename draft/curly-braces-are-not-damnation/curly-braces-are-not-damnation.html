<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Фигурные скобки - не проклятие</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#curly-braces-are-not-damnation" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/curly-braces-are-not-damnation/curly-braces-are-not-damnation.html">
				Фигурные скобки - не проклятие
			</a>
		</h1>
		
		<h3>[2018, Февраль]</h3>

		<h2>Начало</h2>

		<p>
			Недавно я прочитал статью <a href="https://habrahabr.ru/post/258391/">«Проклятие» фигурных скобочек</a> и 
			комментарии к ней. Обсуждение там развернулось нешуточное. Я надеялся найти мнение, созвучное с моими 
			собственными ламерскими измышлениями, но тщетно. Поэтом и написал эту статью.
			
		<p>
			Опыта работы с Oberon у меня нет. И с Rust тоже. Я знаю только Pascal, да и то лишь из школы и университета.
			
		<h2>Маленькое отступление насчет скобочек</h2>

		<p>
			Я видел отрывки кода на Rust, Ruby, Perl, PHP. Что мне не понравилось в этих языках, так это засилье всяких
			закорочек, таких как <code>=></code>, <code>$</code>, <code>::</code>, <code>||</code> и т.п. По-моему, 
			обилие такого рода лексем ухудшает читаемость кода. Но восприятие исходников - понятие субъективное. Кому-то
			больше по душе закорючки, кому-то - обычные английские слова (в этом смысле очень хорош Python, заковыристых
			операторов там совсем немного). Объективно то, что обычные слова (хоть они и занимают больше знакомест на
			экране) проще печатать: не нужно нажимать <kbd>Shift</kbd> и лезть в дальние углы клавиатуры (хотя 
			прагматичные раскладки вроде Dvorak и Colemak смягчают эту проблему). Да и "грепнуть" исходник, написанный
			словами, проще, чем специальными знаками.
		
		<h2>Области видимости - вот истинное проклятие C-подобных языков</h2>

		<p>
			Нет, в самих областях видимости (равно как и в пространствах имен), нет ничего плохого. Но в C-подобных 
			языках (по стечению обстоятельств в них как раз используются фигурные скобочки) области видимости возведены
			в абсолют. Из-за перебора с этой концепцией страдает язык в целом.
		
		<p>
			Чтобы было понятнее, попробуем зайти издалека. Люди всегда стремились к чему-то совершенному. В мире физики,
			к примеру, обожествлена сфера как идеальное вместилище материи. В прошлом-позапрошлом веке атом был загадкой.
			Но к настоящему моменту наука и способы постановки экспериментов значительно продвинулись. Тем не менее, 
			сегодня атомы и элементарные частицы 
			изображают именно в виде шариков. Просто никто (за редким исключением
			!!!тут будет ссылка на книгу Паленко!!!) в наши дни не смеет покушаться на несовершенство кирпичиков мироздания
			и придавать им некрасивые формы.
		
		<p>
			Еще один пример из мира физики - Теории Великого Объединения. Но почему в природе должен быть только один 
			вид взаимодействия материи? Чем числа 2 или 3 или N хуже, чем единица? Ничем, просто человеку хочется 
			идеального !!! будет ссылка на главу из книги Computer viruses, artificial life and evolution)!!!
			
		<p>
			Вообще, аналогия - вещь ненадежная. А годится она только для того, чтобы запудрить оппоненту мозги и доказать 
			свою бредовую версию. Но что-то в ней есть. Ибо аналогичная ситуация наблюдается в языках программирования.

		<p>
			В C-подобных языках проявляется непрестанное стремление к минимизации области видимости переменных. 
			Переменная должна быть объявлена как можно ближе к месту ее непосредственного использования (заодно можно
			сразу объявить и инициализировать переменную, присвоив ей значение в той же строчке исходника). 
			Обоснований такого подхода можно выдвинуть несколько:
			<ul>
				<li>
					Переменную нельзя будет по ошибке использовать за пределами ее "родного" блока.
					
				<li>
					В разных подблоках в пределах одного блока можно называть переменные одинаково, и они не будут 
					пересекаться.
				
				<li>
					Блок с локальными по отношению к нему переменными проще вынести в отдельный метод.
					
				<li>
					и т.д.
			</ul>

		<p>
			Все эти доводы верные. Но у каждой медали есть обратная сторона. Посмотрим, почему же минимизация области
			видимости приносит больше вреда, чем пользы (с поправкой на наши дни, естественно).
		
		<h2></h2>
		
		<p>
			В конце 70-x - начале 80-ых ЯП высокого уровня только начинали входить в моду. Мало кто тогда имел богатый
			опыт разработки на такого рода языках. Коллективы программистов были относительно небольшие. Отдельно взятый
			разработчик чувствовал себя едва лишь не владыкой Вселенной. Ведь коммуникации и популярных нынче Code Review
			в те времена не было и в помине. Следовательно, обмен опытом происходил с черепашьей (по сегодняшним меркам)
			скоростью.
		
		<p>
			Clean Code того времени - это функции-простыни на 100 строчек и больше. Даже в конце 90-ых это считалось
			нормой. Для примера посмотрим на исходный текст модуля Linux PAM (релиз Linux-PAM-1.3.0). 
			Я специально взял модуль <em>pam_userdb</em>. Он не обновлялся с конца 90-ых годов, так что вполне отражает
			дух прошлого.
			
		<p>
			Рассмотрим процедуру 
<a href="https://github.com/linux-pam/linux-pam/blob/1cad9fb2a0d729c5b5e5aa7297c521df7d5a2d33/modules/pam_userdb/pam_userdb.c#L151">
user_lookup()</a>. Ее начало и конец приведены в листинге 1. А всего она занимает... 
			
			static int
 (pam_handle_t *pamh, const char *database, const char *cryptmode,
const char *user, const char *pass, int ctrl)
			
<pre>

</pre>
			
Давным-давно (по нашим меркам) создатели языка программирования С (и не только они, просто кроме Кернигана, Ричи и Вирта
я не знаю других "отцов-основателей") приняли мудрое решение: минимизировать область видимости (scope) переменных настолько, 
насколько это возможно. Если переменная объявлена и используется только в цикле или блоке условного оператора, то нечего
выставлять ее наружу. Для окружающего кода такой переменной просто нет. Сюда же можно отнести еще один эффект: переменная
более узкой области видимости "затеняет" переменную более широкой области видимости. Это верный подход. Но он 
приносит богатый урожай только в случае, если функции огромные. 

Сегодня никому не придет в голову писать функцию на 100 строк (а в конце 90-х начале 2000-ых функции писали поистине 
гигантскими, по крайней мере, в модулях Linux PAM - некоторые из них не обновлялись с тех давних времен - 
именно такие простыни и можно наблюдать). Еще один пример - файловый менеджер Nemo. В нем, как ни странно, используется
такой подход: в самом начале функции объявляются переменные, штук пять. И эти переменные используются на протяжении всей
функции. Хотя часть их них можно было бы объявить внутри блоков поменьше. Вызвано ли это особенностями библиотеки GTK 
(упрощение управления памятью, чтобы не удалять переменные в каждом блоке?), или это такой стиль автора я не знаю - так
глубоко не закапывался в исходники.

Ну а если функция помещается на 10 строчек, то дробление ее на блоки (по сути более мелкие области видимости) не играет
решающего значения. В конце концов, функция маленькая, делает строго определенную задачу. Если функция получается сложная
и большая, то лучше разбить ее на две-три поменьше, а не пытаться ухватиться за возможности локальных по отношению к блоку
переменных. Более того, C-подобный стиль даже вредит. Это проще проиллюстрировать на примере.

Возьмем банальную предметную область: финансы. Сейчас же большинство программ обслуживают бизнес в духе "купи-продай",
космические корабли - лишь малая часть от всего объема ПО в мире.

Пусть у нас есть функция, которая вычисляет премию сотрудника. Попробуем реализовать ее в псеводокоде в стиле C и в 
стиле Pascal. И посмотрим, что лучше для рядового программиста, которому нужно внедрить новую фичу, а не наслаждаться
красотами того или иного ЯП.








У Паскалевского стиля есть неоспоримое преимущество над Си (как правильно заметил автор 
упомянутой в самом начале статьи) - отсутствие областей видимости как таковых. Т.е. областью
видимости в Паскале может быть только модуль, функция и процедура. Никаких блоков, никаких "перекрытий" и т.п. Запомнить
очень легко. И возможности совершить ошибку меньше. 

Есть и еще одно преимущество - упрощение отладки. Когда вы входите в блок, т.е. на самом деле в процедуру, функцию, и т.п.
вы сразу видите все параметры и локальные переменные. Ситуация, при которой у вас в отладчике в окошке Watches ни с того
ни с сего после входа в ветку IF появляется переменная в Паскале в принципе невозможна. Да, некоторые переменные могут
быть перечислены в Watches, но при этом быть пустыми. Но это не проблема. Гораздо важнее то, что этот набор переменных
(количественно) не поменяется ни при каких условиях.

Что же касается неизменяемости, то тут я ничего не знаю. Но если рассуждать логически, то с точки зрения программиста
неизменяемость переменных (как final в Java) - это способ повышения надежности - неизменяемую переменную сложно использовать
не по назначению (хотя само по себе понятие неизменяемой переменнйо странное). Но с другой стороны, если процедуры в 
программе небольшие, неизменяемость не играет ключевой роли. Ведь код процедуры вполне обозрим. Что же касается 
неизменяемых переменных, то в Паскале нового поколения можно просто добавить отдельный (в дополнение к имеющимся
CONST и VAR) раздел, только назвать его нужно "одноразовые переменные".

А сборщику мусора, я думаю, будет даже проще: после выхода из процедуры все, что объявлено в CONST и VAR можно удалить
нафиг. Но я не уверен. :)

Так а что насчет скобочек?

В свете уменьшения значимости scope'а операторные скобки не играют никакой роли. { и } ничуть не хуже, чем BEGIN и END.
Ибо процедуры у нас маленькие, обозримые, не нужно проматывать исходник в поисках закрывающей скобки.
Так же BEGIN и END ничуть не хуже, чем PROCEDURE_NAME и END PROCEDURE_NAME (так принято в языке Basic). Ну и оступы 
очень даже ничего.

И напоследок логи. В паскалевском стиле писать в журнал очень легко. Потому что все переменные объявлены заранее. Ситуации, 
когда запись в лог пишется за пределами блока, в Паскале невозможна.

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>





