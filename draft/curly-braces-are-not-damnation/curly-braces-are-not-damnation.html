Фигурные скобки - не проклятие

Недавно я прочитал статью 

<a href="https://habrahabr.ru/post/258391/">«Проклятие» фигурных скобочек</a> и комментарии к ней. Я везде надеялся найти
что-то, созвучное с моими собственными ламерскими измышлениями, но тщетно. Опыта работы с Oberon у меня нет. И с Rust 
тоже. Эти языки я вообще не видел ни разу в деле. Я помню только Pascal, который изучал в школе и затем в университете.
Так что "плясать" начну от него.

Маленькое отступление насчет скобочек

Я смотрел на отрывки кода на Rust, Ruby, Perl, PHP. В собственно фигурных скобках ничего плохого нет. Но скобки
(круглых, фигурных, квадратных, угловых) и обилие всяких вспомогательных служебных символов (таких как <code>=></code>,
<code>$</code>, <code>::</code>, <code>||</code> и т.п.) скорее портит язык, чем делает его более лаконичным. Печатать
все эти закорючки неудобно, нужно нажимать <kbd>Shift</kbd>, да и читается все это не очень. Другое дело Python. В нем
почти нет заковыристых зарезервированных символов, только обычные английские слова. Еще точки, двоеточия, запятые, 
круглые скобки и немного других скобок - куда уж без них. Но в целом очень даже красиво. И грепнуть "англоязычный" исходник
намного проще, чем все эти закорючки.

Scope - вот истинное проклятие C-подобных языков.

Люди всегда (не всегда, но зачастую) стремяться к чему-то совершенному. Физики обожествляют сферу как самую совершенную
форму физического тела. Почти во всех учебниках и научных трудах атомы и элементарные частицы рисуют в виде шариков. 
Но никто не посягает (за редким исключением - тут будет ссылка на книгу Паленко) на неидеальность форм. Еще одна 
бредовая идея - единая теория всего. Как будто все многообразие сил в природе можно свести к одной-единственной. А почему
не к двум (сослаться на главу из книги Computer viruses, artificial life and evolution)? Вообще, аналогия вещь ненадежная.
А годится она только для того, чтобы запудрить оппоненту мозги и доказать свою бредовую версию. Но что-то в ней есть.
Ибо такая же ситуация наблюдается и в языках программирования.

Давным-давно (по нашим меркам) создатели языка программирования С (и не только они, просто кроме Кернигана, Ричи и Вирта
я не знаю других "отцов-основателей") приняли мудрое решение: минимизировать область видимости (scope) переменных настолько, 
насколько это возможно. Если переменная объявлена и используется только в цикле или блоке условного оператора, то нечего
выставлять ее наружу. Для окружающего кода такой переменной просто нет. Сюда же можно отнести еще один эффект: переменная
более узкой области видимости "затеняет" переменную более широкой области видимости. Это верный подход. Но он 
приносит богатый урожай только в случае, если функции огромные. 

Сегодня никому не придет в голову писать функцию на 100 строк (а в конце 90-х начале 2000-ых функции писали поистине 
гигантскими, по крайней мере, в модулях Linux PAM - некоторые из них не обновлялись с тех давних времен - 
именно такие простыни и можно наблюдать). Еще один пример - файловый менеджер Nemo. В нем, как ни странно, используется
такой подход: в самом начале функции объявляются переменные, штук пять. И эти переменные используются на протяжении всей
функции. Хотя часть их них можно было бы объявить внутри блоков поменьше. Вызвано ли это особенностями библиотеки GTK 
(упрощение управления памятью, чтобы не удалять переменные в каждом блоке?), или это такой стиль автора я не знаю - так
глубоко не закапывался в исходники.

Ну а если функция помещается на 10 строчек, то дробление ее на блоки (по сути более мелкие области видимости) не играет
решающего значения. В конце концов, функция маленькая, делает строго определенную задачу. Если функция получается сложная
и большая, то лучше разбить ее на две-три поменьше, а не пытаться ухватиться за возможности локальных по отношению к блоку
переменных. Более того, C-подобный стиль даже вредит. Это проще проиллюстрировать на примере.

Возьмем банальную предметную область: финансы. Сейчас же большинство программ обслуживают бизнес в духе "купи-продай",
космические корабли - лишь малая часть от всего объема ПО в мире.

Пусть у нас есть функция, которая вычисляет премию сотрудника. Попробуем реализовать ее в псеводокоде в стиле C и в 
стиле Pascal. И посмотрим, что лучше для рядового программиста, которому нужно внедрить новую фичу, а не наслаждаться
красотами того или иного ЯП.