Фигурные скобки - не проклятие

Недавно я прочитал статью 

<a href="https://habrahabr.ru/post/258391/">«Проклятие» фигурных скобочек</a> и комментарии к ней. Я везде надеялся найти
что-то, созвучное с моими собственными ламерскими измышлениями, но тщетно. Опыта работы с Oberon у меня нет. И с Rust 
тоже. Эти языки я вообще не видел ни разу в деле. Я помню только Pascal, который изучал в школе и затем в университете.
Так что "плясать" начну от него.

Маленькое отступление насчет скобочек

Я смотрел на отрывки кода на Rust, Ruby, Perl, PHP. В собственно фигурных скобках ничего плохого нет. Но скобки
(круглых, фигурных, квадратных, угловых) и обилие всяких вспомогательных служебных символов (таких как <code>=></code>,
<code>$</code>, <code>::</code>, <code>||</code> и т.п.) скорее портит язык, чем делает его более лаконичным. Печатать
все эти закорючки неудобно, нужно нажимать <kbd>Shift</kbd>, да и читается все это не очень. Другое дело Python. В нем
почти нет заковыристых зарезервированных символов, только обычные английские слова. Еще точки, двоеточия, запятые, 
круглые скобки и немного других скобок - куда уж без них. Но в целом очень даже красиво. И грепнуть "англоязычный" исходник
намного проще, чем все эти закорючки.

Scope - вот истинное проклятие C-подобных языков.

Люди всегда (не всегда, но зачастую) стремяться к чему-то совершенному. Физики обожествляют сферу как самую совершенную
форму физического тела. Почти во всех учебниках и научных трудах атомы и элементарные частицы рисуют в виде шариков. 
Но никто не посягает (за редким исключением - тут будет ссылка на книгу Паленко) на неидеальность форм. Еще одна 
бредовая идея - единая теория всего. Как будто все многообразие сил в природе можно свести к одной-единственной. А почему
не к двум (сослаться на главу из книги Computer viruses, artificial life and evolution)? Вообще, аналогия вещь ненадежная.
А годится она только для того, чтобы запудрить оппоненту мозги и доказать свою бредовую версию. Но что-то в ней есть.
Ибо такая же ситуация наблюдается и в языках программирования.

Давным-давно (по нашим меркам) создатели языка программирования С (и не только они, просто кроме Кернигана, Ричи и Вирта
я не знаю других "отцов-основателей") приняли мудрое решение: минимизировать область видимости (scope) переменных настолько, 
насколько это возможно. Если переменная объявлена и используется только в цикле или блоке условного оператора, то нечего
выставлять ее наружу. Для окружающего кода такой переменной просто нет. Сюда же можно отнести еще один эффект: переменная
более узкой области видимости "затеняет" переменную более широкой области видимости. Это верный подход. Но он 
приносит богатый урожай только в случае, если функции огромные. 

Сегодня никому не придет в голову писать функцию на 100 строк (а в конце 90-х начале 2000-ых функции писали поистине 
гигантскими, по крайней мере, в модулях Linux PAM - некоторые из них не обновлялись с тех давних времен - 
именно такие простыни и можно наблюдать). Еще один пример - файловый менеджер Nemo. В нем, как ни странно, используется
такой подход: в самом начале функции объявляются переменные, штук пять. И эти переменные используются на протяжении всей
функции. Хотя часть их них можно было бы объявить внутри блоков поменьше. Вызвано ли это особенностями библиотеки GTK 
(упрощение управления памятью, чтобы не удалять переменные в каждом блоке?), или это такой стиль автора я не знаю - так
глубоко не закапывался в исходники.

Ну а если функция помещается на 10 строчек, то дробление ее на блоки (по сути более мелкие области видимости) не играет
решающего значения. В конце концов, функция маленькая, делает строго определенную задачу. Если функция получается сложная
и большая, то лучше разбить ее на две-три поменьше, а не пытаться ухватиться за возможности локальных по отношению к блоку
переменных. Более того, C-подобный стиль даже вредит. Это проще проиллюстрировать на примере.

Возьмем банальную предметную область: финансы. Сейчас же большинство программ обслуживают бизнес в духе "купи-продай",
космические корабли - лишь малая часть от всего объема ПО в мире.

Пусть у нас есть функция, которая вычисляет премию сотрудника. Попробуем реализовать ее в псеводокоде в стиле C и в 
стиле Pascal. И посмотрим, что лучше для рядового программиста, которому нужно внедрить новую фичу, а не наслаждаться
красотами того или иного ЯП.








У Паскалевского стиля есть неоспоримое преимущество над Си (как правильно заметил автор 
упомянутой в самом начале статьи) - отсутствие областей видимости как таковых. Т.е. областью
видимости в Паскале может быть только модуль, функция и процедура. Никаких блоков, никаких "перекрытий" и т.п. Запомнить
очень легко. И возможности совершить ошибку меньше. 

Есть и еще одно преимущество - упрощение отладки. Когда вы входите в блок, т.е. на самом деле в процедуру, функцию, и т.п.
вы сразу видите все параметры и локальные переменные. Ситуация, при которой у вас в отладчике в окошке Watches ни с того
ни с сего после входа в ветку IF появляется переменная в Паскале в принципе невозможна. Да, некоторые переменные могут
быть перечислены в Watches, но при этом быть пустыми. Но это не проблема. Гораздо важнее то, что этот набор переменных
(количественно) не поменяется ни при каких условиях.

Что же касается неизменяемости, то тут я ничего не знаю. Но если рассуждать логически, то с точки зрения программиста
неизменяемость переменных (как final в Java) - это способ повышения надежности - неизменяемую переменную сложно использовать
не по назначению (хотя само по себе понятие неизменяемой переменнйо странное). Но с другой стороны, если процедуры в 
программе небольшие, неизменяемость не играет ключевой роли. Ведь код процедуры вполне обозрим. Что же касается 
неизменяемых переменных, то в Паскале нового поколения можно просто добавить отдельный (в дополнение к имеющимся
CONST и VAR) раздел, только назвать его нужно "одноразовые переменные".

А сборщику мусора, я думаю, будет даже проще: после выхода из процедуры все, что объявлено в CONST и VAR можно удалить
нафиг. Но я не уверен. :)

Так а что насчет скобочек?

В свете уменьшения значимости scope'а операторные скобки не играют никакой роли. { и } ничуть не хуже, чем BEGIN и END.
Ибо процедуры у нас маленькие, обозримые, не нужно проматывать исходник в поисках закрывающей скобки.
Так же BEGIN и END ничуть не хуже, чем PROCEDURE_NAME и END PROCEDURE_NAME (так принято в языке Basic). Ну и оступы 
очень даже ничего.