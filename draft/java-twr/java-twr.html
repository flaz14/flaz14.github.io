<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>try-with-resources на кошках</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#java-twr" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-twr/java-twr.html">
				try-with-resources на кошках
			</a>
		</h1>
		
		<h3>[2018, Февраль]</h3>
		
		<h2>Тренируйся лучше... на кошках</h2>

		<p>
			Java 8 уже прочно закрепилась в промышленном программировании. А по планете во всю шагает Java 9. Тем не 
			менее, не пропадает ощущение, что каждая новая версия Java - это не новые возможности, а исправления 
			недостатков предыдущей версии. В свое время так же выглядела конструкция <strong>try-with-resources</strong>
			(далее - <strong>TWR</strong>). Я прочитал про нее в одной умной книжке
			!!!тут будет ссылка на книгу Java 7. Новое поколение разработки!!!. Затем прочитал туториал Oracle 
			
			!!!тут будет ссылка на туториал от Oracle!!!. Но полностью не понял, что TWR за зверь такой. Так что ничего
			не осталось, как учиться самому не маленьких примерах.

		<h2>Переменные нужны, переменные важны</h2>
		
		<p>
			Начнем с самого простого примера
			!!!здесь будет сноска о том, зачем везде стоят номера строк: проще разбираться с ошибками компиляции 
			и стэктрэйсами.
			
			
			, который приведен в <a href="#listing-1">листинге 1</a>.
			
<h4 id="listing-1">Листинг 1 - типы переменных</h4>
<pre>
     1	public class VariablesTest {
     2		public static void main(String ignored[]) {
     3			try( MyAutoCloseable resource = new MyAutoCloseable() ) { }
     4			
     5			//try( AutoCloseable resource = new MyAutoCloseable() ) { }
     6		
     7			//try( new MyAutoCloseable() ) { }
     8		}
     9	}
    10	
    11	class MyAutoCloseable implements AutoCloseable {
    12		@Override
    13		public void close() {
    14			System.out.println(">>> close()"); 
    15		}
    16	}
</pre>

		<p>
			Действительно, все просто. Программа напечатает <tt>>>> close()</tt>.
		
		<p>
			Если мы расскоментируем строку №5, то получим ошибку компиляции:

<pre>
VariablesTest.java:5: error: unreported exception Exception; must be caught or declared to be thrown
		try( AutoCloseable resource = new MyAutoCloseable() ) { }
		                   ^
  exception thrown from implicit call to close() on resource variable 'resource'
1 error
</pre>
		
		<p>
			Если же раскомментировать строчку №7, то компилятор "порадует" таким известием:

<pre>
VariablesTest.java:7: error: illegal start of type
		try( new MyAutoCloseable() ) { }
		     ^
VariablesTest.java:7: error: = expected
		try( new MyAutoCloseable() ) { }
		         ^
</pre>

		<p>
			Таким образом, без явного объявления переменных в TWR обойтись нельзя. Тип переменной тоже имеет значение.
			Класс <code>MyAutoCloseable</code> реализует <code>AutoCloseable</code>. Но объявление переменной с типом
			интерфейса приводит к ошибке компиляции, посколько метод <code>close()</code> интерфейса декларирует исключение
			<code>Exception</code>. А в методе <code>close()</code> класса <code>MyAutoCloseable</code> об исключении не
			объявлено.

		<h2>Нет, переменные очень нужны</h2>
		
		<p>
			От порядка объявления переменных в TWR зависит порядок "закрытия" ресурсов. Оно и понятно: ресурсы закрываются
			в порядке, обратном их созданию. Это проиллюстрировано в <a href="#listing-2">листинге 2</a>.
			
<h4 id="#listing-2">Листинг 2 - порядок объявления переменных</h4>
<pre>
     1	public class OrderingTest {
     2		public static void main(String args[]) {
     3			System.out.println("--- First - Second");
     4			try ( 
     5				First first = new First();
     6				Second second = new Second();
     7			) {}
     8			
     9			System.out.println("--- Second - First");
    10			try (
    11				Second second = new Second();
    12				First first = new First();
    13			) {}
    14			
    15			System.out.println("--- variable for First is missed");
    16			try (
    17				Second second = new Second(
    18					new First()
    19				)
    20			) {}
    21		}
    22	}
    23	
    24	class First implements AutoCloseable {
    25		@Override
    26		public void close() {
    27			System.out.println(">>> First.close()");
    28		}
    29	}
    30	
    31	class Second implements AutoCloseable {
    32		public Second() {}
    33		
    34		public Second(First first) {}
    35		
    36		@Override
    37		public void close() {
    38			System.out.println(">>> Second.close()");
    39		}
    40	}
</pre>

		<p>
			Программа напечатает:

<pre>
--- First - Second
>>> Second.close()
>>> First.close()
--- Second - First
>>> First.close()
>>> Second.close()
--- variable for First is missed
>>> Second.close()
</pre>

		<p>
			Обратим внимание на случай <i>--- variable for First is missed</i>. Экземпляр класса <code>First</code>
			(созданный в строке 18) не был закрыт. А все из-за того, что мы передали его в конструктор <code>Second</code>
			напрямую, а не завели отдельную переменную. Конечно, в реальном коде такая такая ситуация маловероятна. Т.е.
			в методе <code>close()</code> класса <code>Second</code> должен явно вызываться одноименный метод класса 
			<code>First</code>, и так по цепочке. Но что если метод <code>close()</code> класса <code>Second</code> 
			выбросит исключение до того, как вызовет <code>close()</code> на экземпляре <code>First</code>? Ресурс
			<code>First</code> останется незакрытым. Решение одно: объявлять переменные для каждого ресурса отдельно.

		<h2></h2>




		
		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>






- Написать, почему я поставил @Override в интерфейсах. Конечно, глупо переопределять метод в интерфейсе. Ведь реализации
все равно нету. Ее необходимо предоставить в классе. Но аннотация @Override имеет смысл. Потому что поместив в нашем
интерфейсе метод с сигнатурой <code>void close();</code> мы "поглощаем" исключение, объявленное в интерфейсе

java.lang.AutoCloseable:



<pre>
public interface AutoCloseable {
    void close() throws Exception;
}
</pre>

И теперь, указывая в блоке TWR тип переменной как наш интерфейс, мы можем сделать вид, что никакого исключения не ожидается. 
И писать таким образом лямбда-выражения. Хотя в документации к AutoCloseable рекомендуется объявлять более конкретный тип 
исключения в реализации, если, конечно, реализация может выбрасывать проверяемое исключение.