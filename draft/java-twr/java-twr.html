<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>try-with-resources на кошках</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#java-twr" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-twr/java-twr.html">
				try-with-resources на кошках
			</a>
		</h1>
		
		<h3>[2018, Февраль]</h3>
		
		<h2>Тренируйся лучше... на кошках</h2>

		<p>
			Java 8 уже прочно закрепилась в промышленном программировании. А по планете во всю шагает Java 9. Тем не 
			менее, не пропадает ощущение, что каждая новая версия Java - это не новые возможности, а исправления 
			недостатков предыдущей версии. В свое время так же выглядела конструкция <strong>try-with-resources</strong>
			(далее - <strong>TWR</strong>). Я прочитал про нее в одной умной книжке
			!!!тут будет ссылка на книгу Java 7. Новое поколение разработки!!!. Затем прочитал туториал Oracle 
			
			!!!тут будет ссылка на туториал от Oracle!!!. Но полностью не понял, что TWR за зверь такой. Так что ничего
			не осталось, как учиться самому не маленьких примерах.

		<h2>Переменные нужны, переменные важны</h2>
		
		<p>
			Начнем с самого простого примера
			!!!здесь будет сноска о том, зачем везде стоят номера строк: проще разбираться с ошибками компиляции 
			и стэктрэйсами.
			
			
			, который приведен в <a href="#listing-1">листинге 1</a>.
			
<h4 id="listing-1">Листинг 1 - типы переменных имеют значение</h4>
<pre>
     1	public class VariablesTest {
     2		public static void main(String ignored[]) {
     3			try( MyAutoCloseable resource = new MyAutoCloseable() ) { }
     4			
     5			//try( AutoCloseable resource = new MyAutoCloseable() ) { }
     6		
     7			//try( new MyAutoCloseable() ) { }
     8		}
     9	}
    10	
    11	class MyAutoCloseable implements AutoCloseable {
    12		@Override
    13		public void close() {
    14			System.out.println(">>> close()"); 
    15		}
    16	}
</pre>

		<p>
			Действительно, все просто. Программа напечатает <tt>>>> close()</tt>.
		
		<p>
			Если мы расскоментируем строку №5, то получим ошибку компиляции:

<pre>
VariablesTest.java:5: error: unreported exception Exception; must be caught or declared to be thrown
		try( AutoCloseable resource = new MyAutoCloseable() ) { }
		                   ^
  exception thrown from implicit call to close() on resource variable 'resource'
1 error
</pre>
		
		<p>
			Если же раскомментировать строчку №7, то компилятор "порадует" таким известием:

<pre>
VariablesTest.java:7: error: illegal start of type
		try( new MyAutoCloseable() ) { }
		     ^
VariablesTest.java:7: error: = expected
		try( new MyAutoCloseable() ) { }
		         ^
</pre>

		<p>
			Таким образом, без явного объявления переменных в TWR обойтись нельзя. Тип переменной тоже имеет значение.
			Класс <code>MyAutoCloseable</code> реализует <code>AutoCloseable</code>. Но объявление переменной с типом
			интерфейса приводит к ошибке компиляции, посколько метод <code>close()</code> интерфейса декларирует исключение
			<code>Exception</code>. А в методе <code>close()</code> класса <code>MyAutoCloseable</code> об исключении не
			объявлено.

		<h2>Переменные ОЧЕНЬ нужны</h2>
		
		<p>
			От порядка объявления переменных в TWR зависит порядок "закрытия" ресурсов. Оно и понятно: ресурсы закрываются
			в порядке, обратном их созданию. Это проиллюстрировано в <a href="#listing-2">листинге 2</a>.
			
<h4 id="#listing-2">Листинг 2 - порядок объявления переменных имеет значение</h4>
<pre>
     1	public class OrderingTest {
     2		public static void main(String args[]) {
     3			System.out.println("--- First - Second");
     4			try ( 
     5				First first = new First();
     6				Second second = new Second();
     7			) {}
     8			
     9			System.out.println("--- Second - First");
    10			try (
    11				Second second = new Second();
    12				First first = new First();
    13			) {}
    14			
    15			System.out.println("--- variable for First is missed");
    16			try (
    17				Second second = new Second(
    18					new First()
    19				)
    20			) {}
    21		}
    22	}
    23	
    24	class First implements AutoCloseable {
    25		@Override
    26		public void close() {
    27			System.out.println(">>> First.close()");
    28		}
    29	}
    30	
    31	class Second implements AutoCloseable {
    32		public Second() {}
    33		
    34		public Second(First first) {}
    35		
    36		@Override
    37		public void close() {
    38			System.out.println(">>> Second.close()");
    39		}
    40	}
</pre>

		<p>
			Программа напечатает:

<pre>
--- First - Second
>>> Second.close()
>>> First.close()
--- Second - First
>>> First.close()
>>> Second.close()
--- variable for First is missed
>>> Second.close()
</pre>

		<p>
			Обратим внимание на случай <i>--- variable for First is missed</i>. Экземпляр класса <code>First</code>
			(созданный в строке 18) не был закрыт. А все из-за того, что мы передали его в конструктор <code>Second</code>
			напрямую, а не завели отдельную переменную. Конечно, в реальном коде такая такая ситуация маловероятна. Т.е.
			в методе <code>close()</code> класса <code>Second</code> должен явно вызываться одноименный метод класса 
			<code>First</code>, и так по цепочке. Но что если метод <code>close()</code> класса <code>Second</code> 
			выбросит исключение до того, как вызовет <code>close()</code> на экземпляре <code>First</code>? Ресурс
			<code>First</code> останется незакрытым. Решение одно: объявлять переменные для каждого ресурса отдельно.

		<h2>Полиморфизм в действии</h2>

		<p>
			Несмотря на то, что тип переменной в TWR имеет значение для компилятора в плане обрабатываемых исключений,
			полифорфизм никуда не исчез. В примере, приведенном в <a href="#listing-3">листинге 3</a>, рассмотрены три 
			случая: анонимный класс, "отдельностоящий" класс, который непосредственно реализует <code>AutoCloseable</code>,
			и класс, который реализует <code>AutoCloseable</code> через интерфейс-посредник (я сделал его специально
			для того, чтобы убрать надоедливый <code>IOException</code>, тянущийся из <code>AutoCloseable</code>).
		
<h4 id="listing-3">Листинг 3 - пример полифорфизма в TWR</h4>
<pre>
     1	public class PolymorphismTest {
     2		public static void main(String ignored[]) {
     3			try (
     4				SomeAutoCloseable resource = new SomeAutoCloseable() {
     5					@Override
     6					public void close() { System.out.println(">>> Anonymous close()"); }
     7				}
     8			) {}
     9			
    10			try ( SomeAutoCloseable resource = new StandaloneCloseAble() ) {}
    11			
    12			try ( InterfaceForAutoCloseable tricky = new TrickyAutoCloseable() ) {}
    13		}
    14	}
    15	
    16	class SomeAutoCloseable implements AutoCloseable {
    17		@Override
    18		public void close() { System.out.println(">>> Other.close()"); }
    19	}
    20	
    21	class StandaloneCloseAble extends SomeAutoCloseable {
    22		@Override
    23		public void close() { System.out.println(">>> Standalone close()"); }
    24	}
    25	
    26	interface InterfaceForAutoCloseable extends AutoCloseable { 
    27		@Override
    28		void close();
    29	}
    30	
    31	class TrickyAutoCloseable implements InterfaceForAutoCloseable {
    32		@Override
    33		public void close() { System.out.println(">>> TrickyAutoCloseable.close()"); }
    34	}
</pre>

		<p>
			Результаты работы программы предсказуемы, в каждой случае вызывается актуальный метод класса:
			
<pre>
>>> Anonymous close()
>>> Standalone close()
>>> TrickyAutoCloseable.close()
</pre>

		<h2>Лямбда-выражения - есть!</h2>
		
		<p>
			Да, в TWR можно творить, что угодно. В том числе и объявлять лямбда-выражения. Вгляните на 
			<a href="#listing-4">листинг 4</a>. 
			
<h4 id="listing-4">Листинг 4 - лямбда-выражения в TWR</h4>
<pre>
     1	public class LambdaTest {
     2		public static void main(String ignored[]) {
     3			System.out.println("--- Lambda #1 ---");
     4			try (
     5				MyAutoCloseable resource = () -> {
     6					System.out.println(">>> Lambda #1 close()");
     7				}
     8			) {}
     9			System.out.println("-----------------");
    10	
    11			System.out.println("--- Lambda #2 ---");
    12			try (
    13				MyAutoCloseable resource = () -> {
    14					System.out.println(">>> Lambda #2 close()");
    15					System.out.println("Stacktrace:");
    16					throw new IllegalStateException("Just for illustration");
    17				}
    18			) {}
    19		}
    20	}
    21	
    22	interface MyAutoCloseable extends AutoCloseable {
    23		@Override
    24		void close();
    25	}
</pre>

		<p>
			Тут тоже все вполне ожидаемо:
			
<pre>
--- Lambda #1 ---
>>> Lambda #1 close()
-----------------
--- Lambda #2 ---
>>> Lambda #2 close()
Stacktrace:
Exception in thread "main" java.lang.IllegalStateException: Just for illustration
	at LambdaTest.lambda$main$1(LambdaTest.java:16)
	at LambdaTest.main(LambdaTest.java:18)
</pre>

		<p>
			Лямбда-выражения работают. Правда, практического смысла в этом нет. Зачем нам лямбда-выражение, которое 
			нельзя использовать внутри блока <em>try</em>? Разве что для ведения журнала...
	
		<p>
			Стэктрэйс меня не огорчил, но и не порадовал. Раз уж лямбда выражение определено в TWR, я ожидал увидеть 
			в его имени в стэктрэйсе что-нибудь наподобие <code>LambdaTest.lambda$main$<twr>2$1(LambdaTest.java:16)</code>.
			Т.е. я ожидал увидеть подсказку, что лямбда выражение было определено не просто в методе <code>main()</code>,
			а именно внутри TWR (который идет под номером 2 в исходном коде; сгодилось бы и без циферки).
			
			!!!
			на самом деле можно - можем вызвать на переменной, ссылающейся
			на лямбда-выражение, метод <code>close()</code> (который будет вызван еще раз при выходе из TWR).
			!!!

		<p>
			

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>






- Написать, почему я поставил @Override в интерфейсах. Конечно, глупо переопределять метод в интерфейсе. Ведь реализации
все равно нету. Ее необходимо предоставить в классе. Но аннотация @Override имеет смысл. Потому что поместив в нашем
интерфейсе метод с сигнатурой <code>void close();</code> мы "поглощаем" исключение, объявленное в интерфейсе

java.lang.AutoCloseable:



<pre>
public interface AutoCloseable {
    void close() throws Exception;
}
</pre>

И теперь, указывая в блоке TWR тип переменной как наш интерфейс, мы можем сделать вид, что никакого исключения не ожидается. 
И писать таким образом лямбда-выражения. Хотя в документации к AutoCloseable рекомендуется объявлять более конкретный тип 
исключения в реализации, если, конечно, реализация может выбрасывать проверяемое исключение.