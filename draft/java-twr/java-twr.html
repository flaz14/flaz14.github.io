<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>try-with-resources на кошках</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#java-twr" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/java-twr/java-twr.html">
				try-with-resources на кошках
			</a>
		</h1>
		
		<h3>[2018, Февраль]</h3>
		
		<h2>Тренируйся лучше... на кошках</h2>

		<p>
			Java 8 уже прочно закрепилась в промышленном программировании. А по планете во всю шагает Java 9. Тем не 
			менее, не пропадает ощущение, что каждая новая версия Java - это не новые возможности, а исправления 
			недостатков предыдущей версии. В свое время так же выглядела конструкция <strong>try-with-resources</strong>
			(далее - <strong>TWR</strong>). Я прочитал про нее в одной умной книжке
			!!!тут будет ссылка на книгу Java 7. Новое поколение разработки!!!. Затем прочитал туториал Oracle 
			
			!!!тут будет ссылка на туториал от Oracle!!!. Но полностью не понял, что TWR за зверь такой. Так что ничего
			не осталось, как учиться самому не маленьких примерах.

		<h2>Переменные нужны, переменные важны</h2>
		
		<p>
			Начнем с самого простого примера
			!!!здесь будет сноска о том, зачем везде стоят номера строк: проще разбираться с ошибками компиляции 
			и стэктрэйсами.
			
			
			, который приведен в <a href="#listing-1">листинге 1</a>.
			
<h4 id="listing-1">Листинг 1 - типы переменных имеют значение</h4>
<pre>
     1	public class VariablesTest {
     2		public static void main(String ignored[]) {
     3			try( MyAutoCloseable resource = new MyAutoCloseable() ) { }
     4			
     5			//try( AutoCloseable resource = new MyAutoCloseable() ) { }
     6		
     7			//try( new MyAutoCloseable() ) { }
     8		}
     9	}
    10	
    11	class MyAutoCloseable implements AutoCloseable {
    12		@Override
    13		public void close() {
    14			System.out.println(">>> close()"); 
    15		}
    16	}
</pre>

		<p>
			Действительно, все просто. Программа напечатает <tt>>>> close()</tt>.
		
		<p>
			Если мы расскоментируем строку №5, то получим ошибку компиляции:

<pre>
VariablesTest.java:5: error: unreported exception Exception; must be caught or declared to be thrown
		try( AutoCloseable resource = new MyAutoCloseable() ) { }
		                   ^
  exception thrown from implicit call to close() on resource variable 'resource'
1 error
</pre>
		
		<p>
			Если же раскомментировать строчку №7, то компилятор "порадует" таким известием:

<pre>
VariablesTest.java:7: error: illegal start of type
		try( new MyAutoCloseable() ) { }
		     ^
VariablesTest.java:7: error: = expected
		try( new MyAutoCloseable() ) { }
		         ^
</pre>

		<p>
			Таким образом, без явного объявления переменных в TWR обойтись нельзя. Тип переменной тоже имеет значение.
			Класс <code>MyAutoCloseable</code> реализует <code>AutoCloseable</code>. Но объявление переменной с типом
			интерфейса приводит к ошибке компиляции, посколько метод <code>close()</code> интерфейса декларирует исключение
			<code>Exception</code>. А в методе <code>close()</code> класса <code>MyAutoCloseable</code> об исключении не
			объявлено.

		<h2>Переменные ОЧЕНЬ нужны</h2>
		
		<p>
			От порядка объявления переменных в TWR зависит порядок "закрытия" ресурсов. Оно и понятно: ресурсы закрываются
			в порядке, обратном их созданию. Это проиллюстрировано в <a href="#listing-2">листинге 2</a>.
			
<h4 id="#listing-2">Листинг 2 - порядок объявления переменных имеет значение</h4>
<pre>
     1	public class OrderingTest {
     2		public static void main(String args[]) {
     3			System.out.println("--- First - Second");
     4			try ( 
     5				First first = new First();
     6				Second second = new Second();
     7			) {}
     8			
     9			System.out.println("--- Second - First");
    10			try (
    11				Second second = new Second();
    12				First first = new First();
    13			) {}
    14			
    15			System.out.println("--- variable for First is missed");
    16			try (
    17				Second second = new Second(
    18					new First()
    19				)
    20			) {}
    21		}
    22	}
    23	
    24	class First implements AutoCloseable {
    25		@Override
    26		public void close() {
    27			System.out.println(">>> First.close()");
    28		}
    29	}
    30	
    31	class Second implements AutoCloseable {
    32		public Second() {}
    33		
    34		public Second(First first) {}
    35		
    36		@Override
    37		public void close() {
    38			System.out.println(">>> Second.close()");
    39		}
    40	}
</pre>

		<p>
			Программа напечатает:

<pre>
--- First - Second
>>> Second.close()
>>> First.close()
--- Second - First
>>> First.close()
>>> Second.close()
--- variable for First is missed
>>> Second.close()
</pre>

		<p>
			Обратим внимание на случай <i>--- variable for First is missed</i>. Экземпляр класса <code>First</code>
			(созданный в строке 18) не был закрыт. А все из-за того, что мы передали его в конструктор <code>Second</code>
			напрямую, а не завели отдельную переменную. Конечно, в реальном коде такая такая ситуация маловероятна. Т.е.
			в методе <code>close()</code> класса <code>Second</code> должен явно вызываться одноименный метод класса 
			<code>First</code>, и так по цепочке. Но что если метод <code>close()</code> класса <code>Second</code> 
			выбросит исключение до того, как вызовет <code>close()</code> на экземпляре <code>First</code>? Ресурс
			<code>First</code> останется незакрытым. Решение одно: объявлять переменные для каждого ресурса отдельно.

		<h2>Полиморфизм в действии</h2>

		<p>
			Несмотря на то, что тип переменной в TWR имеет значение для компилятора в плане обрабатываемых исключений,
			полифорфизм никуда не исчез. В примере, приведенном в <a href="#listing-3">листинге 3</a>, рассмотрены три 
			случая: анонимный класс, "отдельностоящий" класс, который непосредственно реализует <code>AutoCloseable</code>,
			и класс, который реализует <code>AutoCloseable</code> через интерфейс-посредник (я сделал его специально
			для того, чтобы убрать надоедливый <code>IOException</code>, тянущийся из <code>AutoCloseable</code>).
		
<h4 id="listing-3">Листинг 3 - пример полифорфизма в TWR</h4>
<pre>
     1	public class PolymorphismTest {
     2		public static void main(String ignored[]) {
     3			try (
     4				SomeAutoCloseable resource = new SomeAutoCloseable() {
     5					@Override
     6					public void close() { System.out.println(">>> Anonymous close()"); }
     7				}
     8			) {}
     9			
    10			try ( SomeAutoCloseable resource = new StandaloneCloseAble() ) {}
    11			
    12			try ( InterfaceForAutoCloseable tricky = new TrickyAutoCloseable() ) {}
    13		}
    14	}
    15	
    16	class SomeAutoCloseable implements AutoCloseable {
    17		@Override
    18		public void close() { System.out.println(">>> Other.close()"); }
    19	}
    20	
    21	class StandaloneCloseAble extends SomeAutoCloseable {
    22		@Override
    23		public void close() { System.out.println(">>> Standalone close()"); }
    24	}
    25	
    26	interface InterfaceForAutoCloseable extends AutoCloseable { 
    27		@Override
    28		void close();
    29	}
    30	
    31	class TrickyAutoCloseable implements InterfaceForAutoCloseable {
    32		@Override
    33		public void close() { System.out.println(">>> TrickyAutoCloseable.close()"); }
    34	}
</pre>

		<p>
			Результаты работы программы предсказуемы, в каждой случае вызывается актуальный метод класса:
			
<pre>
>>> Anonymous close()
>>> Standalone close()
>>> TrickyAutoCloseable.close()
</pre>

		<h2>Лямбда-выражения - есть!</h2>
		
		<p>
			Да, в TWR можно творить, что угодно. В том числе и объявлять лямбда-выражения. Вгляните на 
			<a href="#listing-4">листинг 4</a>. 
			
<h4 id="listing-4">Листинг 4 - лямбда-выражения в TWR</h4>
<pre>
     1	public class LambdaTest {
     2		public static void main(String ignored[]) {
     3			System.out.println("--- Lambda #1 ---");
     4			try (
     5				MyAutoCloseable resource = () -> {
     6					System.out.println(">>> Lambda #1 close()");
     7				}
     8			) {}
     9			System.out.println("-----------------");
    10	
    11			System.out.println("--- Lambda #2 ---");
    12			try (
    13				MyAutoCloseable resource = () -> {
    14					System.out.println(">>> Lambda #2 close()");
    15					System.out.println("Stacktrace:");
    16					throw new IllegalStateException("Just for illustration");
    17				}
    18			) {}
    19		}
    20	}
    21	
    22	interface MyAutoCloseable extends AutoCloseable {
    23		@Override
    24		void close();
    25	}
</pre>

		<p>
			Тут тоже все вполне ожидаемо:
			
<pre>
--- Lambda #1 ---
>>> Lambda #1 close()
-----------------
--- Lambda #2 ---
>>> Lambda #2 close()
Stacktrace:
Exception in thread "main" java.lang.IllegalStateException: Just for illustration
	at LambdaTest.lambda$main$1(LambdaTest.java:16)
	at LambdaTest.main(LambdaTest.java:18)
</pre>

		<p>
			Лямбда-выражения работают. Правда, практического смысла в этом нет. Зачем нам лямбда-выражение, которое 
			нельзя использовать внутри блока <em>try</em>? Разве что для ведения журнала...
	
		<p>
			Стэктрэйс меня не огорчил, но и не порадовал. Раз уж лямбда выражение определено в TWR, я ожидал увидеть 
			в его имени в стэктрэйсе что-нибудь наподобие <code>LambdaTest.lambda$main$<twr>2$1(LambdaTest.java:16)</code>.
			Т.е. я ожидал увидеть подсказку, что лямбда выражение было определено не просто в методе <code>main()</code>,
			а именно внутри TWR (который идет под номером 2 в исходном коде; сгодилось бы и без циферки).
			
			!!!
			на самом деле можно - можем вызвать на переменной, ссылающейся
			на лямбда-выражение, метод <code>close()</code> (который будет вызван еще раз при выходе из TWR).
			!!!

		<h2>final - не нужен</h2>

		<p>
			Неизменяемость нынче в моде. В Java модификатор <code>final</code> можно добавлять к чему угодно. Но в случае
			с TWR это не имеет никакого смысла. Объявленную в TWR переменную не позволит изменить компилятор; неважно,
			объявлена она как <code>final</code> или нет. Что и проиллюстрировано в 
			<a href="#listing-5">листинге 5</a>

<h4 id="#listing-5">Листинг 5 - пример использования final</h4>
<pre>
     1	public class FinalModifierTest {
     2		public static void main(String ignored[]) {
     3			try( final MyAutoCloseable my = new MyAutoCloseable() ) {}
     4			
     5			// Compile-time error: auto-closeable resource my may not be assigned
     6			/* 
     7			try( MyAutoCloseable my = new MyAutoCloseable() ) {
     8				my = null;
     9			}
    10			*/
    11		}
    12	}
    13	
    14	class MyAutoCloseable implements AutoCloseable {
    15		@Override
    16		public void close() {}
    17	}
</pre>

		<p>
			Об этом сказано в 
						<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.20.3">
				JSL</a>: 
				
				<cite>
					
						A variable declared in a resource specification is implicitly declared final (§4.12.4) if it is 
						not explicitly declared final.</cite>

		<h2>Магия null</h2>
		
		<p>
			Как сказано в 
			<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.20.3">
				JSL</a>: <cite>A resource is closed only if it initialized to a non-null value.</cite>
			Согласно спецификации, программа, приведенная в <a href="#listing-6">листинге 6</a>, 
<pre>
yura@Aspire-ES1-521 ~/Projects/flaz14.github.io/draft/java-twr/code $ cat -n NullPointer2Test.java 
     1	public class NullPointer2Test {
     2		public static void main(String ignored[]) {
     3			try(MyResource resource = getMyResource()) {
     4			}
     5		}
     6		
     7		private static MyResource getMyResource() {
     8			return null;
     9		}
    10	}
    11	
    12	class MyResource implements AutoCloseable {
    13		@Override
    14		public void close() {
    15			System.out.println(">>> MyResource.close()");
    16		}
    17	}
</pre>
		
		<p>
			ничего не напечатает. И это правильно. Вызов какого-либо метода на <code>null</code> не имеет смысла. Соответственно,
			вызыв <code>close()</code> на заведомо нулевой ссылке - тоже.
			
		<p>
			Рассмотрим еще один пример. Я воспроизвел его из упомянутой в начале статьи умной книжки и поместил в 
			<a href="#listing-7">листинг 7</a>.
			
<h4 id="listing-7">Листинг 7 - пример неотвратимого NullPointerException'а</h4>
<pre>
     1	import java.io.InputStream;
     2	import java.io.IOException;
     3	
     4	public class NullPointer1Test {
     5		public static void main(String ignored[]) throws IOException {
     6			try(InputStream i = getNullStream()) {
     7				i.available();
     8			}
     9		}
    10		
    11		private static InputStream getNullStream() { 
    12			return null;
    13		}
    14	}
</pre>

		<p>
			В книге в комментариях к примеру сказано:
			
			<blockquote>
				<p>
					Один из аспектов конструкции TWR - появление улучшенных стектрейсов и заблокированных исключений. До
					Java 7 информация об исключении могла быть поглощена при обработке ресурсов. Такой вариант не 
					исключен и с TWR, поэтому стековые следы были усовершенствованы. Теперь вы можете просматривать в
					исключениях и информацию о типах, которая ранее просто терялась.
					
				<p>
					Например, рассмотрим следующий фрагмент кода, в котором нулевой <code>InputStream</code> 
					возвращается из метода:
					
				<p>
					<i>далее идет то же, что и в <a href="#listing-7">листинге 7</a></i>
				
				<p>
					В результате получится улучшенный стектрейс, в котором мы увидим заблокированное исключение 
					<code>NullPointerException</code> (сокращенно - NPE):
					
				<p>
					<i>далее приведен стектрейс, но он в корне отличается от того, что реально получается в результате
					работы тестового кода</i>	
			</blockquote>
			
		<p>
			Запустим пример и получим:
			
<pre>
Exception in thread "main" java.lang.NullPointerException
	at NullPointer1Test.main(NullPointer1Test.java:7)
</pre>
		
		<p>
			Никакого упоминания о <code>Suppressed</code> нет. И старый добрый <code>NullPointerException</code> никуда
			не делся. Я ожидал, что нулевая ссылка на <code>i</code> будет "отловлена и подавлена" в TWR в месте создания
			ресурса, т.е. в строчке №6. Но нет, стэктрэйс ведет в строку №7, т.е. в место, где переменная была использована.
		
		<p>
			Т.о. <code>null</code>-значения в TWR вполне допустимы. То ли авторы не разобрались в теме, то ли переводчики
			напутали... Как бы то ни было, "подавление" исключений в TWR - совсем другой случай. Рассмотрим его далее.
			
		<h2>Suppressed exceptions</h2>
		
		<p>
			"Подавление" исключений	имеет смысл лишь в том случае, когда исключений возникает несколько. 
			Легче всего разобраться на примере. Об этом уже 
			рассказано в официальной статье от Oracle: 
			<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html#suppressed-exceptions">
			The try-with-resources Statement</a>.
			Но пример там выбран не сильно удачный. Он великоват, уловить суть непросто. Я сделал свой пример совсем маленьким.
			Он приведен в <a href="#listing-8">листинге 8</a>.

<h2 id="#listing-8">Листинг 8 - пример "подавляемого" исключения</h2>			
<pre>
     1	public class SuppressedExceptionTest {
     2		public static void main(String ignored[]) {
     3			try(MyResource resource = new MyResource()) {
     4				System.out.println(">>> try-block");
     5				throw new IllegalStateException("Exception from try-block");
     6			} finally {
     7				System.out.println(">>> finally-block");
     8			}
     9		}
    10	}
    11	
    12	class MyResource implements AutoCloseable {
    13		@Override
    14		public void close() {
    15			System.out.println(">>> MyResource.close()");
    16			throw new IllegalStateException("Exception from MyResource.close()");
    17		}
    18	}
</pre>
		
		<p>
			Тестовая программа напечатает:

<pre>
>>> try-block
>>> MyResource.close()
>>> finally-block
Exception in thread "main" java.lang.IllegalStateException: Exception from try-block
	at SuppressedExceptionTest.main(SuppressedExceptionTest.java:5)
	Suppressed: java.lang.IllegalStateException: Exception from MyResource.close()
		at MyResource.close(SuppressedExceptionTest.java:16)
		at SuppressedExceptionTest.main(SuppressedExceptionTest.java:6)
</pre>

		<p>
			Что же произошло? Первым делом выполнился блок <em>try</em>. Затем в строке №5 было выброшено исключение
			с текстом <tt>Exception from try-block</tt>. Но это исключение не "всплыло" наверх сразу. Так и должно быть.
			Блок <em>finally</em>
			<em>finally</em> выполняется всегда, независимо от того, было ли в <em>try</em> выброшено исключение или же
			возвращено значение посредством <em>return</em>. Но перед выполнением <em>finally</em> было произведено
			автоматическое закрытие ресурса, созданного в TWR. И во время автоматического закрытия произошло еще одно 
			исключение, с текстом <tt>Exception from MyResource.close()</tt>. Получается интересная ситуация: выброшены
			два исключения: одно родом из блока <em>try</em>, а другое - из безымянного блока автоматического закрытия
			(назовем его <em>pre-finally</em>). С ними надо что-то делать. Как пишут в умной книжке:
			
			<blockquote>
				<p>
					До Java 7 информация об исключении могла быть поглощена при обработке ресурсов. Такой вариант не
					исключен и с TWR, поэтому стековые следы были усовершенствованы. Теперь вы можете просматривать в исключениях
					информацию о типах, которая ранее просто терялась</cite>.
			</blockquote>
			
		<p>
			Да, так и есть. Первичным, если так можно выразиться, исключением был и остался 
			<code>IllegalStateException("Exception from try-block")</code>. За вторичное исключение, которое произошло позже
			в хронологическом порядке, принят 
			<code>IllegalStateException("Exception from MyResource.close()")</code>
			 (и вообще, это вторичное уже просто потому, что <em>pre-finally</em> - служебный автоматически генерируемый
			 компилятором
			 блок, к логике программы он не имеет непосредственного отношения, и даже не предназначен для этого).
			Тем не менее, вторичное исключение было добавлено в стэктрэйс первичного. Номера строчек на месте. Так, 
			на вершине стэка вызовов вторичного исключения находится строчка:
			
<pre>
		at MyResource.close(SuppressedExceptionTest.java:16)
</pre>

		<p>
			№16 ведет в строку <code>throw new IllegalStateException("Exception from MyResource.close()");</code> 
			исходника, которая находится в методе <code>close()</code> класса <code>MyResource</code>. Ниже в стэктрэйсе
			идет:
			
<pre>
			at SuppressedExceptionTest.main(SuppressedExceptionTest.java:6)
</pre>

		<p>
			Хм... Строка №6 - это самое начало блока <em>finally</em>. Поскольку блок автоматического закрытия ресурсов
			(названный мною <em>pre-finally</em>) генерируется компилятором, то и номеров строчек исходного текста 
			предоставить компилятор не в силах. Вот и "приписали" к <em>finally</em>.

		<h2>Multiple suppressed exceptions</h2>
		
		<p>
			А могут ли появится в стэктрэйсе несколько исключений? Да пожалуйста! Пример, приведенный в 
			<a href="#listing-9">листинге 9</a>, отлично это демонстрирует:
			
<h4 id="listing-9">Листинг 9 - пример нескольких подавляемых исключений</h4>
<pre>
     1	public class MultipleSuppressedExceptionsTest {
     2		public static void main(String ignored[]) {
     3			try (
     4				MyResource apple = new MyResource("apple");
     5				MyResource banana = new MyResource("banana");
     6				MyResource orange = new MyResource("orange");
     7				MyResource cherry = new MyResource("cherry");
     8			) { 
     9				System.out.println(">>> try-block");
    10				throw new IllegalStateException("Exception from try-block");
    11			} finally {
    12				System.out.println(">>> finally-block");
    13			}
    14		}
    15	}
    16	
    17	class MyResource implements AutoCloseable {
    18		private final String id;
    19		
    20		public MyResource(String id) { this.id = id;}
    21		
    22		@Override
    23		public void close() { 
    24			System.out.println(">>> MyResource [" + id + "] close()"); 
    25			throw new IllegalStateException("Exception from MyResource [" + id + "]");
    26		}
    27	}
</pre>

		<p>
			Запустим пример и увидим:
<pre>
>>> try-block
>>> MyResource [cherry] close()
>>> MyResource [orange] close()
>>> MyResource [banana] close()
>>> MyResource [apple] close()
>>> finally-block
Exception in thread "main" java.lang.IllegalStateException: Exception from try-block
	at MultipleSuppressedExceptionsTest.main(MultipleSuppressedExceptionsTest.java:10)
	Suppressed: java.lang.IllegalStateException: Exception from MyResource [cherry]
		at MyResource.close(MultipleSuppressedExceptionsTest.java:25)
		at MultipleSuppressedExceptionsTest.main(MultipleSuppressedExceptionsTest.java:11)
	Suppressed: java.lang.IllegalStateException: Exception from MyResource [orange]
		at MyResource.close(MultipleSuppressedExceptionsTest.java:25)
		at MultipleSuppressedExceptionsTest.main(MultipleSuppressedExceptionsTest.java:11)
	Suppressed: java.lang.IllegalStateException: Exception from MyResource [banana]
		at MyResource.close(MultipleSuppressedExceptionsTest.java:25)
		at MultipleSuppressedExceptionsTest.main(MultipleSuppressedExceptionsTest.java:11)
	Suppressed: java.lang.IllegalStateException: Exception from MyResource [apple]
		at MyResource.close(MultipleSuppressedExceptionsTest.java:25)
		at MultipleSuppressedExceptionsTest.main(MultipleSuppressedExceptionsTest.java:11)
</pre>

		<p>
			Все осталось на месте и ничего не потерялось. Отлично! Если же закомментировать строчку №10, то на вершине
			стэка вызовов окажется исключение, возникшее при закрытии ресурса, который был иницилизирован последним в 
			TWR, т.е. "вишневое" К сожалению, при таком раскладе часть информации об остальных исключениях 
			("апельсиновое", "банановое", "яблочное") теряется: ни тебе имен методов, ни номеров строчек исходного текста.
			Какие-то вместо них <tt>... 2 more</tt> невнятные.
			Хорошо хоть имена классов и сообщения исключений оставили. Логично, что все они будут относится
			к одному и тому же блоку <em>finally</em>. Но все равно не понимаю такой мелочной экономии.
			
<pre>
>>> try-block
>>> MyResource [cherry] close()
>>> MyResource [orange] close()
>>> MyResource [banana] close()
>>> MyResource [apple] close()
>>> finally-block
Exception in thread "main" java.lang.IllegalStateException: Exception from MyResource [cherry]
	at MyResource.close(MultipleSuppressedExceptionsTest.java:25)
	at MultipleSuppressedExceptionsTest.main(MultipleSuppressedExceptionsTest.java:11)
	Suppressed: java.lang.IllegalStateException: Exception from MyResource [orange]
		... 2 more
	Suppressed: java.lang.IllegalStateException: Exception from MyResource [banana]
		... 2 more
	Suppressed: java.lang.IllegalStateException: Exception from MyResource [apple]
		... 2 more
</pre>
		
		<p>
			Напоследок, попробуем выполнить совершенно безумный пример.
		
		
		<h2>Читайте JLS</h2>
		
		<p>
			Умные книжки не нужны. Ламерские статьи вроде этой - тоже. В спецификации все разложено по полочкам. А вообще, 
			
		
		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>



-----------------------------------------------------------------------------------------------------------------------

============
yura@Aspire-ES1-521 ~/Projects/flaz14.github.io/draft/java-twr/code $ javac -version
javac 1.8.0_111
yura@Aspire-ES1-521 ~/Projects/flaz14.github.io/draft/java-twr/code $ java -version
java version "1.8.0_111"
Java(TM) SE Runtime Environment (build 1.8.0_111-b14)
Java HotSpot(TM) Client VM (build 25.111-b14, mixed mode)
============


- Написать, почему я поставил @Override в интерфейсах. Конечно, глупо переопределять метод в интерфейсе. Ведь реализации
все равно нету. Ее необходимо предоставить в классе. Но аннотация @Override имеет смысл. Потому что поместив в нашем
интерфейсе метод с сигнатурой <code>void close();</code> мы "поглощаем" исключение, объявленное в интерфейсе

java.lang.AutoCloseable:



<pre>
public interface AutoCloseable {
    void close() throws Exception;
}
</pre>

И теперь, указывая в блоке TWR тип переменной как наш интерфейс, мы можем сделать вид, что никакого исключения не ожидается. 
И писать таким образом лямбда-выражения. Хотя в документации к AutoCloseable рекомендуется объявлять более конкретный тип 
исключения в реализации, если, конечно, реализация может выбрасывать проверяемое исключение.