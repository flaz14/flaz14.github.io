<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Еще раз о JOIN</title>
	</head>
	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
		
		<hr>
		
		<h1>
			<a href="http://flaz14.github.io/once-again-about-join/once-again-about-join.html">
				Еще раз о JOIN
			</a>
		</h1>	
		
		<h2>Начнем, пожалуй</h2>
		
		<p>
			В Интернете куча статей про SQL. И про JOIN уже сказано немало. Но все равно, когда читаешь документацию или 
			чьи-то статьи, ничего не понятно. Т.е. вроде бы понятно, но не полностью. Особенно для таких как я, кто 
			знает SQL на уровне <code>SELECT * FROM </code>...
		
		<p>
			В качестве СУБД, на которой будем тренироваться, возьмем 
			<a href="http://www.h2database.com/html/main.html">H2 Database</a>. Эта СУБД хорошо подходит для обучения, 
			по крайней мере, ничего устанавливать не надо (нужно только иметь установленную Java). Итак, скачаем 
			и установим H2:
<pre>
cd /tmp && \
wget 'http://www.h2database.com/h2-2016-10-31.zip' && \
unzip h2-2016-10-31.zip && \
cd h2/bin/ && \
chmod a+x --verbose h2.sh
</pre>	
		
		<p>
			Теперь запустим СУБД:
<pre>
./h2.sh
</pre>
		
		<p>
			В Web-браузере откроется страница как на <a href="#illustration-1">рисунке 1</a>.
			
		<h4>
			<a id="illustration-1">
				Рисунок 1 - подключение к СУБД H2 из Web-браузера
			</a>
		</h4>
		
		<p>
			<img src="illustrations/connect-to-h2-database.png" width="480px"/>

		<p>
			Здесь сразу нажимаем на <strong>Connect</strong>. После чего откроется Web-консоль, изображенная на 
			<a href="#illustration-2">рисунке 2</a>, в которой можно писать запросы и выполнять их.

		<h4>
			<a id="illustration-2">
				Рисунок 2 - общий вид Web-консоли СУБД H2
			</a>
		</h4>			
			
		<p>
			<img src="illustrations/overlook-of-h2-console.png" width="480px"/>
					
		<h2>Придумываем структуру БД</h2>
		
		<p>
			В качестве примера рассмотрим Интернет-магазин. Сейчас полным-полно магазинов, которые всего лишь 
			переправляют товары из Азии в другие страны. Будем хранить сведения о поставщиках в таблице 
			<strong>shops</strong>:
<pre>
CREATE TABLE shops (
	shop_id INTEGER PRIMARY KEY,
	shop_name VARCHAR
);	
</pre>			
			
		<p>
			Для информации о товарах заведем таблицу <strong>products</strong>.
<pre>
CREATE TABLE products (
	product_id INTEGER PRIMARY KEY,
	product_name VARCHAR
);	
</pre>

		<p>
			Теперь сопоставим поставщиков и поставляемые ими товары. Отношение между поставщиками и товарами будет 
			<i>многие-ко-многим</i>. Поле <strong>published</strong> отвечает за наличие/отсутствие товара у поставщика.
<pre>
CREATE TABLE shop_products (
	shop_id INTEGER,
	product_id INTEGER,
	published BOOLEAN,
	FOREIGN KEY (shop_id) REFERENCES shops(shop_id),
	FOREIGN KEY (product_id) REFERENCES products(product_id)
);
</pre>

		<p>
			В результате получилась структура, изображенная на <a href="#illustration-3">рисунке 3</a>.
		
		<h4>
			<a id="illustration-3">
				Рисунок 3 - структура тестовой БД
			</a>
		</h4>			

		<p>
			<img src="illustrations/structure-of-exemplary-database.png" width="640px"/>
	

		<h2>Заполняем БД</h2>
		
		<p>
			Пусть у нас будет 3 магазина (т.е. 3 поставщика из Азии):
<pre>
INSERT INTO shops (shop_id, shop_name) VALUES (1, 'China');
INSERT INTO shops (shop_id, shop_name) VALUES (2, 'Vietnam');
INSERT INTO shops (shop_id, shop_name) VALUES (3, 'Taiwan');
</pre>	
		
		<p>
			Пусть у нас в каталоге будет 3 товара.
<pre>
INSERT INTO products (product_id, product_name) VALUES (1, 'nVidia');
INSERT INTO products (product_id, product_name) VALUES (2, 'AsRock');
INSERT INTO products (product_id, product_name) VALUES (3, 'Asus');
</pre>

		<p>
			Лучше всех стараются китайцы, они производят два продукта: AsRock и Asus. В то время как Вьетнам и Тайвань -
			только по одному. Самый популярный продукт - Asus. Его производят в двух странах: Китай и Вьетнам (это для 
			разнообразия, чтобы было видно, как работает JOIN).
<pre>
INSERT INTO shop_products (shop_id, product_id, published) VALUES (1, 2, TRUE);
INSERT INTO shop_products (shop_id, product_id, published) VALUES (2, 3, FALSE);
INSERT INTO shop_products (shop_id, product_id, published) VALUES (3, 1, TRUE);
INSERT INTO shop_products (shop_id, product_id, published) VALUES (1, 3, TRUE);			
</pre>	
		
		<p>
			Данные в БД изображены на <a href="#illustration-4">рисунке 4</a>.
			
		<h4>
			<a id="illustration-4">
				Рисунок 4 - структура тестовой БД
			</a>
		</h4>			
		<p>
			<img src="illustrations/contents-of-exemplary-database.png" width="320px"/>

		<h2>Выполняем запросы</h2>
		
		<h3 id="example-1">Пример 1</h3>
		
		<p>
				Выберем все возможные комбинации товаров (т.е. все товары всех поставщиков). Будем использовать WHERE 
				для того, чтобы ячейки из разных таблиц не путались (SELECT не умеет сопоставлять результаты). Это
				рабочий подход, но он не очень наглядный. Особенно если критериев WHERE много: какой из них нужен 
				"склеивания" данных из нескольких связанный таблиц, а какой для фильтрации данных по какому-либо полю? 
				Как бы то ни было, результат приведен на рисунке 5.
				
		<h4>
			<a id="illustration-5">
				Рисунок 5 - выборка из нескольких таблиц с использованием критерия WHERE
			</a>
		</h4>			
		<p>
			<img src="illustrations/example-1.png" width="480px"/>
				
		<h4>Пример 2</h4>
		
		<p>
			Сделаем то же самое, что и в <a href="#example-1">примере 1</a>, только с помощью "настоящего" JOIN. В 
			запросе явно сказано: взять все строки из таблицы <code>products</code>, затем каждую строку из таблицы 
			<code>products</code> сопоставить с каждой строкой из таблицы <code>shop_products</code> (а именно 
			сопоставить поля <code>product_id</code>). Как видно из рисунка 6, результаты получились такими же, как и на 
			рисунке 5.
			
		<h4>
			<a id="illustration-6">
				Рисунок 6 - выборка из нескольких таблиц с использованием оператора JOIN
			</a>
		</h4>			
		<p>
			<img src="illustrations/example-2.png" width="480px"/>
			
		<h4>Пример 3</h4>
		
		<p>
			Этот пример - усложненная версия примера 2. Выберем все возможные товары, но только те, что есть в наличии.
			Работает это так:
			<ol>
				<li>
					Берем все строки из таблицы <code>products</code>.
					
				<li>
					К каждой из выбранных на шаге 1 строк "приклеиваем" строку из таблицы 
					<code>shop_products</code>, но "склеиваем" только те строки, у которых одинаковые значения поля
					<code>product_id</code>. На этом этапе получается таблица из 4 строк и 5 столбцов (столбец 
					<code>product_id</code> встречается в двух изначальных таблицах, но после <code>JOIN</code> 
					остается один экземпляр).
					
				<li>
					Из того, что получилось на шаге 2, выбираем только те строки, в которых поле 
					<code>published</code> равно <code>TRUE</code>.
			</ol>
		
		Результат приведен на рисунке 7.
		<h4>
			<a id="illustration-7">
				Рисунок 7 - использование JOIN и WHERE
			</a>
		</h4>			
		<p>
			<img src="illustrations/example-3.png" width="480px"/>			
			
		<h4>Пример 4</h4>
		<p>
			Попробуем сделать то же самое, что и в примере 3, но без <code>JOIN</code>. В результаты получится таблица
			из 9 строк и 6 столбцов (см. рисунок 8). Почему 9 строк? Потому что, если не задействован <code>JOIN</code> 
			(или <code>WHERE table_a.id = table_b.id</code>), результат будет произведением 1-ой таблицы на 2-ую (такое
			произведение как-то по-умному называется, но я уже не помню, главное что в результате получатся все 
			сочетания без ограничений по ключам, т.е. "каждый с каждым". Работает это так:
			<ol>
				<li>
					Две таблицы перемножаются. Результат произведения - таблица из 12 строк и 6 столбцов (т.е. 12 = 3 x 4, 
					ведь в таблицу <code>products</code> мы вставили 3 записи, а в таблицу <code>shop_products</code> - 
					4 записи):
					<p>
						<img src="illustrations/example-3-a.png" width="480px"/>	
				
				<li>
					Из получившейся на шаге 1 таблицы остются только те строки, у которых поле <code>published</code>
					равно <code>TRUE</code>.
					<p>
						<img src="illustrations/example-3-b.png" width="480px"/>	

			</ol>
		Тут еще можно заметить, что в результате получилась таблица из 6 столбцов, т.е. столбец встречается дважды...
		
		<h2>Выводы</h2>
		
		<code>JOIN</code> необходим. Если в БД таблицы связаны по ключам, то без JOIN не обойтись. Впрочем, если 
		"наивный" запрос (т.е. заведомо ошибочный) сразу проявит себя: представьте, что таблица A связана с Таблицей B, 
		которая в свою очередь связана с таблицей C. Если в каждой из таблиц несколько тысяч записей, "наивный" запрос 
		зависнет надолго.
		
		<p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Сноска 1.

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 
						Сноска 2.
						
				<li id="footnote-3-bottom">
					<p>
						<a href="#footnote-3-top" title="Перейти к основному тексту">&uarr;</a> 
						Сноска 3.
			</ol>
			
		<hr>
		
		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
