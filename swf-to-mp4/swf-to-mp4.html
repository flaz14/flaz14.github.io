<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Преобразование SWF в MP4 - это просто!</title>
	</head>
	<body>
		<h1>
			<big>
				<a href="/#swf-to-mp4" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
		
		<hr>
		
		<h1>
			<a href="http://flaz14.github.io/swf-to-mp4/swf-to-mp4.html">
				Преобразование SWF в MP4 - это просто!
			</a>
		</h1>
		
		<h3>[2017, Апрель]</h3>
		
		<h3>
			<a href="https://github.com/flaz14/flaz14.github.io/tree/master/swf-to-mp4/video">Примеры видео</a>
			|
			<a href="https://github.com/flaz14/flaz14.github.io/tree/master/swf-to-mp4/code">Исходный код</a>

		</h3>
		
		<h2>Adobe Flash уходит в прошлое</h2>
			
		<p>
			Когда-то Adobe Flash был очень распространен. И он до сих пор используется, хотя популярные сервисы 
			официально "похоронили" его. Тем не менее, Adobe Flash - это больше, чем видео и анимация. Flash-ролик - это 
			программа, которая выполняется внутри flash-плеера, а иногда сама содержит плеер. Вроде бы можно все это 
			программировать с использованием языка ActionScript...
			
		<h2>Реальный случай</h2>
		
		<p>
			Как-то раз на работе мне пришлось выполнять задачу по расследованию таинственной ошибки в корпоративном 
			приложении. Обнаружил ошибку и сообщил о ней пользователь. И не просто написал отчет, а приложил к нему 
			видеоролик, в котором ее продемонстрировал. Это было круто. Расстраивал только формат видео - SWF. Да, можно
			смотреть его в браузере (не забыв предварительно активировать соответствующий плагин) или в самостоятельном 
			плеере (например, <a href="https://www.gnu.org/software/gnash/">GNU Gnash</a>). Но возможности этих плееров 
			ограничены по сравнению с "обычными", такими как <a href="http://www.videolan.org/vlc/">VLC</a>. Например, 
			в <em>VLC</em> можно перематывать видео на 10 секунд назад/вперед и выполнять множество других действий, без 
			которых изучение содержания видеоролика весьма затруднительно (тем более, что все можно проделывать с 
			помощью "горячих" клавиш). 
			
		<h2>Ролики бывают разные</h2>
		
		<p>
			Преобразовать SWF в MP4 можно без особых усилий, достаточно лишь прочитать ответ на вопрос
			<a href="http://stackoverflow.com/questions/20194270/convert-compressed-swf-to-mp4">
				Convert compressed swf to mp4</a>.
			Но не все так безоблачно. Рассмотрим простой SWF-файл. "Простой" в данном случае означает, что в файле нет 
			ничего, кроме видео. Т.е. достаточно запустить его в <em>Gnash</em> такой командой: 
<pre>
$ gnash simple.swf
</pre>	
		<p>
			И ролик сразу начнет проигрываться (в "простом" ролике - реклама приставки Nintendo; взят он с сайта,
			на котором много тестовых роликов: <a href="http://samples.mplayerhq.hu/SWF/">samples.mplayerhq.hu</a>). 
			Интересно, что после того, как ролик дойдет до конца (появится логотип компании), ролик будет раз за разом 
			проигрываться с самого начала. Чтобы предотвратить этот побочный эффект (непонятно, то ли это SWF-файл 
			"косячный", то ли это особенность <em>Gnash</em>), достаточно добавить параметр <code>--once</code>, т.е.: 
<pre>
$ gnash --once simple.swf	
</pre>
		<p>
			Как бы то ни было, можно без лишних подготовок задействовать утилиту <em>dump-gnash</em> и получить на 
			выходе RAW-видео, которое затем можно преобразовать в MP4.
			
		<p>
			Но есть и нетривиальные SWF-файлы. Свой "сложный" ролик я записал с помощью программы 
			<a href="https://www.techsmith.com/jing.html">Jing</a> (видео, записанные с помощью Jing, довольно 
			распространены на популярном сайте <a href="http://www.screencast.com/">screencast.com</a>). В чем же 
			сложность этого SWF-файла? В том, что это не просто видео, это видео и плеер в одном флаконе. Так, если 
			открыть файл в <em>Gnash</em> (<code>$ gnash tricky.swf</code>), то появится затененный кадр с кнопкой 
			<b>Play</b>, как показано на <a href="#illustration-1">рисунке 1</a>.
			
		<h4 id="illustration-1">Рисунок 1 - "сложный" SWF-файл, открытый в <em>Gnash</em></h4>
		<p>
			<img src="illustrations/tricky-swf-first-impression.png" width="640px"
			alt='Это скриншот плеера Gnash. На нем видно, что изначально изображение "висит" на первом кадре, и этот 
			кадр затенен. А поверх него отображается кнопка Play. Она не имеет отношения к Gnash, а является частью 
			flash-ролика.'>
		
		<p>
			Очевидно, что преобразовать такой файл в MP4 способом, указанным выше, не получится. Потому что для начала 
			реального проигрывания видео необходимо щелкнуть по затененному кадру левой клавишей мыши (пункт меню 
			<b>Movie Control</b> &rarr; <b>Play</b> в <em>Gnash</em> не помогает, равно как и всевозможные параметры 
			командной строки). Без щелчка видео будет бесконечно "висеть" на одном кадре. А соответствующий RAW-файл 
			разрастется до невероятных размеров (собственно, я это сразу заметил, потому что мой рабочий компьютер 
			завис: я же писал RAW-файл в <i>/tmp</i>, а каталог <i>/tmp</i> был смонтирован как <em>tmpfs</em>).
			
		<p>
			Щелкнем по кнопке <b>Play</b>. Ничего удивительного: мы видим, что в SWF-файле есть свой плеер со своими 
			собственными элементами управления (см. <a href="#illustration-2">рисунок 2</a>).
		
		<h4 id="illustration-2">Рисунок 2 - "сложный" SWF-файл содержит собственный плеер</h4>
		<p>
			<img src="illustrations/tricky-swf-has-its-own-player.png" width="640px"
			alt="Это скриншот плеера Gnash. На нем видно, что у загруженного ролика есть собственные элементы 
			управления, такие как кнопка Pause/Play, полоса прогресса, регулятор громкости, кнопка переключения 
			полноэкранного режима.">
		
		<p>
			Деваться некуда, придеться делать костыли...
			
		<h2>Нам помогут <em>X virtual framebuffer</em> и все-все-все</h2>
		
		<p>
			Поступим просто: будем открывать ролик в <em>Gnash</em> на отдельном виртуальном экране, щелкать 
			по затененной области посредством <a href="http://www.semicomplete.com/projects/xdotool">xdotool</a>
			и записывать происходящее с помощью <a href="https://ffmpeg.org">FFmpeg</a>. Впрочем, об этом подходе 
			<b>Rafał Malinowski</b> уже рассказал в статье 
			<a href="http://afterdesign.net/2016/02/07/recording-headless-selenium-tests-to-mp4.html">
				Recording headless selenium tests to mp4 with Xvfb and ffmpeg</a>. Так что добавим лишь парочку деталей.
			
		<h2>Исследуем SWF-файл</h2>
		
		<p>
			Перво-наперво, узнаем действительные размеры видео. Для этого воспользуемся программой <em>swfdump</em> из 
			пакета <a href="http://www.swftools.org/">SWFTools</a>:
<pre>
$ swfdump --width --height tricky.swf 
-X 677 -Y 342
</pre>

		<p>
			Также есть смысл заранее узнать, с какой скоростью проигрывается оригинальный ролик: нет смысла записывать 
			на скорости 60 FPS, когда оригинальный ролик проигрывается на скорости 10 FPS:
<pre>
$ swfdump --rate tricky.swf 
-r 10.00
</pre>
		
		<h2>Воспроизводим и захватываем видео</h2>
		
		<p>
			Пожалуй, самая полезная опция <em>Gnash</em> - это <code>--fullscreen</code>. Она позволяет растянуть 
			картинку на весь экран, при этом рамка окна и панель меню не отображаются. К сожалению, на деле все плохо. 
			Посмотрим на <a href="#illustration-3">рисунок 3</a> и увидим, что применение <code>--fullscreen</code> в 
			сочетании с <em>Xvfb</em> приводит к плачевному результату:	окно <em>Gnash</em> отображается в виде 
			крошечного прямоугольника.
			
		<h4 id="illustration-3">
			Рисунок 3 - странное поведение <em>Gnash</em> при использовании опции <code>--fullscreen</code>
		</h4>
		<p>
			<img src="illustrations/gnash-xvfb-small-window.png" width="640px"
			alt="Это снимок виртуального экрана, сделанный при помощи утилиты 'xwud' (за подробностями обращайтесь к
			'man Xvfb')">
		
		<p>
			При этом в случае с "настоящим" экраном проблема не наблюдается. Так что придеться задействовать параметры
			<code>--hide-menubar</code>, <code>--x-pos</code> и <code>--y-pos</code> (будут установлены в нoль). А также 
			<code>--width</code> и <code>--height</code> (очевидно, они будут равны уже известной ширине и высоте 
			изображения в исходном файле).
                        
		<p>
			Здесь, правда, не все так радужно. Потому что скрытие строки меню и явное указание размеров изображения не 
			отменяет наличия рамки вокруг окна <em>Gnash</em> (как и любого другого приложения, работающего в среде 
			<strong>X</strong>). К счастью, виртуальный экран запускается с параметрами по умолчанию, которые настроены 
			на "безрамочное" отображение окон. По крайней мере, в дистрибутиве <b>LinuxMint 17.1 Cinnamon</b>. Хотя в 
			других дистрибутивах эти умолчания могут быть другими.
			
		<p>
			Следующая задача - это щелчок мышью по упомянутой выше кнопке <b>Play</b>. Щелкать именно по кнопке не 
			обязательно. Щелчка по любой точке затенной области достаточно для того, чтобы воспроизведение видео 
			реально началось. <em>xdotool</em> позволяет делать такие вещи в два счета: переместить курсор в нужную 
			позицию и сымитировать щелчок левой клавишей. Указатель мыши, конечно же, нужно спрятать. Тем более, что в 
			моем случае он имеет вид крестика (замечательные умолчания снова в действии), и он довольно заметен. 
			Призовем на помощь утилиту <a href="https://wiki.archlinux.org/index.php/unclutter">Unclutter</a> 
			(официальный сайт не удалось найти, так что даю ссылку на ArchWiki). Сокрытие достигается путем установки 
			времени бездействия в ноль, т.е. курсор тут же прячется, не успев появиться.
		
		<p>
			С <em>Unclutter</em> есть небольшой нюанс. Так, в <b>LinuxMint 17.1 Cinnamon</b> (скорее всего, в 
			<b>Ubuntu</b> тоже) после установки <em>Unclutter</em> (<code>$ sudo apt-get install unclutter</code>) и 
			последующего перезапуска X-сервера (например, после выключения компьютера) курсор мыши постоянно пропадает с 
			экрана после пятисекундного бездействия. Оказывается, автоматический запуск <em>Unclutter</em> настроен по 
			умолчанию. Взглянем на соответствующий файл настроек <i>/etc/default/unclutter</i>:
<pre>
# /etc/default/unclutter - configuration file for unclutter

# Set this option to 'true' if you want to start unclutter
# automagically after X has been started for a user.
# Otherwise, set it to 'false'.
START_UNCLUTTER="true"
...
</pre>
		<p>
			С ним все ясно: просто меняем <code>true</code> на <code>false</code>.
		
		<p>
			В целом алгоритм выглядит так:
			<ol>
				<li>
					Запускаем <em>Xvfb</em>.
					
				<li>
					Запускаем <em>Gnash</em>.
					
				<li>
					Запускаем <em>FFmpeg</em> и начинаем захватывать видео.
					
				<li>
					Прячем указатель мыши и имитируем щелчок по кнопке <b>Play</b>.
					
				<li>
					Ждем, пока проигрывание SWF-файла не завершится.
				
				<li>
					Вежливо останавливаем <em>FFmpeg</em> (чтобы на выходе не получился поврежденный MP4-файл).
			</ol>
			
		<p>
			Очевидно, что после запуска <em>Xvfb</em> нужно немного подождать, прежде чем запускать <em>Gnash</em>. А 
			перед тем, как начинать	захват видео с виртуального экрана, нужно, в свою очередь, подождать, пока 
			<em>Gnash</em> полность проинициализируется. В принципе, ждать готовности <em>Xvfb</em> нет необходимости: 
			можно просто "пинговать" виртуальный экран каждую секунду. Но в случае с <em>Gnash</em> подобный трюк не 
			пройдет: <em>Gnash</em> никак не сообщает о своей готовности к работе (наличие соответствующего PID'а в 
			списке процессов - не в счет, потому что PID может присутствовать, но программа может быть еще не готова к 
			выполненю работы). Так что просто подождем. Я жду десять секунд, чтобы уж наверняка не было глюков. 
			Возможно, пяти секунд будет достаточно...
			
		<h2>Костыльный код и костыльные результаты</h2>
		
		<p>
			Вышеописанный алгоритм реализован на Python. Получилось то, что 
			<a href="https://github.com/flaz14/flaz14.github.io/blob/master/swf-to-mp4/code/swf-to-mp4.py">
				получилось</a> :) Запустим скрипт:
<pre>
$ ./swf-to-mp4.py ../video/tricky.swf /tmp/tricky.mp4
</pre>			

		<p>
			<a href="https://github.com/flaz14/flaz14.github.io/blob/master/swf-to-mp4/video/tricky.mp4">
				tricky.mp4</a> - это и есть результат преобразования (76 КБайт всего лишь).
		
		<p>
			Побочные эффекты:
			<ol>
				<li>
					Как уже говорилось выше, задержки, необходимые для надежной работы скрипта, проявляются и в 
					результирующем MP4-файле. В принципе, подобрать оптимальные отрезки времени для кокретного 
					компьютера можно. Тем не менее, полностью избавиться от них нельзя (а всякие последующие правки MP4 
					в видеоредакторе вгоняют в тоску).
					
				<li>
					Скрипт очень хрупкий, особенно в плане отображения рамок окон. Да, в <b>LinuxMint 17.1 Cinnamon</b> 
					все отлично: рамки вокруг окна <em>Gnash</em> отсутствуют. Но в другом дистрибутиве все может быть 
					по-другому (я сомневаюсь, что скрипт вообще запустится на другом дистрибутиве).
					
				<li>
					Элементы управления встроенного в SWF-файл плеера видны в получившемся MP4-файле (правда, они 
					пропадают через некоторое время). Эту удручающую картину мы уже видели на 
					<a href="#illustration-2">рисунке 2</a>.
			</ol>
		
		<p>
			И наконец, самый большой недостаток - это звук. В моем случае звук был не нужен: его не было в оригинальном 
			ролике. Но в реальности звук может понадобиться. Как в этом случае его записывать? Проделать ли	некоторые 
			трюки с PulseAudio/AlsaMixer/etc? Или задействовать вторую звуковую карту (USB, например)? Или отдельно 
			записать видео,	отдельно - звук, а затем свести их воедино? Или вообще декомпилировать SWF-файл, убрать все 
			ненужное, вытянуть звук и т.д.? Непонятно...
		
		<hr>
		
		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>
