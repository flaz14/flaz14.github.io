<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>InnerClasses + JUnit = CleanCode</title>
	</head>
	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
		
		<hr>
		
		<h1>
			<a href="http://flaz14.github.io/inner-classes-and-junit/inner-classes-and-junit.html">
				InnerClasses + JUnit = CleanCode
			</a>
		</h1>
		
		<h3>[2017, Март]</h3>
		
		<p>
			Я не сильно люблю тесты, но делаю ТDD. Начинаю с самого простого, что может быть в классе - конструктора. И 
			по мере дополнения класса появляются новые тестовые методы. Каждый тестовый метод выглядит примерно так (это
			не я придумал, так сказано в Code Style компании):
			
			названиеМетодаКоторыйНужноПроверить_делаетЧтоТо_когдаВыполняетсяКакоеЛибоУсловие
			
			И называется такой стиль Expressive Tests (по-моему, очень даже хороший стиль).
			
		<p>
			Пусть нам нужно реализовать самый обычный service-класс. На класс будут возложены задачи создания объектов, 
			их сохранения в БД, чтения по ID и т.п. Для простоты будем считать, что у нас есть два метода: create и read.
			Нужно сделать тесты для них.
			
		<p>
			Поначалу я организовывал тесты таким образом: 
			Создавал пакет имяКласса + 'Test' (т.е. CustomerServiceTest ), а в нем для каждого тестируемого метода создавал класс
			следующего вида: имяКласса + '_' + имяМетода + 'Test' (например, CustomerService_createTest). А уже в каждом классе
			создавал методы (для каждого сценария) с именами: делаетЧтоТо_когдаВыполняетсяКакоеЛибоУсловие.
			Например, в тесте для метода create() (CustomerService_createTest) будут такие методы:
			
			happyPath()
			throwsException_whenUnderlyingLayerIsNotAvailable()
			
			Преимущества такого подхода перед изложенным в Code Style:
			
			1. Каждый тестируемый метод тестируется в изоляции от остальных. Это уменьшает вероятность ошибок и случайного
			влияния одних тестов на другие.
			
			2. Найти требуемый тестовый сценарий намного проще - сценарии не свалены в одну кучу, а разбиты на группы.
			
			2. В именах тестовых методов не нужно дублировать название тестируемого метода. Потому что оно отражено в название
			тестового класса.
			
			Недостатки тоже есть:
			
			1. Нестандарное название классов и пакетов. Вообще-то для тестов названия не так критичны. Но необычные названия
			нарушают общепринятые в Java соглашения. Что многим не нравиться.
			
			2. Дублирование в именах: только повторяются не названия тестируемых методов, а название тестируемого класса.
			
			Поэтому я задался вопросом организации тестов. Теорию мне читать не пришлось. На Stackoverflow
			нашелся готовый ответ: 
			<a href="http://stackoverflow.com/questions/8758294/test-cases-in-inner-classes-with-junit">
				Test cases in inner classes with JUnit</a>. 
			Собственно, на основании того поста и написана эта статья. Я лишь попытался систематизировать разные подходы
			и сказать о достоинствах и недостатках каждого из них.
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			Здесь "отключить" означает настроить PolicyKit таким образом, чтобы с его помощью нельзя было выполнять 
			административные задачи. Например, удалять пакеты посредством Synaptic (команда 
			<code>synaptic-pkexec</code>) или форматировать диски с помощью GParted (команда 
			<code>gparted-pkexec</code>). Но при этом должна остаться возможность выключать компьютер, менять настройки 
			сетевых подключений и выполнять другие действия, для которых по умолчанию никакие пароли не требуются.
		
		<p>
			Удалить PolicyKit в Linux Mint нельзя (от него зависит пакет <strong>cinnamon</strong> и многие другие). Но,
			даже если бы PolicyKit можно было удалить, появилась бы куча проблем: разрешения на выключение компьютера и 
			прочие действия пришлось бы настраивать заново (или с помощью SUID битов, или допиливанием PAM, или 
			каким-нибудь другим образом, ведь старые дистрибутивы обходились без PolicyKit, когда его еще не было).
		
		<p>
			У PolicyKit есть "действия", "правила" и т.д. Каждому такому понятию соответствуют свои конфиги. Например, 
			для "действий" есть <i>/usr/share/polkit-1/actions/</i>. Казалось бы, достаточно удалить ненужные файлы. Но 
			они могут создаваться при установке программ (тот же GParted) и при обновлении дистрибутива. Кроме того, с 
			первого раза не так просто разобраться в этом ворохе конфигов. Для "правил" есть 
			<i>/usr/share/polkit-1/rules.d/</i>, но и там темный лес.
		
		<p>
			А вот конфиги в <i>/etc</i> - именно то, что нужно 
			<sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>. Итак:
			<ol>
				<li>
					Создаем фиктивную группу <strong>mypolkit</strong>:
					<p>
						<code>sudo addgroup mypolkit</code>

				<li>
					Правим файл <i>/etc/polkit-1/localauthority.conf.d/51-ubuntu-admin.conf</i> (в нем нет 
					предупреждений вроде <tt>DO NOT EDIT THIS FILE, it will be overwritten on update.</tt>). Не забываем
					предварительно сделать его бэкап, но только не в этот же каталог, а в другой, например, 
					<i>/backups</i>, иначе файл-бэкап будет воспринят как еще один конфиг. Отредактированный конфиг
					должен выглядеть так:
<p>
<pre>
[Configuration]
AdminIdentities=unix-group:mypolkit
</pre>	
			</ol>
			
		<p>
			В итоге PolicyKit будет запрашивать пароль не вызвавшего его пользователя, а пароль <strong>root</strong>.
			Но, поскольку пользователя <strong>root</strong> в Ubuntu (а следовательно, и в Linux Mint) нет, то, какой 
			пароль ни вводи, он не подойдет 
			<sup id="footnote-2-top"><a href="#footnote-2-bottom">[2]</a></sup> 
			<sup id="footnote-3-top"><a href="#footnote-3-bottom">[3]</a></sup>.
			<p>
				<img src="policy-kit-enter-password-window.png" width="480px"
				alt="здесь изображен скриншот окна PolicyKit для ввода пароля">
		
		<p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Для большей уверенности можно удалить и конфиг <i>/etc/pam.d/polkit-1</i>. Но, как выяснилось, 
						наличие/отсутствие этого конфига не влияет на запрашиваемый PolicyKit пароль. Так что лучше 
						оставить.

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 
						После описанных выше манипуляций нельзя будет изменить системное время из апплета на панели 
						задач. Но это не проблема: запускаем <code>gksudo cinnamon-settings</code> и меняем что душе 
						угодно (правда, тут надо быть осторожным, чтобы не испортить другие настройки).
						
				<li id="footnote-3-bottom">
					<p>
						<a href="#footnote-3-top" title="Перейти к основному тексту">&uarr;</a> 
						Если в системе все-таки есть пользователь <strong>root</strong> (т.е. если он был добавлен 
						вручную), нужно установить для него сложный (лучше - "невзламываемый", длиной около 50 случайных
						символов) пароль.
			</ol>
			
		<hr>
		
		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
