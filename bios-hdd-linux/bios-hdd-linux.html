<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Настройка BIOS и подготовка HDD перед установкой LinuxMint</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/bios-hdd-linux/bios-hdd-linux.html">
				Настройка BIOS и подготовка HDD перед установкой LinuxMint
			</a>
		</h1>
		
		<h3>[2017, Ноябрь]</h3>
		
		<h2>Когда-то...</h2>
		
		<p>
			Про BIOS и тонкую настройку ПК уже написано огромное количество статей и книг. В эпоху Windows XP 
			повсеместно встречались душевно и старательно составленные CHM-файлы со всякого рода FAQ, сборниками статей 
			и т.д. К примеру, на моем винчестере как-то оказался EXE-файл, который в действительности представлял собой 
			руководство по оптимизации и разгону Windows XP. Автор боролся за каждый мегабайт оперативной и дисковой 
			памяти. Конечно, некоторые его методы оптимизации не вызывают восторга сейчас, в свете накопленного опыта 
			использования ПК. Например, полное отключение графических эффектов приводит к тому, что глаза, стараясь 
			различить сплошь серые элементы управления, утомляются быстрее, чем при наличии мягких теней, градиентов и 
			т.п. Пренебрежение разграничением доступа (а именно: ежедневная работа с правами администратора вместо 
			использования ограниченной учетной записи) тоже ни к чему хорошему не приводит (а фраза была примерной 
			такой: "Сделаем так, чтобы экран приветствия пропускался, ведь пользователь в системе один-одинёшенек"). 
			Но что касается освобождения 50 МБ, занимаемых на диске ненужными экранными заставками - это и сейчас круто.
		
		<p>
			В этой ламерской статье я постараюсь выразить свое видение подготовки рабочей станции перед установкой 
			Linux.
		
		<h2>BIOS</h2>
		
		<p>
			В BIOS много чего можно настроить. Или много чего нельзя. Так, в современных дешевых ноутбуках в BIOS даже 
			нельзя выключить Bluetooth и Wi-Fi (подразумевается, что заботу о них возьмет на себя ОС). Главное, что 
			нужно сделать с BIOS на первых порах - включить режим <strong>AHCI</strong> для жесткого диска (для 
			SATA-диска, естественно). Хотя этот режим может быть включен по-умолчанию (в современных компьютерах дело 
			обстоит именно так). В статье  
			<a href="http://forums.crucial.com/t5/Crucial-SSDs/Why-do-i-need-AHCI-with-a-SSD-Drive-Guide-Here-Crucial-AHCI-vs/td-p/57078">
				Why do i need AHCI with a SSD Drive (Guide Here!) Crucial AHCI vs IDE</a> все популярно объясняется.
		
		<p>
			Второй важный момент: перед установкой Linux следует включить в BIOS все возможные периферийные устройства. 
			Это нужно для того, чтобы программа установки Linux обнаружила устройства и установила необходимые драйверы.
			Отключить невостребованные устройства в BIOS позднее несложно. А вот установить драйверы для Wi-Fi-адаптера
			потруднее будет (особенно, если нет способа выйти в Интернет не прибегая к Wi-Fi; да чего уж говорить, во 
			многих современных ноутбуках разъема Ethernet нету).

		<p>
			Не стоит запирать BIOS паролем первое время. Пароль всегда можно задать позже. Восстановить же забытый 
			пароль - морока, особенно в случае с ноутбуком. Придется его разбирать, искать контакты (перемычек в 
			портативных компьютерах нету) или батарейку. Не очень приятное занятие (и рискованное - современная техника 
			делается с минимальным заделом на разборку-сборку). А если ноутбук на гарантии, забот прибавляется. Везти в 
			сервисный центр, чтобы не пропала гарантия, и платить за это - ну его нафиг.
			
		<p>
			Также не стоит заморачиваться по поводу шифрования. Нет, шифровать домашнию директорию или даже весь жесткий
			диск нужно (об этом идет речь <a href="#encryption-note">ниже</a>). А вот включать аппаратное шифрование 
			винчестера не стоит. Потерянные пароли не восстанавливаются. В случае же с программным шифрованием забытый 
			пароль все же можно восстановить: зная большую часть пароля возможно подобрать оставшуюся за приемлимое 
			время.
		
		<h2>HDD</h2>
		
		<p>
			Часто в Интернете можно встретить устаревшие рекомендации по ускорению жесткого диска. Вот основные из них.
		
		<h4>Системный раздел (он же /) должен быть небольшого размера.</h4> 
		
		<p>
			Неизвестно, откуда берет начало эта традиция. Может, с простой аналогии, что в маленьком стоге сена иголку 
			(то бишь одиночный файл) найти проще, чем в большом? Логично. Так оно и было во времена DOS (тогда все файлы
			были небольшими). Система, будучи установленной на жестком диске, со всеми драйверами, прикладными 
			программами и т.д. занимала 50 МБ от силы. И файлы по-большей части оставались неизменными. Программы тогда 
			обновлялись редко и вручную. Плюс еще сама архитектура DOS: каждой программе - свой каталог. В нем хранятся 
			и исполняемые файлы, и настройки, и вспомогательные модули. Другое дело *nix: файлы, принадлежащие одной и 
			той же программе, размазаны по всему диску. Так что маленький системный раздел ничем не поможет 
			<a id="defragmentation-note"></a>
			(и дефрагментация принципиально бессмысленна: как диск ни дефрагментируй, не получиться собрать рядом файлы,
			принадлежащие одной программе, ведь программа дефрагментации "видит" только файлы и каталоги, но не 
			программы).
		
		<p>
			Наоборот, чем больше свободного места на разделе - тем лучше. У файловой системы появляется больше 
			возможностей для выбора. Файловая система рассуждает примерно так: "Есть большой кусок непрерывного 
			свободного пространства - отлично, запишем туда увесистый файл. А маленькие промежутки заполним крошечными 
			файлами". Косвенно этот тезис подтверждает Windows: там для успешной дефрагментации требовалось не менее 15%
			свободного места на диске. Возможно, это было вызвано ограничениями реализации штатного дефрагментатора. В 
			самом деле, почему не 10%, а именно 15%? Но рациональное зерно здесь есть...
			
		<p>
			<b>Вывод:</b> если планируется использовать 20 ГБ для системы (а примерно столько требуется LinuxMint с 
			Cinnamon), то лучше создать раздел минимум на 40 ГБ.
		
		<h4>Расположение раздела на диске играет роль.</h4>
		
		<p>
			На самом деле нет. Давным-давно кластеры на диске были одинаковые (в угловых координатах). Из-за этого они 
			были неодинаковые в декартовых координатах - на краю диска кластеры получались большего размера, чем в 
			начале (ведь диаметр внешней окружности больше внутренней). Т.o. данные с края диска читались, при прочих 
			равных условиях, медленнее, чем из начала или из середины. В современных дисках кластеры имеют одинаковый 
			размер. Следовательно, они равномерно распределены по поверхности диска. В любом его месте плотность записи 
			одинаковая. Теперь получается наоборот - лучше создавать раздел в конце диска, поскольку линейная скорость 
			на краю больше, чем в начале.
			
		<p>
			По поводу физического расположения раздела на винчестере переживать не нужно. Нет никакой гарантии, что 
			отсчет кластеров начинается с начала диска. Возможно, отсчет начинается как раз с края. Кроме этого, нет 
			гарантии, что выделенный нами раздел займет непрерывную область на поверхности одной пластины. Пусть мы 
			создадим раздел, скажем, на 300 ГБ, начиная с начала диска. Может случиться так, что реально он начнется на 
			диске с его края, при этом 280 ГБ найдут пристанище на поверхности одной пластины, а кусочек объемом 20 ГБ 
			попадет на другую пластину. Предсказать это очень трудно. 
		
		<p>
			Дело в том, что даже в рамках одной серии жестких дисков конкретные экземпляры могут сильно отличаться. К 
			примеру, хотел производитель X сделать диск на 1 ТБ. В результате из всей партии 10% винчестеров оказались 
			глючными. Разобрать и переделать - долго и дорого. Объявить их хламом - тоже невыгодно. Вот и начинают 
			"чинить" такие диски модификацией прошивки. Отключили одну пластину - и вместо диска на 1 ТБ получился диск 
			на 500 ГБ. Такой диск уже можно продать, разместив его в соответствующем ценовом сегменте. Ситуация может 
			быть даже хуже: зоны, скажем так, неуверенного чтения/записи (предположим, коромысло головки деформировалось
			немного при сборке), могут быть исключены из обращения на уровне прошивки. Тут уж как ни старайся, но 
			создать непрерывный раздел вряд ли получиться (конечно, у дорогих моделей, которые закупают серьезные 
			организации, в этом плане все хорошо).
		
		<p>
			<b>Вывод:</b> танцевать с бубном вокруг геометрии жесткого диска - пустое дело. Вместо этого лучше уделить 
			внимание простой и понятной разметке. Например, разбить диск так, чтобы программы вроде 
			<strong>fdisk</strong> показывали только "круглые" числа. Тогда и восстановить таблицу разделов можно будет 
			по памяти, не прибегая ко всякого рода утилитам и/или тетрадным записям.

		<h2>Еще пара слов о дефрагментации</h2>
		
		<p>
			Дефрагментация в Linux не нужна. Большие файлы (такие как фильмы) дефрагментировать смысла нет. Когда вы 
			смотрите фильм, соотвествующий файл читается с диска небольшими порциями. Так что даже если реально он 
			хранится как пять-шесть кусков на диске, на скорости воспроизведения это никак не скажется (но на файловом 
			сервере при большом количестве запросов разница, я думаю, будет заметной). Дефрагментация на уровне 
			приложений невозможна в принципе (об этом уже говорилось <a href="#defragmentation-note">выше</a>). 
			
		<p>
			Есть еще один нюанс. Современное приложение, например, Web-браузер, - это не просто программа, это 
			операционная система внутри "настоящей" ОС (вспомним хотя бы т.н. дополнения к браузеру - чем не близнецы 
			традиционных приложений?). Всякого рода временными файлами, кэшами и т.п. Web-браузер занимается 
			самостоятельно. ОС вообще не в курсе происходящего. Дефрагментация в этом случае ничем не поможет.
			
		<h2 id="encryption-note">О шифровании на уровне ОС</h2>	
		
		<p>
			В популярных дистрибутивах шифрование домашнего каталога 
			(<a href="https://wiki.archlinux.org/index.php/ECryptfs_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">eCryptfs</a>
			или 
			<a href="https://habrahabr.ru/post/327682/">шифрование в EXT4</a>) 
			и даже всего диска 
			(<a href="https://ru.wikipedia.org/wiki/LUKS">LUKS</a>) 
			доступны "из коробки". Такие готовые решения, тем не менее, оставляют на диске незашифрованные разделы 
			(нужно ведь загрузить для начала хоть-что, хоть какой-нибудь код, который поможет начать расшифровку файлов,
			необходимых для загрузки ОС). В	LinuxMint это раздел, который монтируется в каталог <strong>/boot</strong>. 
			Этот раздел имеет небольшой размер (примерно 200 МБ), форматируется он в файловую систему <em>ext2</em>. 
			С одной стороны, отсутствие журналирования уменьшает износ диска. С другой, увеличивает шансы на 
			порчу данных в случае аппаратного сбоя. А шифрование этого раздела только усугубит ситуацию (теоретически)
			<sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>.
		
		<p>	
			В принципе, зашифровать <strong>/boot</strong> возможно: 
			<a href="http://www.pavelkogan.com/2014/05/23/luks-full-disk-encryption/">
				Full disk encryption with LUKS (including /boot)</a>. 
			Только в начале загрузки придеться вводить ключ рассшифровки два раза
			<sup id="footnote-2-top"><a href="#footnote-2-bottom">[2]</a></sup>.
			
		<p>
			Еще один момент: по-умолчанию установщик LinuxMint (при выборе опции 
			<em>Erase disk and install Linux Mint</em> создает один большой раздел и пихает туда и <strong>/</strong>, 
			и <strong>/home</strong>. Что на первых порах расстраивает. Но беспокоиться не стоит. Создание отдельного 
			раздела для <strong>/home</strong> помогает только в одном случае: при переустановке системы. Не нужно 
			возиться в переносом документов и настроек программ. Но никакой дополнительной защиты от случайного 
			повреждения данных это не дает. К тому же, при переустановке системы (по сути, установке на зашифрованный 
			раздел), старое все равно придеться (предварительно забэкапив) отформатировать. Или перешифровать домашний
			раздел после установки. В любом случае, возни будет много. Да и насколько проще с одним-единственным 
			разделом! В случае возникновения аварийной ситуации один раздел будет намного проще смонтировать при 
			загрузке с LiveCD (а монтирование раздела LUKS - это не одна лишь команда <code>mount</code>, т.е.
			<a href="https://askubuntu.com/questions/653408/mounting-encrypted-luks-partition-from-live-cd">
				Mounting encrypted LUKS partition from Live CD</a>).
			
		<h2>И про swap поговорим чуть-чуть</h2>
		
		<p>
			Здесь речь пойдет о специфичной линуксовой фиче. Но для начала совершим краткую экскурсию в мир Windows.	
			В Windows вместо раздела подкачки используется файл подкачки <i>pagefile.sys</i>. Размеры этого файла можно
			менять в широких пределах. А для гибернации используется <i>hiberfil.sys</i>, его размер равен объему 
			оперативной памяти.
		
		<p>
			В Linux обычно используется не файл подкачки, а раздел подкачки (хотя можно задействовать и файл, и то и 
			другое одновременно). Причем этот раздел не имеет файловой системы. То, что данные по "сырому" пространству 
			пишутся быстрее, очевидно. Но неочевиден тот факт, что раздел подкачки используется для хранения
			содержимого ОЗУ при переходе компьютера в гибернацию. Т.о. чтобы компьютер мог глубоко заснуть, нужно,
			чтобы размер раздела подкачки превышал объем ОЗУ. Во сколько раз, зависит от конкретной ситуации. Пусть у 
			нас есть ноутбук с объемом ОЗУ 2 ГБ. Тогда минимум 2 ГБ понадобится для перехода в гибернацию. Но как только 
			что-то засвопится (я имею в виду ситуацию, когда оперативная память занята полностью), ноутбук заснуть не 
			сможет: на swap-разделе просто не хватит места. Так что лучше выделить под swap-раздел 4 ГБ. В этом случае 
			тоже можно попасть впросак. Но только если засвопится более 2 ГБ (чтобы столько данных выгрузилось в swap, 
			нужно очень сильно постараться; скорее всего, задолго до этого компьютер станет так сильно задумываться, 
			что поможет только hard reset).
		
		<p>
			Самое обидное, что при шифровании диска "из коробки" установщик LinuxMint создает раздел swap как раз равным
			объему ОЗУ, что совершенно не годится для ноутбука. Придеться либо самостоятельно настраивать зашифрованные 
			разделы (т.е. провести много "приятных" минут с LVM и LUKS), либо наращивать swap за счет файла подкачки, 
			что не замедлит сказаться на производительности. Либо провести еще больше времени за курением мануалов 
			к <strong>cgroups</strong> (т.е. настроить квоты таким образом, чтобы только программа гибернации могла 
			писать в swap-файл). Но проще всего настроить <code>vm.swapiness</code>: на новых ядрах установка параметра
			в 0 полностью выключает swap (подробности см. в 
			<a href="https://www.percona.com/blog/2014/04/28/oom-relation-vm-swappiness0-new-kernel/">
				OOM relation to vm.swappiness=0 in new kernel</a>) 
				<sup id="footnote-3-top"><a href="#footnote-3-bottom">[3]</a></sup>. Т.е. программы не смогут писать в 
			swap. При этом его размера (как уже говорилось выше, он создается равным объему ОЗУ по умолчанию) заведомо 
			хватит для гибернации.
			
		<h2>Всё!</h2>	
		
		<p>
			Установка Linux - это всегда приключение. Никогда не знаешь, с чем придеться столкнуться. Так что, помимо
			этой статьи, запасайтесь тетрадками, живыми флэшками, 3G-модемом и едой (ибо продолжаться сие действо может
			далеко за полночь).

        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a>
						Если вдруг на вашем ноутбуке диск зашифрован, не включайте музыку на встроенных динамиках на
						всю катушку. Слишком громкие звуки могут привести к ошибкам чтения/записи:
						<a href="https://geektimes.ru/post/294455/">Почему нельзя кричать на свой HDD</a>. Ведь в 
						ноутбуках динамики расположены недалеко от винчестера, и в одном корпусе. Паранойя, конечно... 
						
				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a>
						Для чего вообще нужно шифрование? Чтобы никто без вашего ведома не прочитал ваши данные. 
						Лишиться данных легко - достаточно потерять ноутбук. Конечно, с полностью зашифрованным 
						компьютером вы вообще в шоколаде. Наши спецслужбы вряд ли смогут взломать (хотя американские 
						взломают как нефиг, для них производители железа оставили в каждом чипе по два бэкдора минимум, 
						что уж говорить про разработчиков ПО). Если и строить "полностью безопасный зашифрованный 
						ноутбук", то делать это нужно на полностью открытом аппаратном обеспечении, например, 
						<em>Raspberry Pi</em>. А "чуть-чуть" незашифрованный комп подстерегает только одна опастность:
						протроянивание. Представьте себе, что вы потеряли ноутбук. Какие-то нехорошие люди ноутбук нашли
						(или спецслужбы проникли в ваш дом, когда вас не было). И вместо того, чтобы забрать ноутбук, 
						продать его и т.д., они открыли раздел, который монтируется в <em>/boot</em> (он-то не 
						зашифрован!), установили туда троянов, которые активизируются на самой ранней стадии загрузки 
						системы, и отдали ноутбук вам (к ни в чем не бывало). Вы же, наивный линуксоид, ошибочно 
						полагаете, что ноутбук остался прежним. Такой сценарий возможен, но маловероятен (скорее всего, 
						вашего кремниевого друга продадут или пропьют вместе с файлами). А вообще, отсутствие шифрования 
						на <em>/boot</em> будет консистентно с отсутствием паролей на BIOS и на GRUB. И гораздо легче 
						запомнить, что в безопасности только данные, а всякая обвязка (загрузчики и т.п.) не 
						зашифрованы. 
						
				<li id="footnote-3-bottom">
					<p>
						<a href="#footnote-3-top" title="Перейти к основному тексту">&uarr;</a> 
						После отключения подкачки командной <code>swapoff -a</code> гибернация перестает работать вовсе.						
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
