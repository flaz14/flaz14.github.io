<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Настройка BIOS и подготовка HDD перед установкой LinuxMint</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/bios-hdd-linux/bios-hdd-linux.html">
				Настройка BIOS и подготовка HDD перед установкой LinuxMint
			</a>
		</h1>
		
		<h3>[2017, Июль]</h3>
		
		<h2>Введение</h2>
		
		<p>
			Про BIOS и тонкую настройку ПК уже написано огромное количество статей и книг. В эпоху Windows XP встречались 
			душевно и заботливо составленные CHM-файлы со всякого рода FAQ, сборниками статей и т.п. К примеру, мне 
			как-то попал на винчестер EXE-файл, который представлял собой руководство по оптимизации и разгону Windows XP. 
			Автор боролся
			за каждый мегабайт оперативной и дисковой памяти. Конечно, некоторые его методы оптимизации не вызывают восторга
			сейчас, после многолетнего использования ПК. Например, полное отключение графических эффектов приводит к 
			тому, что глаза, стараясь различить сплошь серые элементы управления, больше напрягаются. 
			Пренебрежение разграничением 
			доступа (а именно: использование аккаунта с правами администратора вместо ограниченной учетной записи) тоже 
			ни к чему хорошему не приводит (а фраза была примерной такой: "Сделаем так, чтобы экран приветствия пропускался, 
			ведь пользователь в системе один-одинёшенек"). Ну а освобождение 50 МБ, занимаемых на диске ненужными
			экранными заставками - это и сейчас круто.
			
		<p>
			В этой ламерской статье я постараюсь выразить свое видение подготовки рабочей станции перед установкой Linux.			станции.
						
		<h2>BIOS</h2>
		
		<p>
			В BIOS много чего можно настроить. Или много чего нельзя. Так, в современных дешевых ноутбуках 
			в BIOS даже нельзя выключить Bluetooth и WiFi - подразумевается, что заботу о них возьмет на себя ОС. 
			Главное, что нужно сделать с BIOS на первых порах - включить режим <strong>AHCI</strong> для
			жесткого диска (для SATA-диска, естественно). Хотя он уже может быть включен по-умолчанию. В статье  
			<a href="http://forums.crucial.com/t5/Crucial-SSDs/Why-do-i-need-AHCI-with-a-SSD-Drive-Guide-Here-Crucial-AHCI-vs/td-p/57078">
				Why do i need AHCI with a SSD Drive (Guide Here!) Crucial AHCI vs IDE</a> все популярно объясняется.
		
		<p>
			Второй важный момент: перед установкой ОС (особенно Linux) следует включить в BIOS все возможные периферийные 
			устройства. Это нужно для того, чтобы программа установки Linux обнаружила устройства и установила необходимые
			драйверы. Отключить невостребованные устройства в BIOS позднее - несложно. А вот установить драйверы для 
			WiFi-адаптера
			потруднее будет (особенно, если нет способа выйти в Интернет не прибегая к WiFi; да чего уж говорить, на многих
			ноутбуках разъема Ethernet нету).

		<p>
			На первых порах не стоит запирать BIOS паролем. Пароль всегда можно установить позже. Восстановить же
			забытый пароль - морока, особенно в случае с ноутбуком. Придется его разбирать, искать контакты (перемычек
			в портативных компьютерах нету) или батарейку. Не очень приятное это (да и вообще рискованное) удовольствие. 
			А если ноутбук на гарантии, забот
			прибавляется. Везти в сервисный центр, чтобы не пропала гарантия, и платить за это - ну его нафиг.
			
			
		<p>
			Также не стоит заморачиваться с шифрованием. Нет, шифровать домашнию директорию или даже весь жесткий диск 
			нужно (об этом идет речь ниже !!!здесь будет ссылка на якорь!!!). А вот включать аппаратное шифрование 
			жесткого диска не стоит. Потерянные
			пароли не восстанавливаются. В случае же с программным шифрованием забытый пароль все же можно восстановить:
			зная большую часть пароля возможно подобрать оставшуюся за приемлимое время.
			
		<h2>HDD</h2>
		
		<p>
			Часто в Интернете можно встретить устаревшие рекомендации по ускорению жесткого диска. Вот основные из них.
			
			<ol>
				<li>
					<p>
						<b>Системный раздел (он же <em>/</em>) должен быть небольшого размера.</b> 
						
					<p>
						Не знаю, откуда берет начало эта 
						традиция. Может из простой аналогии, что в маленьком стоге сена иголку (то бишь отдельно взятый 
						файл) найти проще, чем в большом? В принципе, логично. Так оно и было во времена DOS (тогда 
						все файлы были небольшими). Система, будучи 
						установленной на жестком диске со всеми драйверами, прикладными программами и т.п. занимала 
						50 МБ от силы. И файлы по-большей части оставались неизменными. Программы тогда 
						обновлялись редко и вручную. Прикладные программы, если и создавали в процессе работы временные файлы,
						то делали это не так часто, как современные приложения (сегодня, наверное, даже в самой пустяковой 
						программе используется БД SQLite для хранения пары-тройки параметров конфигурации). Плюс еще сама
						архитектура DOS: каждой программе - свой каталог. В нем хранятся и исполняемые файлы, и настройки,
						и вспомогательные модули. Другое дело *nix: файлы, принадлежащие одной и той же программе, 
						размазаны по всему диску. Так что маленький системный раздел ничем не поможет (и дефрагментация 
						принципиально бессмысленна: как диск 
						не дефрагментируй, никак не получится собрать рядом файлы, принадлежащие
						одной программе, ведь программа дефрагментации видит только файлы и каталоги, но не программы).
					
					<p>
						Наоборот, чем больше свободного места на разделе - тем
						лучше.
						У файловой системы появляется больше возможностей для выбора. Например, есть большой
						кусок непрерывного свободного пространства - отлично, запишем туда увесистый файл. А маленькие 
						промежутки заполним крошечными файлами. Косвенно этот тезис подтверждает Windows: там для 
						успешной дефрагментации требовалось не менее 15%
						свободного места на диске. Возможно, что это было вызвано ограничениями реализации 
						штатного дефраментатора - в самом деле, почему не 10%, а именно 15%. Но рациональное зерно здесь есть.
						
					<p>
						Так что вывод такой: если планируется 
						использовать 20 ГБ для системы (а примерно столько требуется LinuxMint с Cinnamon),
						то лучше создать раздел минимум на 40 ГБ.
				
				<li>
					<p>
						<b>Расположение раздела на диске играет роль.</b>
						
					<p>
						На самом деле нет. Давным-давно кластеры на диске были одинаковые (в угловых координатах). 
						Из-за этого они были неодинаковые в декартовых координатах - на краю диска кластеры получались
						большими, чем в начале (ведь диаметр внешней окружности больше внутренней). Т.е. образом данные
						с края диска читались, при прочих равных условиях, медленнее, чем из начала или из середины. В 
						современных дисках кластеры имеют одинаковый размер, а следовательно, равномерно распределены
						по поверхности диска. Теперь получается наоборот - лучше создавать раздел в конце диска. 
						Поскольку линейная
						скорость на краю больше, чем в середине.
						А поскольку кластеры одинаковых декартовых размеров, то и читаться
						данные с внешнего края диска будут быстрее! 
						
					<p>
						Но по этому поводу заморачиваться не нужно. Нет
						никакой гарантии, что отсчет кластеров начинается с начала диска. Возможно, 
						отсчет начинается он как раз с края. Кроме этого, 
						нет никакой гарантии, что выделенный нами раздел займет непрерывную область поверхности
						одного блина. Пусть мы создадим раздел, скажем на 300 ГБ, начиная с начала диска. Может случиться так,
						что он начнется реально на диске с его края, при этом 280 ГБ найдут пристанище на одной поверхности
						одной пластины, а кусочек объемом 20 ГБ попадет на другую пластину. Предсказать это очень трудно. 
						
					<p>
						Дело в том, что даже в рамках одной серии жестких дисков конкретные экземпляры могут сильно отличаться.
						К примеру, хотел производитель X сделать диск на 1ТБ. В результате оказалось, что из всей партии 
						10% винчестеров глючат. Разбирать и переделывать - долго и дорого. Выкинуть на свалку - тоже невыгодно.
						Вот и начинают "чинить" такие диски модификацией прошивки. Отключили одну пластину - и вместо 
						диска на 1 ТБ получился
						диск на 500ГБ. Такой диск уже можно продать, разместив его в соответствующем ценовом сегменте.
						Еще один пример: изначально планировалось сделать диск на 2ТБ, то может 
						выйти, что реально рабочие поверхности  Диск продали
						как 1 ТБ. Но вы же не знаете, как там реально расположены работающие поверности. Может они 
						располагаются через одну, как в слоеном пироге. Или даже
						хуже: зоны, скажем так, неуверенного чтения/записи (ну деформировалось немного коромысло головки 
						при сборке), в середине диска могут быть исключены из обращения на уровне прошивки. 
						Какой тогда толк от хакерского разбиения на разделы? Конечно, 
						у дорогих серверных моделей, которые закупают серьезные организации, такое вряд ли встретишь. 
						Равно как и во всяких MacBook'ах, которые стоят в пять раз дороже, чем ходовые ноутбуки - 
						железо для Mac'ов подбирается чуть ли не индивидуально.
						
					<p>
						Так что танцевать вокруг геометрии жесткого диска - пустое дело. Вместо этого лучше уделить
						внимание простой и понятной разметке. Например, разбить диск так, чтобы программы вроде 
						<strong>fdisk</strong> 
						показывали "круглые" числа. Тогда и восстановить таблицу разделов можно будет 
						по памяти, не прибегая ко всякого рода утилитам и/или тетрадным записям.
			</ol>	

		<h2>Немного слов о дефрагментации</h2>
		
		<p>
			Дефрагментация в Linux не нужна. Большие файлы (такие, как фильмы) дефрагментировать смысла нет. Когда вы 
			смотрите фильм, соотвествующий файл читается с диска небольшими порциями. Так что даже если реально он 
			хранится как пять-шесть кусков на диске - на скорости воспроизведения это никак не скажется 
			(но на файловом сервере при большом количестве запросов разница, я думаю, будет заметной).
			Дефрагментация на уровне приложений невозможна в принципе (об этом уже говорилось выше !!!тут будет ссылка
			на абзац в этом же документе!!!). 
			
		<p>
			Есть еще один нюанс. Современные приложения, такие как Web-браузеры - это не просто небольшие программки, 
			это операционная система внутри другой ОС (вспомним хотя бы т.н. дополнения к браузеру - чем не близнецы 
			традиционных приложений?). О всякого рода временных файлах, кэшировании Веб-страниц Web-браузер заботится сам.
			ОС может быть вообще не в курсе происходящего. Следовательно, даже при использовании DOS-like подхода 
			(как уже говорилось выше !!!тут будет ссылка на якорь!!!) дефрагментация ничем
			не поможет. 
			
		<h2>О шифровании на уровне ОС</h2>	
			
		<p>
			В популярных дистрибутивах шифрование домашнего каталога и даже всего диска (LUKS !!!здесь будет ссылка на 
			Википедию!!!) доступны "из коробки". Такие 
			готовые решения, тем не менее, оставляют на диске незашифрованные разделы (нужно ведь загрузить для начала 
			хоть-что, хоть какой-нибудь код, который поможет начать расшифровку и продолжить загрузку. В частности, в 
			LinuxMint
			это раздел, который монтируется в каталог <em>/boot</em>. Этот раздел имеет небольшой размер (примерно 200 МБ),
			форматируется он в  
			файловую систему <em>ext2</em> и не шифруется. В принципе, журналирование для загрузочного раздела не требуется.
			С другой стороны, отсутствие журналирования уменьшает износ диска, но увеличивает шансы на безвозвратную 
			потерю данных в случае аппаратного
			сбоя. А шифрование этого раздела только усугубит ситуацию (теоретически).
			
		<p>	
			В принципе, зашифровать <em>/boot</em> можно. Только в начале загрузки придется вводить ключь рассшифровки 
			два раза. С другой стороны, можно обойтись и без него, носить с собой Read-Only флэшку и загружаться только 
			с нее. А уже она будет загружать основную систему. Но как тогда обновлять загрузчик?
			Хрень в итоге получается...
			
		<p>
			Да, можно и на <strong>grub</strong> поставить пароль. Но для чего вообще нужно шифрование? 
			Чтобы никто без вашего ведома не прочитал Ваши данные. Лишиться данных 
			легко - достаточно просто потерять ноутбук. Конечно, с полностью зашифрованным компьютером вы вообще в 
			шоколаде. Даже наши спецслужбы вряд ли смогут взломать (хотя американские взломают как нефиг, для них 
			производители железа заботливо оставили в каждом
			чипе по 2 бэкдора, что уж говорить про разработчиков ПО...
			Если уж и строить "полностью безопасный зашифрованный ноутбук", то делать это нужно на 
			полностью открытом аппаратном обеспечении, например, Raspberry PI. И еще придется отказаться от многих 
			прелестей современных Линуксов. "Чуть-чуть" незашифрованный комп подстерегает только одна опастность: его
			протроянивание. Представьте себе, что вы потеряли ноутбук. Какие-то нехорошие люди ноутбук нашли (или спец
			службы вломились в ваш дом, когда вас не было). И вместо того, чтобы забрать ноутбук себе, продать его и т.п.
			они открыли раздел, который монтируется в <em>/boot</em> (он-то не зашифрован!), установили туда троянов, которые активизируются на самой
			ранней стадии загрузки системы, и отдали ноутбук вам (к ни в чем не бывало). Вы же, наивный линуксоид, 
			ошибочно предполагаете, что
			ноутбук остался прежним. Такой сценарий возможен, но маловероятен (скорее, вашего кремниевого друга продадут 
			или пропьют пропьют,
			вместе с файлами. А может и по частям. Но файлы никто уж не прочитает, главное, не скидывать ничего личного 
			в каталог <em>/boot</em>).
			А вообще, лучше и <em>/boot</em> зашифровать нафиг. Или не шифровать? Нет, лучше не шифровать. 
			Отсутствие шифрование 
			будет консистентно с отсутствием паролей на BIOS и на GRUB: гораздо легче запомнить, что в безопасности 
			только данные, а всякая обвязка (загрузчики и т.п.) незашифрованы.
					
		<p>
			Еще один момент: по-умолчанию установщик LinuxMint (при выборе опции "Use the entire disk" !!!или как там
			она называется!!!) создает один большой раздел, и пихает туда и <strong>/</strong>, и <strong>/home</strong>.
			 Что на первых порах расстраивает.
			Но беспокоиться не стоит. Создание отдельного раздела для <strong>/home</strong> помогает только в одном случае: 
			при переустановке 
			системы. Не нужно возиться в переносом документов и настроек программ. Но никакой дополнительной защиты 
			от случайного повреждения данных это не дает. К тому же, при переустановке системы (по сути, установки
			на зашифрованный раздел), старое все равно придется (предварительно забэкапив) отформатировать. Или уж 
			перешифровывать домашний раздел после установки. В любом случае, возни будет много. Да и насколько проще 
			с одним-единственным разделом! В случае возникновения аварийной ситуации один раздел будет намного проще 
			смонтировать при загрузке с Live-CD (а монтирование раздела LUKS - это не одна лишь команда <code>mount</code>).
			
		<h2>И про swap поговорим чуть-чуть</h2>
		
		<p>
			Здесь речь пойдет о специфичной линуксовой фиче. Но для начала совершим краткую экскурсию в мир windows.
			
			В Windows вместо раздела подкачки используется файл подкачки pagefile.sys !!!уточнить как этот файл называется!!!. 
			Размеры этого файла можно менять в широких
			пределах. А для гибернации используется hiberfile.sys !!!надо уточнить!!!. Размер hiberfile.sys равен объему
			оперативной памяти. 
			
			В Linux обычно используется не файл подкачки, а раздел подкачки (хотя можно задействовать и файл, и то и 
			другое одновременно). Причем этот раздел не имеет файловой системы. То, что данные по "сырому" 
			пространству пишутся быстрее, очевидно. Но неочевиден тот факт, что раздел подкачки используется для хранения
			содержимого ОЗУ при переходе компьютера в гибернацию. Т.о. чтобы компьютер мог глубоко заснуть, нужно,
			чтобы объем раздела подкачки превышал объем ОЗУ. Во сколько раз, зависит от конкретной ситуации. Пусть у нас
			есть ноутбук с объемом ОЗУ 2 ГБ. Тогда минимум 2 ГБ понадобиться, для перехода в гибернацию. Но как только 
			что-то засвопится, то ноутбук заснуть не сможет: на своп-разделе просто не останется места. 
			Но лучше выделить под swap 4 ГБ. В этом случае тоже можно попасть в просак. Но только только в том случае,
			если засвопится более 2 ГБ. Чтобы столько данных выгрузилось в своп нужно очень сильно постараться. Скорее
			всего, что задолго до этого компьютер станет так глубоко задумываться, что поможет только спасительный 
			hard reset.
			
			!!! этот абзац нужно вынести в сноску !!!
			Интересный вопрос: можно ли отключить своп (современные компьютеры с объемом ОЗУ 4 ГБ и без свопа
			чувствуют себя неплохо, потратить столько памяти можно разве что при использовании виртуаьных машин или 
			за декодированием видео каким-нибудь )
			и при этом оставить 
			гибернацию работающей? Т.е. чтобы раздел
			подкачки служил только целями гибернации, а система не могла выталкивать туда страницы?
			Надо проверить. Но
			насколько я помню из опыта использования LinuxMint, при отключении свопа swapoff -a гибернация перестает 
			работать вовсе.
			
		<p>
			Самое обидное, что при шифровании диска "из коробки" установщик LinuxMint создает раздел swap как раз равным
			объему ОЗУ, но совершенно не годится для ноутбука. Придется либо самостоятельно настраивать зашифрованные 
			разделы (а заодно провести много приятных минут с LVM и LUKS), либо наращивать своп за счет файла подкачки, 
			что не замедлит сказаться на производительности. Либо провести еще больше времени за курением мануалов 
			к <strong>cgroups</strong> (т.е. настроить квоты таким образом, чтобы только программа гибернации могла 
			писать в swap, 
			см. выше). Но проще всего настроить <code>vm.swapiness=0</code> - на ядрах старше !!!не помню, какая тут версия!!!
			 такое
			значение опции отрубает swap нафиг (конечно, как-то страшновато сидеть с двумя гигабайтами ОЗУ и без свопа,
			но, с другой стороны, интересно, что из этого получится).
			
		
 
			<sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>.		

        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Ссылки, которые выдает <code>apt-get --print-uris download ...</code> можно использовать напрямую,
						т.е. можно использовать для скачивания не <strong>apt-get</strong>, а, например, <strong>wget</strong>.
						Но лучше использовать все-таки <strong>apt-get</strong>. И не потому что это более элегантно (особенно
						в случае скачивания исходных текстов - поди разберись, что там за три файла), а потому, что 
						<strong>apt-get</strong> еще проверяет контрольные суммы и т.д.
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
