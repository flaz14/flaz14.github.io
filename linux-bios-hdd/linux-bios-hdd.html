<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Настройка BIOS и подготовка HDD перед установкой LinuxMint</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/linux-bios-hdd/linux-bios-hdd.html">
				Настройка BIOS и подготовка HDD перед установкой LinuxMint
			</a>
		</h1>
		
		<h3>[2017, Июль]</h3>
		
		<h2>Введение</h2>
		
		<p>
			Про BIOS и тонкую настройку ПК написано огромное количество статей и книг. В эпоху Windows XP встречались 
			душевно и заботливо составленные CHM-файлы со всякого рода FAQ, сборниками статей и т.п. К примеру, мне 
			попался EXE-файл, который представлял собой руководство по оптимизации и разгону Windows XP. Автор боролся
			за каждый мегабайт оперативной и дисковой памяти. Конечно, некоторые методы оптимизации не вызывают восторга
			сейчас, после многолетнего использования ПК. Например, полное отключение графических эффектов приводит к 
			тому, что глаза, стараясь различить пункты серых меню, больше напрягаются. Пренебрежение разграничением 
			доступа (а именно: использование аккаунта с правами администратора вместо ограниченной учетной записи) тоже 
			ни к чему хорошему не приводит (а фраза была примерной такой: "Сделаем так, чтобы экран приветствия пропускался, 
			ведь пользователь в системе один-одинёшенек"). Ну а освобождение 50 Мегабайт дискового пространства от ненужных
			экранных заставок - это и сейчас круто.
			
		<p>
			В этой ламерской статье я постараюсь выразить свое видение манипуляций перед установкой Linux на рабочей 
			станции.
						
		<h2>BIOS</h2>
		
		<p>
			В BIOS много чего можно настроить. Ну или почти ничего нельзя (например, в современных дешевых ноутбуках 
			в BIOS'е даже нельзя выключить Bluetooth и WiFi - подразумевается, что заботу о них берет на себя ОС). 
			Настройка RAID - отдельная тема. Главное, что нужно сделать с BIOS на первых порах - включить режим AHCI для
			жесткого диска (для SATA-диска, естественно). Хотя он уже может быть включен по-умолчанию). В статье  
			<a href="http://forums.crucial.com/t5/Crucial-SSDs/Why-do-i-need-AHCI-with-a-SSD-Drive-Guide-Here-Crucial-AHCI-vs/td-p/57078">
				Why do i need AHCI with a SSD Drive (Guide Here!) Crucial AHCI vs IDE</a> все популярно объясняется.
		
		<p>
			Второй важный момент перед установкой ОС (особенно Linux) - включить в BIOS'е все возможные периферийные 
			устройства. Это нужно для того, чтобы программа установки Linux обнаружила устройства и установила необходимые
			драйверы. В любом случае, отключить устройства в BIOS - несложно. А вот установить драйверы для WiFi-адаптера
			потруднее будет (особенно, если нет выйти в Интернет не прибегая к WiFi. Да чего уж там говорить, на многих
			ноутбуках уже разъема Ethernet нету.)

		<p>
			На первых порах не стоит запирать BIOS паролем. Пароль всегда можно установить позже. Восстановить же
			забытый пароль - морока, особенно в случае с ноутбуком. Придется его разбирать, искать контакты (перемычек
			в портативных компьютерах нету) или батарейку. Не очень приятное это (да и вообще рискованное) удовольствие. 
			А если ноутбук на гарантии, забот
			прибавляется. Везти в сервисный центр, чтобы не пропала гарантия, и платить за это - ну его нафиг.
			
			
		<p>
			Также не стоит заморачиваться с шифрованием. Нет, шифровать домашнию директорию или даже весь жесткий диск 
			нужно (об этом пойдет речь ниже). А вот включать аппаратное шифрование жесткого диска не стоит. Потерянные
			пароли не восстанавливаются. В случае же с программным шифрованием забытый пароль все же можно восстановить:
			зная большую часть пароля можно подобрать оставшуюся за приемлимое время.
			
			
		<h2>HDD</h2>
		
		<p>
			Часто в Интернете можно встретить устаревшие рекомендации по ускорению жесткого диска. Вот основные из них.
			
			<ol>
				<li>
					<p>
						<b>Системный раздел (он же '/') нужно создавать небольшого размера.<b> 
						
					<p>
						Не знаю, откуда берет начало эта 
						традиция. Может из простой аналогии, что в маленьком стоге сена иголку (то бишь отдельно взятый 
						файл) найти проще, чем в большом? В принципе, логично. И так оно и было во времена MS-DOS (все файлы
						были небольшими и примерно одного размера). Система, будучи 
						установленной на жестком диске со всеми драйверами, прикладными программами и т.п. занимала 
						от силы мегабайт 200. И файлы по-большей части оставались неизменными. Программы тогда 
						обновлялись редко и вручную. Прикладные программы, если и создавали в процессе работы временные файлы,
						то делали это не так часто, как современные приложения (сегодня, наверное, даже в самой пустяковой 
						программе используется БД SQLite для хранения пары-тройки параметров конфигурации). Плюс еще само
						устройство DOS: каждой программе - свой каталог, в котором хранятся и исполняемые файлы, и настройки,
						и вспомогательные модули. Другое дело современный *nix: файлы, принадлежащие одной и той же программе, 
						размазаны по всему диску. Так что маленький системный раздел ничем не поможет (и дефрагментация 
						принципиально бессмысленна: как диск 
						не дефрагментируй, никак не получится собрать рядом файлы, принадлежащие
						одной программе, ведь программа дефрагментации видит только файлы и каталоги, но не программы).
					
					<p>
						Наоборот, чем больше свободного места на разделе - тем
						лучше.
						У файловой системы появляется больше возможностей для выбора. Например, есть большой
						кусок непрерывного свободного пространства - отлично, запишем туда увесистый файл. А маленькие 
						промежутки заполним крошечными файлами (косвенно этот тезис подтверждает Windows - там для 
						успешной дефрагментации требовалось не менее 15%
						свободного места на диске. Вполне возможно, что это было вызвано ограничениями реализации 
						штатного дефраментатора - в самом деле, почему не 10%, а именно 15%. Но рациональное зерно в этом
						есть).
						
						Так что вывод такой: если планируется 
						использовать 20 ГБ для системы (а примерно столько и требуется LinuxMint в редакции с Cinnamon),
						то лучше создать раздел минимум на 40ГБ.
				
				<li>
					<p>
						<b>Расположение раздела на диске играет роль.</b>
						
					<p>
						На самом деле нет. Да, давным-давно кластеры на диске были одинаковые (в угловых координатах). 
						Из-за этого они были неодинаковые в декартовых координатах - на краю диска кластеры получались
						большими, чем в начале (ведь диаметр внешней окружности больше внутренней). Т.е. образом данные
						с края диска читались, при прочих равных условиях, медленнее, чем из начала или из середины. В 
						современных дисках кластеры имеют одинаковый размер, а следовательно, равномерно распределены
						по поверхности диска. Теперь получается наоборот - лучше создавать раздел в конце диска. Да, 
						угловая скорость вращения диска что на внешнем крае, что в середине, одинаковая. Но вот линейная
						скорость на окружности больше. А поскольку кластеры одинаковых декартовых размеров, то и читаться
						данные с внешнего края диска будут быстрее! 
						
					<p>
						Но по этому поводу заморачиваться не нужно. Нет
						никакой гарантии, отсчет кластеров (а сейчас как известно, используется линейная адресация - 
						ОС видит весь диск как большой байтовый массив) начинается с внутреннего края диска. Возможно, 
						отсчет начинается он как раз с внешнего. Кроме этого, 
						нет никакой гарантии, что выделенный нами раздел будет находится на непрерывной области поверхности
						одного блина. Пусть мы создадим раздел, скажем на 300ГБ, начиная с начала диска. Может случиться так,
						что он начнется реально на диске с его внешнего края, 280ГБ разместятся на одной поверхности
						одной пластины, а кусочек объемом 20ГБ попадет на другую пластину, начиная от шпинделя. Предсказать
						это трудно. 
						
					<p>
						Дело
						в том, что даже в рамках одной модели жесткого диска, конкретные экземпляры могут сильно отличаться.
						Вот к примеру, хотел производитель X сделать диск на 1ТБ. Из всей партии получилось, что 10% 
						винчестеров глючат. Разбирать и переделывать - долго и дорого. Выкинуть на свалку - тоже невыгодно.
						Вот начинают "чинить" такие диски модификацией прошивки. Отключили одну пластину - получился
						диск на 500ГБ - можно продать. Или если изначально планировалось сделать диск на 2ТБ, то может 
						выйти, что реально рабочие поверхности располагаются через одну, как в слоеном пироге. Или даже
						хуже: зоны, скажем так, неуверенного чтения/записи (ну деформировалось немного коромысло головки 
						при сборке), в середине диска могут быть исключены из обращения на уровне прошивки. Конечно, 
						у дорогих серверных моделей, которые закупают серьезные организации, такое вряд ли встретишь. 
						Равно как и во всяких MacBook'ах, которые стоят в пять раз дороже, чем ходовые ноутбуки - 
						все подбирается в таких случаях индивидуально.
						
					<p>
						Так что танцевать вокруг геометрии жесткого диска - пустое дело. Вместо этого лучше уделить
						внимание простой и понятной разметке. Например, разбить диск так, чтобы программы вроде fdisk 
						показывали "круглые" числа. Тогда и восстановить таблицу разделов (GPT и т.д.) можно будет 
						по памяти, без всяких утилит и тетрадных записей.
			</ol>	

		<h2>Немного слов о дефрагментации</h2>
		
		<p>
			Дефрагментация в Linux не нужна. Большие файлы (такие, как фильмы) дефрагментировать смысла нет. Когда вы 
			смотрите фильм, соотвествующий файл читается с диска небольшими порциями. Так что даже если реально он 
			хранится как пять-шесть кусков на диске - на скорости воспроизведения это никак не скажется 
			(но на файловом сервере при большом количестве запросов разница, я думаю, будет заметной).
			Дефрагментация на уровне приложений невозможна в принципе (об этом уже говорилось выше !!!тут будет ссылка
			на абзац в этом же документе). 
			
		<p>
			Но есть еще один момент. Современные приложения, такие как Web-браузеры, - это не просто небольшие программки, 
			это операционная система внутри другой ОС (вспомним хотя бы т.н. дополнения к браузеру - чем не близнецы 
			традиционных приложений?). О всякого рода временных файлах, кэшировании Веб-страниц Web-браузер заботится сам.
			ОС может быть вообще не в курсе происходящего. Следовательно, даже при использовании DOS-like подхода 
			(как уже говорилось выше !!!тут будет ссылка на якорь!!!, каждой программе - свой каталог) дефрагментация ничем
			не поможет. 
			
		<h2>О шифровании на уровне ОС</h2>	
			
		<p>
			Более того, эти возможности доступны в современных популярных дистрибутивах "из коробки". Такие 
			"коробочные" решения, тем не менее, оставляют на диске незашифрованные разделы (нужно ведь загрузить хоть-что
			, хоть какой-нибудь код, который поможет начать расшифровку и загружаться дальше). В частности, в LinuxMint
			это раздел /boot (т.е. для этой директории создается незашифрованный раздел, форматируется он в файловую систему
			ext2, что и без шифрование увеличивает риск его логического повреждения, но в то же время уменьшает 
			физический износ). Особенно упоротые линуксоиды шифруют еще и /boot, и ставят пароль на grub (а может, и
			grub шифруют - кто знает). Но это слишком. Лучше уж тогда носить отдельную флэшку (Read-Only, естественно) с 
			загрузчиком, и загружаться с нее. А уже она будет загружать основную систему. Но как тогда обновлять загрузчик?
			Хрень в итоге получается.
			
		<p>
			Для чего вообще нужно шифрование? Чтобы никто без вашего ведома не прочитал Ваши данные. Лишиться данных 
			легко - достаточно просто потерять ноутбук. Конечно, с полностью зашифрованным компьютером вы вообще в 
			шоколаде. Даже наши спецслужбы вряд ли смогут взломать (хотя американские взломают как нефиг, у них в каждом
			чипе по 2 бэкдора, если уж и строить "полностью безопасный зашифрованный ноутбук", то делать это нужно на 
			полностью открытом аппаратном обеспечении, например, Raspberry PI. И еще придется отказаться от многих 
			прелестей современных Линуксов). "Чуть-чуть" незашифрованный комп подстерегает только одна опастность: его
			протроянивание. Представьте себе, что вы потеряли ноутбук. Какие-то нехорошие люди ноутбук нашли (или спец
			службы вломились в ваш дом, когда вас не было). И вместо того, чтобы забрать ноутбук себе, продать его и т.п.
			они открыли раздел /boot (он-то не зашифрован!), установили туда троянов, которые активизируются на самой
			ранней стадии загрузки системы, и отдали ноутбук вам. Вы же, наивный линуксоид, ошибочно предполагаете, что
			ноутбук остался прежним. Такой сценарий возможен, но маловероятен (скорее, вашего кремниевого друга пропьют,
			вместе с файлами - но файлы никто уж не прочитает, главное, не скидывать ничего личного в каталог /boot).
			А вообще, лучше и boot зашифровать нафиг. Или не шифровать? Нет, лучше не шифровать. Отсутствие шифрование 
			будет консистентно с отсутствием паролей на BIOS и на GRUB: гораздо легче запомнить, что в безопасности 
			только данные, а всякая обвязка (загрузчики и т.п.) требую повышенного внимания.
			
		<p>
			О том, что просто необходимо записать ключ шифрования на первое время где-то на листке (до тех пор, пока
			мы не настроим специальную флэшку !!!тут будет ссылка на описание процесса, англоязычный источник!!!), бумага
			будет жизненно необходима. 
			
		<p>
			Еще один момент: по-умолчанию установщик LinuxMint (при выборе опции "Use the entire disk" !!!или как там
			она называется!!!) создает один большой раздел, и пихает туда и /, и /home. Что на первых порах расстраивает.
			Но беспокоитьс не стоит. Создание отдельного раздела для /home помогает только в одном: при переустановки 
			системы (не нужно возиться в переносом настроек программ и документов). Но никакой дополнительной защиты 
			от случайного повреждения данных это не дает. К тому же, при переустановке системы (по сути, установки
			на зашифрованный раздел), старое все равно придется (предварительно забэкапив) отформатировать. Или уж 
			перешифровывать домашний раздел после установки. В любом случае, возни будет много. Да и насколько проще 
			с одним-единственным разделом! В случае возникновения аварийной ситуации один раздел будет намного проще 
			смонтировать при загрузке с Live-CD.
			
		
	
		<p>
			Все-таки скажу немного слов о разбиении на разделы. Здесь предполагается, что при установке LinuxMint
			используется пункты Erase disk and install LinuxMint (!!!или как он там называется!!!) и 
			Encrypt LinuxMint installation. Так что каким образом
			огранизовано разбиение на разделы (т.е. включена ли в биос GPT или по-старинке MBR) - не важно, при установке
			будет задействован LVM. Тут можно спросить: как же так, ведь принято создавать два раздела - один для '/', 
			второй для '/home'. На самом деле при шифровании всего диска это не имеет значения. Если что-то сломается,
			то полетят оба раздела. Но насколько проще подключить зашифрованный том при загрузке с LIVE CD , если томов 
			всего одна штука!
			
			

			
		<h2>И про swap поговорим чуть-чуть</h2>
		
		<p>
			Здесь речь пойдет о спецефичной Линуксовой фиче. Но для начала совершим краткую экскурсию в мир windows.
			
			В Windows вместо раздела подкачки используется файл подкачки pagefile.sys. Размеры этого файла можно менять в широких
			пределах. А для гибернации используется hiberfile.sys !!!надо уточнить!!!. Размер hiberfile.sys равен объему
			оперативной памяти. 
			
			В Linux обычно используется не файл подкачки, а раздел подкачки (хотя можно задействовать и файл, и то и 
			другое одновременно). Причем этот раздел не имеет файловой системы. То, что данные по "сырому" 
			пространству пишутся быстрее - очевидно. Но неочевиден тот факт, что раздел подкачки используется для хранения
			содержимого ОЗУ при переходе компьютера в гибернацию. Т.о. чтобы компьютер мог спокойно уснуть, нужно
			чтобы объем раздела подкачки превышал объем ОЗУ. Во сколько раз, зависит от конкретной ситуации. Пусть у нас
			есть ноутбук с объемом ОЗУ 2 ГБ. Тогда минимум 2ГБ понадобиться, для перехода в гибернацию. Но как только 
			что-то засвопится, то ноутбук заснуть не сможет: на своп-разделе просто не останется места. 
			Но лучше выделить под swap 4 ГБ. В этом случае тоже можно попасть в просак. Но только только в том случае,
			если засвопится более 2 ГБ. Чтобы столько данных выгрузилось в своп нужно очень сильно постараться. Скорее
			всего, что задолго до этого компьютер станет так глубоко задумываться, что поможет только спасительный 
			hard reset.
			
			Интересный вопрос: можно ли отключить своп (современные компьютеры с объемом ОЗУ 4 ГБ и без свопа
			чувствуют себя неплохо, потратить столько памяти можно разве что при использовании виртуаьных машин или 
			за декодированием видео каким-нибудь )
			и при этом оставить 
			гибернацию работающей? Т.е. чтобы раздел
			подкачки служил только целями гибернации, а система не могла выталкивать туда страницы?
			Надо проверить. Но
			насколько я помню из опыта использования LinuxMint, при отключении свопа swapoff -a гибернация перестает 
			работать вовсе.
			
			Самое обидное, что при шифровании диска "из коробки" установщик LinuxMint создает раздел swap как раз равным
			объему ОЗУ, но совершенно не годится для ноутбука. Придется либо самостоятельно настраивать зашифрованные 
			разделы (а заодно провести много приятных минут с LVM и LUKS), либо наращивать своп за счет файла подкачки, 
			что не замедлит сказаться на производительности. Либо провести еще больше времени за курением мануалов 
			к cgroups (т.е. настроить квоты таким образом, чтобы только программа гибернации могла писать в swap, 
			см. выше). Но проще всего настроить vm.swapiness=0 - на ядрах старше !!!не помню, какая тут версия!!! такое
			значение опции отрубает swap нафиг (конечно, как-то страшновато сидеть с двумя гигабайтами ОЗУ и без свопа,
			но, с другой стороны, интересно, что из этого получится).
			
		<p>
			Будьте готовы к тому, что в вашем любимом дистрибутиве после установки (а может быть, и до ее начала, 
			особенно актуально в случае ноутбуков), не заработает какое-нибудь жизненно важное устройство. Ннапример, 
			WiFi (хотя к этом все уже давно привыкли) или 3G-модем (систему перед началом настройки нужно обновить в 
			первую очередь!) или даже тачпад (особую радость доставляют установщики с GUI - а таких большинство сейчас -
			вообще фиг установишь систему). Так что желательно запастить Ethernet-кабелем, мышкой (проводная на всякий 
			случай) и несколькими установочными флэшками (а в случае наличия в компе оптического привода загрузочный
			диск не помешает). Ведь если вы записывали загрузочные флэшки в Линуксе, наверняка они глючные.
			
		
 
			<sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>.		

        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Ссылки, которые выдает <code>apt-get --print-uris download ...</code> можно использовать напрямую,
						т.е. можно использовать для скачивания не <strong>apt-get</strong>, а, например, <strong>wget</strong>.
						Но лучше использовать все-таки <strong>apt-get</strong>. И не потому что это более элегантно (особенно
						в случае скачивания исходных текстов - поди разберись, что там за три файла), а потому, что 
						<strong>apt-get</strong> еще проверяет контрольные суммы и т.д.
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
