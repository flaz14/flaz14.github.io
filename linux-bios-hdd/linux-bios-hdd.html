<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Толстая настройка BIOS и подготовка диска перед установкой LinuxMint</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/linux-bios-hdd/linux-bios-hdd.html">
				Толстая настройка BIOS и подготовка диска перед установкой LinuxMint
			</a>
		</h1>
		
		<h3>[2017, Июль]</h3>
		
		<h2>Введение</h2>
		
		<p>
			тут будет введение

		<h2>Начнем с железа</h2>
		
		<p>
			В BIOS много чего можно настроить. Оставим в стороне настройку UEFI, GPT, разбиение на разделы, безопасных 
			загрузчиков и т.д. Главное, что нужно сделать в BIOS - включить режим AHCI для жесткого диска !!!тут
			будет ссылка на подробное описание, т.е. на статью на английском!!!. По-умолчанию может быть включен режим
			эмуляции IDE. Если жесткий диск работает в режиме эмуляции IDE, то о скорости можно забыть.
			
		<p>
			На первых порах не стоит запирать BIOS паролем. Пароль всегда можно установить позже. Восстановить же
			забытый пароль - морока, особенно в случае с ноутбуком - придется его разбирать, искать контакты или 
			батарейку. Не очень приятное это (да и вообще рискованное) удовольствие. А если ноутбук на гарантии, забот
			прибавляется.
			
		<p>
			Все-таки скажу немного слов о разбиении на разделы. Здесь предполагается, что при установке LinuxMint
			используется пункты Erase disk and install LinuxMint (!!!или как он там называется!!!) и 
			Encrypt LinuxMint installation. Так что каким образом
			огранизовано разбиение на разделы (т.е. включена ли в биос GPT или по-старинке MBR) - не важно, при установке
			будет задействован LVM. Тут можно спросить: как же так, ведь принято создавать два раздела - один для '/', 
			второй для '/home'. На самом деле при шифровании всего диска это не имеет значения. Если что-то сломается,
			то полетят оба раздела. Но насколько проще подключить зашифрованный том при загрузке с LIVE CD , если томов 
			всего одна штука!
			
		<p>
			Еще перед установкой системы нужно включить все возможные устройства в BIOS. Это необходимо сделать для того,
			чтобы установщик LinuxMint нашел и установил драйверы для как можно большего количества устройств. Ненужное
			устройство (например, Bluetooth) можно будет отключить в BIOS позже (конечно же, главная причина - 
			снижение энергопотребления). Удалить драйверы тоже можно будет потом.
			Но лучше оставить драйверы (разве только убрать их из автоматической загрузки). Много места на диске они не 
			занимают. Мало ли понадобиться тот же Bluetooth или драйвер 3G модема. Включить в BIOS устройство - дело одной
			минуты.
			
		<h2>Все-таки несколько слов о разметке диска</h2>
		
		<p>
			Часто в Интернете можно встретить устаревшие рекомендации по ускорению жесткого диска (про SSD ничего не 
			знаю, знаю только, что толку от SSD мало в пересчете на цену. Рискну предположить, что чтобы почувствовать 
			разницу между HDD и SSD нужно установить как минимум два твердотельных накопителя, чтобы данные 
			читались/записывались одновременно на оба диска - parallel raid или как эта штука называется, и чтобы SSD были
			подключены через шину PCI-Express. Да, скорости у SATA II и SATA III с лихвой хватит, но когда говорят о 
			скорости передачи данных, то имеют ввиду именно скорость, т.е. "крейсерскую" скорость. Очевидно, что для 
			настольного компьютера большее значение имеет задержка перед операцией чтения/записи. Последовательный 
			интерфейс, какой бы быстрый он ни был, не может обеспечить низкую задержку !!!хрень какая-то - надо 
			погуглить!!! А у шины PCI-Express линий - хоть отбавляй).
			
			Какие же можно встретить заблуждения?
			
			<ol>
				<li>
					<p>
						Системный раздел (он же '/') нужно создавать небольшого размера. Не знаю, откуда берет начало эта 
						традиция. Может из простой аналогии, что в маленьком стоге сена иголку найти проще, чем в большом?
						Т.е. если вдруг нам понадобился некоторый файл (небольшой файл), то мол на маленьком разделе он 
						быстрее отыщется. В принципе, логично. И так оно и было во времена MS-DOS. Система, будучи 
						установленной на жестком диске со всеми драйверами, прикладными программами и т.п. занимала 
						от силы мегабайт 200. Но при этом файлы по-большей части оставались неизменными. Программы тогда 
						обновлялись редко, вручную. Прикладные программы, если и создавали в процессе работы временные файлы,
						то делали это не так часто, как современные приложения (уже наверное даже в самой пустяковой 
						программе используется БД SQLite для хранения пары-тройки параметров конфигурации). Плюс еще само
						устройство DOS: каждой программе - свой каталог, в котором хранятся и исполняемые файлы, и настройки,
						и модули. Другое дело современный Linux: файлы, принадлежащие одной и той же программе, размазаны по
						всему диску. Так что как диск не дефрагментируй, никак не получится собрать рядом файлы, принадлежащие
						одной программе.
					
					<p>
						В общем, все вышесказанное приводит к мысли, что чем больше свободного места на разделе - тем
						лучше.
						Файловая система Ext4 в 
						дефрагментации не нуждается, но только лишь потому, что меры по предотвращению фрагментации 
						принимаются в самом начале записи файла на диск.  У файловой системы появляется больше возможностей для выбора. Например, есть большой
						кусок непрерывного свободного пространства - отлично, разместим там увесистый файл. И т.д. и т.п.
						(тут уместно будет всмопнит Windows - там для успешной дефрагментации требовалось не менее 15%
						свободного места на диске. Вполне возможно, что это было вызвано ограничениями реализации 
						штатного дефраментатора - в самом деле, почему не 10%, а именно 15%. Но рациональное зерно в этом
						есть).
						
						Вероятно, современным файловым
						системам (всякие там ZFS, т.е. те, что применяют copy-on-write - !!!!нужно погуглить и 
						проверить!!!) свободное место вовсе не помешает. Так что вывод такой: если планируется 
						использовать 20 ГБ для системы (а примерно столько и требуется LinuxMint в редакции с Cinnamon),
						то лучше создать раздел минимум на 40ГБ.
				
				<li>
					<p>
						Расположение раздела на диске играет роль.
						
					<p>
						На самом деле нет. Да, давным-давно кластеры на диске в угловом	измерении они были одинаковые. 
						Из-за этого они были неодинаковые в декартовых координатах - на краю диска кластеры получались
						большими, чем в начале (ведь диаметр внешней окружности больше внутренней). Т.е. образом данные
						с края диска читались, при прочих равных условиях, медленнее, чем из начала или середины. В 
						современных дисках кластеры имеют одинаковый размер, а следовательно, равномерно распределены
						по поверхности диска. Теперь получается наоборот - лучше создавать раздел в конце диска. Да, 
						угловая скорость вращения диска что на окружности, что у шпинделя одинаковая. Но вот линейная
						скорость на окружности больше. А поскольку кластеры одинаковых декартовых размеров, то и читаться
						данные с внешнего края диска будут быстрее! Но по этому поводу заморачиваться не нужно. Нет
						никакой гарантии, отсчет кластеров (а сейчас как известно, используется линейная адресация - 
						ОС видит весь диск как большой байтовый массив) начинается с внутреннего края диска. Возможно, 
						что начинается он как раз в внешнего. Кроме этого, 
						нет никакой гарантии, что выделенный нами раздел будет находится на непрерывной области поверхности
						одного блина. Пусть мы создадим раздел, скажем на 300ГБ, начиная с конца диска. Может случиться так,
						что он начнется реально на диске с его внешнего края, 280ГБ разместятся на одной поверхности
						одной пластины, а кусочек объемом 20ГБ попадет на другую пластину, начиная от шпинделя. Дело
						в том, что даже в рамках одной модели жесткого диска, конкретные экземпляры могут сильно отличаться.
						Вот к примеру, хотел производитель X сделать диск на 1ТБ. Из всей партии получилось, что 5% 
						винчестеров глючат. Разбирать и переделывать - долго и дорого. Выкинуть на свалку - тоже невыгодно.
						Вот начинают "чинить" такие диски модификацией прошивки. Отключили одну пластину - получился
						диск на 500ГБ - можно продать. Или если изначально планировалось сделать диск на 2ТБ, то может 
						выйти, что реально рабочие поверхности располагаются через одну, как в слоеном пироге. Или даже
						хуже: зоны скажем так, неуверенного чтения/записи (ну деформировалось немного коромысло головки 
						при сборке), в середине диска могут быть исключены из обращения на уровне прошивки. Конечно, 
						у дорогих серверных моделей, которые закупают серьезные организации, такое вряд ли встретишь. 
						Равно как и во всяких MacBook'ах, которые стоят в пять раз дороже, чем ходовые ноутбуки - 
						все подбирается в таких случаях индивидуально.
						
					<p>
						Так что танцевать вокруг геометрии жесткого диска - пустое дело (равно как и со всякой рандомизацией/
						уменьшением износа SSD - пустое дело - хотя я не сильно разбираюсь в этом вопросе). Лучше уделить
						внимание простой и понятной разметке. Например, разбить диск так, чтобы программы вроде fdisk 
						показывали "круглые" числа. Тогда и восстановить таблицу разделов (GPT и т.д.) можно будет 
						по памяти, без всяких утилит и тетрадных записей.
						
				<li>
					<p>SSD - для системы, HDD - для файлопомойки
					
					<p>
						Тут будут чисто мои суждения. Они никак не подкреплены практикой, потому что я ни разу не работал
						с SSD. Но идея простая: систему установить на быстрый диск, чтобы она работала быстро. А 
						некритичные к скорости программы, например, торрент-клиент, на медленный (скорость работы того же
						торрент-клиента определяется в решающей степени скоростью работы сети, а не жесткого диска). Но
						это немного не так. Да, в случае с медленным чтением, например, просмотр фильма, жесткий диск
						роли не играет (все равно человек не воспринимает фильм быстрее, чем он читается с диска). То же
						и с копированием - какая разница, скопируете вы файл за одну минуту или за 55 секунд (тем более,
						что скорость упрется в скорость шины USB - типичная ситуация для внешних накопителей). Но в 
						случае хитроумных программ (тот же торрент-клиент) все по-другому. "Умные" программы пишут на 
						диск кусочками, в несколько потоков. Ясное дело, что торрент-клиент будет ждать, пока данные 
						окажутся на диске. А это значит, что его буферы записи будут занимать место в оперативной памяти.
						Вспомогательные данные тоже будут висеть в кэше процессора до тех пор, пока очередь записи на 
						диск не освободится. Так что если уж решили ставить SSD, то откажитесь от HDD полностью.
			</ol>
			
		<h2>О бедном swap'е замолвите слово</h2>
		
		<p>
			Здесь речь пойдет о спецефичной Линуксовой фиче. Но для начала совершим краткую экскурсию в мир windows.
			
			В Windows вместо раздела подкачки используется файл подкачки pagefile.sys. Размеры этого файла можно менять в широких
			пределах. А для гибернации используется hiberfile.sys !!!надо уточнить!!!. Размер hiberfile.sys равен объему
			оперативной памяти. 
			
			В Linux обычно используется не файл подкачки, а раздел подкачки (хотя можно задействовать и файл, и то и 
			другое одновременно). Причем этот раздел не имеет файловой системы. То, что данные по "сырому" 
			пространству пишутся быстрее - очевидно. Но неочевиден тот факт, что раздел подкачки используется для хранения
			содержимого ОЗУ при переходе компьютера в гибернацию. Т.о. чтобы компьютер мог спокойно уснуть, нужно
			чтобы объем раздела подкачки превышал объем ОЗУ. Во сколько раз, зависит от конкретной ситуации. Пусть у нас
			есть ноутбук с объемом ОЗУ 2 ГБ. Тогда минимум 2ГБ понадобиться, для перехода в гибернацию. Но как только 
			что-то засвопится, то ноутбук заснуть не сможет: на своп-разделе просто не останется места. 
			Но лучше выделить под swap 4 ГБ. В этом случае тоже можно попасть в просак. Но только только в том случае,
			если засвопится более 2 ГБ. Чтобы столько данных выгрузилось в своп нужно очень сильно постараться. Скорее
			всего, что задолго до этого компьютер станет так глубоко задумываться, что поможет только спасительный 
			hard reset.
			
			Интересный вопрос: можно ли отключить своп (современные компьютеры с объемом ОЗУ 4 ГБ и без свопа
			чувствуют себя неплохо, потратить столько памяти можно разве что при использовании виртуаьных машин или 
			за декодированием видео каким-нибудь )
			и при этом оставить 
			гибернацию работающей? Т.е. чтобы раздел
			подкачки служил только целями гибернации, а система не могла выталкивать туда страницы?
			Надо проверить. Но
			насколько я помню из опыта использования LinuxMint, при отключении свопа swapoff -a гибернация перестает 
			работать вовсе.
			
			Самое обидное, что при шифровании диска "из коробки" установщик LinuxMint создает раздел swap как раз равным
			объему ОЗУ, но совершенно не годится для ноутбука. Придется либо самостоятельно настраивать зашифрованные 
			разделы (а заодно провести много приятных минут с LVM и LUKS), либо наращивать своп за счет файла подкачки, 
			что не замедлит сказаться на производительности. Либо провести еще больше времени за курением мануалов 
			к cgroups (т.е. настроить квоты таким образом, чтобы только программа гибернации могла писать в swap, 
			см. выше)
		
		
		
		
		
						
		<p>
			
			В <a href="how-to-set-up-offline-software-repository-part-1.html#note-apt-get-approach">части 1</a> 
			говорилось, что при использовании <strong>apt-get</strong> для скачивания будут доступны только пакеты, 
			соответствующие архитектуре компьютера, на который они загружаются. Но это не так. Даже "сидя" на 32-х битном
			дистрибутиве, скачать пакеты для 64-х битного дистрибутива возмножно. Достаточно добавить маленький суффикс 
			к имени
			пакета.
		
		<p>
			Пусть мы используем 32-х битный дистрибутив. Посмотрим, действительно ли это так:
<pre>
$ dpkg --print-architecture
i386
</pre>		

		<p>
			Теперь глянем, для каких еще архитектур есть доступные пакеты:
<pre>
$ dpkg --print-foreign-architectures
</pre>
		<p>
			И в ответ не получим ничего. Что ж, неудивительно: на 64-х битный дистрибутив можно установить 32-х битную
			программу, но наоборот - нельзя. Придеться добавить архитектуру (практического смысла в этом нет, просто 
			сделаем	это для демонстрации скачивания пакетов):
<pre>
$ sudo dpkg --add-architecture amd64
$ dpkg --print-foreign-architectures
amd64
</pre>
		<p>
			C 64-х битными пакетами вроде бы разобрались. А как насчет архитектур ARM, PowerPC и т.д.? В принципе, пакеты
			для этих архитектур есть в <a href="https://www.debian.org/releases/stable/">репозиториях Debian</a>, но не
			в Ubuntu и не в LinuxMint. Так что ограничимся <strong>i386</strong> и <strong>amd64</strong>.
		
		<p>
			Скачаем уже что-нибудь, например, текстовый редактор Vim для 64-х битного дистрибутива (не забыв
			перед этим выполнить <code>sudo apt-get update</code>):
<pre>
$ apt-get download vim:amd64
$ ls
vim_2%3a7.4.052-1ubuntu3.1_amd64.deb
</pre>

		<p>
			Для пущей уверенности можно зайти в свежескачанный <i>.deb</i>-файл с помощью 
			<a href="https://midnight-commander.org/">Midnight Commander</a>'а и убедиться правильности архитектуры, что
			и продемонстрировано на <a href="#illustration-1">рисунке 1</a>:
			
		<h4 id="illustration-1">Рисунок 1 - Примерное содержимое файла <i>INFO</i> внутри <i>.deb</i>-пакета</h4>
		<p>
			<img src="illustrations/vim-deb-contents.png" width="640px">

		<p>
			Чтобы скачать не только готовый двоичный пакет, но и исходные тексты придеться сначала добавить 
			соответствующие	ссылки. Но не в файл <i>/etc/apt/sources.list</i>. В Ubuntu (а следовательно, и в LinuxMint)
			для источников ПО есть каталог <i>/etc/apt/sources.list.d</i>. А уже в нем находятся файлы, которые содержат
			ссылки определенной категории. Посмотрим, что уже есть:
<pre>
$ ls -alh /etc/apt/sources.list.d/
total 24K
drwxr-xr-x 2 root root 4,0K Apr  2 11:23 .
drwxr-xr-x 6 root root 4,0K Apr  2 11:23 ..
-rw-r--r-- 1 root root   78 May 24  2016 bro.list
-rw-r--r-- 1 root root   59 Nov 27  2014 getdeb.list
-rw-r--r-- 1 root root  140 Apr  2 11:23 mc3man-trusty-media-trusty.list
-rw-r--r-- 1 root root  529 Nov 27  2014 official-package-repositories.list
</pre>

		<p>
			Откуда взялся файл <i>getdeb.list</i> я не знаю. Да и содержит этот файл единственную строчку, являющуюся 
			комментарием. <i>bro.list</i> и <i>mc3man-trusty-media-trusty.list</i> соответствуют сторонним репозиториям.
			А вот <i>official-package-repositories.list</i> - это список оригинальных репозиториев (по крайней 
			мере, так следует из названия). Посмотрим на его содержимое:
<pre>
$ cat /etc/apt/sources.list.d/official-package-repositories.list 
# Do not edit this file manually, use Software Sources instead.

deb http://packages.linuxmint.com rebecca main upstream import  #id:linuxmint_main
deb http://extra.linuxmint.com rebecca main #id:linuxmint_extra

deb http://archive.ubuntu.com/ubuntu trusty main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse

deb http://security.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse
deb http://archive.canonical.com/ubuntu/ trusty partner
</pre>			

		<p>
			Все вполне предсказуемо. Будет логичным предположение, что для подключения репозиториев с исходными текстами 
			потребуется создать еще один файл внутри каталога <i>/etc/apt/sources.list.d/</i> и напихать в него ссылок.
			Но угрожающий комментарий о нежелательности ручного редактирования файла наводит на мысль задействовать-таки
			утилиту с графическим интерфейсом. Найти и запустить ее не так уж сложно: 
			<code>gksudo software-sources</code>. Перед нами предстанет картинка, приведенная на 
			<a href="#illustration-2">рисунке 2</a>:
			
		<h4 id="illustration-2">
			Рисунок 2 - Управление источниками ПО посредством утилиты с графическим интерфейсом
		</h4>
		<p>
			<img src="illustrations/software-sources.png" width="640px">
			
		<p>
			Ставим флажок напротив <em>Enable source code repositories</em>, закрываем окно и на всякий случай делаем
			в консоли <code>sudo apt-get update</code> (выполнить команду в терминале будет надежнее, чем кликнуть по 
			кнопке <em>Update the cache</em> в правом верхнем углу окна уже просто потому, что в терминале мы увидим 
			информационные сообщения, и не придеться лезь в файл журнала). В выводе должны появиться строчки вроде 
			<em>... http://archive.ubuntu.com trusty/main Sources ...</em>.	А в каталоге <i>/etc/apt/sources.list.d</i> 
			появится новый файл <i>official-source-repositories.list</i> следующего содержания:
<pre>
deb-src http://packages.linuxmint.com rebecca main upstream import 

deb-src http://extra.linuxmint.com rebecca main

deb-src http://archive.ubuntu.com/ubuntu trusty main restricted universe multiverse
deb-src http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse

deb-src http://security.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse
deb-src http://archive.canonical.com/ubuntu/ trusty partner
</pre>			

		<p>
			Чтобы скачать исходный текст программы достаточно выполнить такую команду (для примера скачаем исходные 
			тексты редактора Vim):			
<pre>
$ apt-get source vim
</pre>

		<p>
			Посмотрим, что же реально скачалось:
<pre>
$ ls -1
vim-7.4.052
vim_7.4.052-1ubuntu3.1.debian.tar.gz
vim_7.4.052-1ubuntu3.1.dsc
vim_7.4.052.orig.tar.gz
</pre>

		<p>
			Именно то, что надо. Подробно останавливаться на описании скачанного не будем (дополнительные сведения можно
			почерпнуть в <code>man apt-get</code>). Очевидно, что указывать архитектуру при скачивании исходных текстов 
			не требуется.
			
		<p>
			В целом алгоритм создания собственного репозитория простой:
			<ol>
				<li>
					Cоставляем список архитектур (в нашем случае их будет всего две: <strong>i386</strong> и 
					<strong>amd64</strong>).
				
				<li>
					Составляем список пакетов для скачивания.

				<li>
					Для каждого пакета из списка выполняем:
					<ul>
						<li><code>apt-get source &lt;имя_пакета&gt;</code>
						<li><code>apt-get download &lt;имя_пакета&gt;:i386</code>
						<li><code>apt-get download &lt;имя_пакета&gt;:amd64</code>
					 </ul>
			</ol>
		<p>
			О том, как получить список всех доступных пакетов уже подробно рассказано в ответе на вопрос 
<a href="https://askubuntu.com/questions/160897/how-do-i-search-for-available-packages-from-the-command-line">
	How do I search for available packages from the command-line?</a>. 
	
		<p>
			Остается только определиться, каким именно образом мы будем складировать скачанное добро. 
			
		<p>
			Можно поступить просто:	разложить скачанное в два каталога: один - для двоичных пакетов, другой - для 
			исходных текстов.
			
		<p>
			Можно разбить на категории. Узнать, к какой категории (впрочем, они довольно условны) относится тот или иной
			пакет можно с помощью команды <strong>apt-cache</strong>. Например, 			
<pre>
$ apt-cache show vim
Package: vim
Priority: optional
Section: editors
...
</pre>
		<p>
			Как видим, Vim относится к категории текстовых редакторов. В принципе, такое разбиение на группы нам вполне 
			подходит. Но, поскольку мы создает собственный репозиторий, лучше будет сохранить информацию о том, откуда 
			был скачан тот или иной пакет. Т.е. чтобы наш репозиторий повторял структуру официального репозитория Ubuntu
			(LinuxMint и т.д.). Как же получить информацию о том, откуда реально будет скачиваться тот или иной пакет?
			
		<p>
			Для начала попробуем воспользоваться командой <strong>apt-cache</strong>:
<pre>
$ apt-cache showpkg vim
Package: vim
Versions: 
2:7.4.052-1ubuntu3.1 (/var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty-updates_main_binary-i386_Packages) 
(/var/lib/apt/lists/security.ubuntu.com_ubuntu_dists_trusty-security_main_binary-i386_Packages) 
(/var/lib/dpkg/status)
 Description Language: 
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages
                  MD5: 59e8b8f7757db8b53566d5d119872de8
 Description Language: en
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_i18n_Translation-en
                  MD5: 59e8b8f7757db8b53566d5d119872de8

2:7.4.052-1ubuntu3 (/var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-i386_Packages)
 Description Language: 
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages
                  MD5: 59e8b8f7757db8b53566d5d119872de8
 Description Language: en
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_i18n_Translation-en
                  MD5: 59e8b8f7757db8b53566d5d119872de8
...
</pre>
		<p>
			Из строчек вроде 
			<em>/var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages</em>
			можно вычленить имя каталога из оригинального репозитория. 
			<em>archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages</em> подоздрительно похоже на 
			уже упоминавшуюся в <a href="how-to-set-up-offline-software-repository-part-1.html#table-1">части 1</a> 
			строчку <em>archive.ubuntu.com/ubuntu trusty main</em>, только записанное в немного другом порядке и с 
			символами 
			подчеркивания вместо слеша. В принципе, такого рода строчек достаточно, чтобы восстановить структуру 
			каталогов 
			оринигального репозитория. 
			
			
		<h2>Кажется, мы придумали кое-что получше</h2>
		
		<p>
			А именно: использование команды <strong>apt-get</strong>
			c опцией <code>--print-uris</code>. Т.о. можно узнать ссылку на оригинальный файл (сам же пакет при 
			использовании
			этого параметра загружен на будет, подробности см. в <code>man apt-get</code>). Например, узнаем, где  
			в оригинальном репозитории расположен двоичный пакет редактора Vim:
			
<pre>
$ apt-get --print-uris download vim
'http://archive.ubuntu.com/ubuntu/pool/main/v/vim/vim_7.4.052-1ubuntu3.1_i386.deb' ...
</pre>			
		<p>
			Т.о. последний подход лучше всех вышеперечисленных. Но, как всегда, при работе с параметром 
			<code>--print-uris</code> есть несколько нюансов. 
			
		<p>
			Во-первых, лучше всего ставить параметр перед действием 
			в командной строке. Да,
			команды 
			<ul>
				<li><code>apt-get --print-uris download vim</code>
				<li><code>apt-get download --print-uris vim</code>
				<li><code>apt-get download vim --print-uris</code>
			</ul>
			выдадут одинаковый результат. Но все же лучше будет
			разместить <code>--print-uris</code> сразу после <code>apt-get</code>.
		
		<p>
			Во-вторых, <code>apt-get --print-uris download ...</code> ничего не напечатает, если пакет уже загружен в 
			текущий	каталог. Проверим это вживую (в начале каждой строки стоит ее порядковый номер для удобства):	
<pre>
1	$ apt-get --print-uris download vim
'http://archive.ubuntu.com/ubuntu/pool/main/v/vim/vim_7.4.052-1ubuntu3.1_i386.deb' ...
2	$ apt-get download vim
Get:1 http://archive.ubuntu.com/ubuntu/ trusty-updates/main vim i386 2:7.4.052-1ubuntu3.1 [876 kB]
Fetched 876 kB in 1s (498 kB/s)
3	$ apt-get --print-uris download vim
4	$ rm vim_2%3a7.4.052-1ubuntu3.1_i386.deb 
5	$ apt-get --print-uris download vim
 	'http://archive.ubuntu.com/ubuntu/pool/main/v/vim/vim_7.4.052-1ubuntu3.1_i386.deb' ...
</pre>			
		<p>
			Как видим, команда №3 ничего не напечатала (к моменту ее выполнения пакет уже был скачан в текущий каталог). 
			Но после
			удаления файла пакета Vim из текущего каталога команда №5 напечатала ссылку как ни в чем не бывало 
			<sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>.		

        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Ссылки, которые выдает <code>apt-get --print-uris download ...</code> можно использовать напрямую,
						т.е. можно использовать для скачивания не <strong>apt-get</strong>, а, например, <strong>wget</strong>.
						Но лучше использовать все-таки <strong>apt-get</strong>. И не потому что это более элегантно (особенно
						в случае скачивания исходных текстов - поди разберись, что там за три файла), а потому, что 
						<strong>apt-get</strong> еще проверяет контрольные суммы и т.д.
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
