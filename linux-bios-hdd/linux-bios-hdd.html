<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Толстая настройка BIOS и подготовка диска перед установкой LinuxMint</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/linux-bios-hdd/linux-bios-hdd.html">
				Толстая настройка BIOS и подготовка диска перед установкой LinuxMint
			</a>
		</h1>
		
		<h3>[2017, Июль]</h3>
		
		<h2>Введение</h2>
		
		<p>
			Уже сколько было написано статей и книг про BIOS и тонкую настройку ПК. Во времена Windows XP "оптимизаторы"
			боролись за каждый мегабайт. В какой-то статье (эта статья мини-книга была оформлена как самостоятельный 
			exe-файлованный exe-файл, назывался он "учебка" вроде) про ускорение Windows XP освобождение 50 мегабайт 
			дискового пространства считалось достижением. Так что не стоит особенно сильно беспокоится об оптимизации. 
			Вместо того, чтобы освобождать крохи, лучше сразу удалить с компьютера ненужные фильмы, книги. Да, у меня 
			когда-то было гигабайта два электронных книг. Всяких разных: текстовые файлы, оформленные под канонам DOS
			(только ASCII - cp866, и ширина 80 символов), с любовью составленные CHM-файлы, отсканированные книги в PDF
			и DjVU, ... И сколько я из этих книг прочитал? Хорошо, если десяток (в любом случае, не больше двадцати).
			Так что оптимизировать надо только самое необходимое и без фанатизма. Впрочем, если ускорять компьютер 
			исходя только лишь из практичных соображений, то не стоит и начинать. Главное, чтобы было весело.
			
		<h2>Начнем с железа</h2>
		
		<p>
			В BIOS много чего можно настроить. Оставим в стороне настройку UEFI, GPT, разбиение на разделы, безопасных 
			загрузчиков и т.д. Главное, что нужно сделать в BIOS - включить режим AHCI для жесткого диска !!!тут
			будет ссылка на подробное описание, т.е. на статью на английском!!!. Вполне возможно, что по-умолчанию 
			будет включен режим
			эмуляции IDE (надо же как-то FreeDOS устанавливать на новые компьютеры). Если жесткий диск работает в режиме
			эмуляции IDE, то о скорости можно забыть.
			
		<p>
			Тут же можно сказать пару слов о питании, охлаждении и т.п. Но это и так понятно. Чтобы перегреть жесткий 
			диск (про SSD в этой статье речь не идет) нужно очень постараться. Хотя факт остается фактом: технике 
			необходимо своевременное обслуживание. Чистка от пыли, замена термопасты, внимание к болтам (вибрация 
			убивает печатные платы) - все это очень важно. И, конечно же, главное - безопасность. Лучше не лезть куда
			не надо и не разгонять ничего (и не стоит усердствовать с самостоятельной разборкой-сборкой ноутбука - времени
			убивается куча, а толку мало, да и не рассчитана современная техника на разборку-сборку, сервисный центр 
			может сделать это самостоятельно, ).
			
		<p>
			Так что перед тем, как включать и начинать оптимизировать драндулет на Sempron 3000+ стоит прочистить его 
			от пыли.
			
		<h2>И продолжим на BIOS</h2>	
			
		<p>
			На первых порах не стоит запирать BIOS паролем. Пароль всегда можно установить позже. Восстановить же
			забытый пароль - морока, особенно в случае с ноутбуком - придется его разбирать, искать контакты или 
			батарейку. Не очень приятное это (да и вообще рискованное) удовольствие. А если ноутбук на гарантии, забот
			прибавляется. Везти в сервисный центр, чтобы не пропала гарантия, и платить за это - ну его нафиг.
			
		<p>
			Также не стоит заморачиваться с шифрованием. Нет, шифровать домашнию директорию или даже весь жесткий диск 
			нужно. Более того, эти возможности доступны в современных популярных дистрибутивах "из коробки". Такие 
			"коробочные" решения, тем не менее, оставляют на диске незашифрованные разделы (нужно ведь загрузить хоть-что
			, хоть какой-нибудь код, который поможет начать расшифровку и загружаться дальше). В частности, в LinuxMint
			это раздел /boot (т.е. для этой директории создается незашифрованный раздел, форматируется он в файловую систему
			ext2, что и без шифрование увеличивает риск его логического повреждения, но в то же время уменьшает 
			физический износ). Особенно упоротые линуксоиды шифруют еще и /boot, и ставят пароль на grub (а может, и
			grub шифруют - кто знает). Но это слишком. Лучше уж тогда носить отдельную флэшку (Read-Only, естественно) с 
			загрузчиком, и загружаться с нее. А уже она будет загружать основную систему. Но как тогда обновлять загрузчик?
			Хрень в итоге получается.
			
		<p>
			Для чего вообще нужно шифрование? Чтобы никто без вашего ведома не прочитал Ваши данные. Лишиться данных 
			легко - достаточно просто потерять ноутбук. Конечно, с полностью зашифрованным компьютером вы вообще в 
			шоколаде. Даже наши спецслужбы вряд ли смогут взломать (хотя американские взломают как нефиг, у них в каждом
			чипе по 2 бэкдора, если уж и строить "полностью безопасный зашифрованный ноутбук", то делать это нужно на 
			полностью открытом аппаратном обеспечении, например, Raspberry PI. И еще придется отказаться от многих 
			прелестей современных Линуксов). "Чуть-чуть" незашифрованный комп подстерегает только одна опастность: его
			протроянивание. Представьте себе, что вы потеряли ноутбук. Какие-то нехорошие люди ноутбук нашли (или спец
			службы вломились в ваш дом, когда вас не было). И вместо того, чтобы забрать ноутбук себе, продать его и т.п.
			они открыли раздел /boot (он-то не зашифрован!), установили туда троянов, которые активизируются на самой
			ранней стадии загрузки системы, и отдали ноутбук вам. Вы же, наивный линуксоид, ошибочно предполагаете, что
			ноутбук остался прежним. Такой сценарий возможен, но маловероятен (скорее, вашего кремниевого друга пропьют,
			вместе с файлами - но файлы никто уж не прочитает, главное, не скидывать ничего личного в каталог /boot).
			А вообще, лучше и boot зашифровать нафиг. Или не шифровать? Нет, лучше не шифровать. Отсутствие шифрование 
			будет консистентно с отсутствием паролей на BIOS и на GRUB: гораздо легче запомнить, что в безопасности 
			только данные, а всякая обвязка (загрузчики и т.п.) требую повышенного внимания.
			
		<p>
			О том, что просто необходимо записать ключ шифрования на первое время где-то на листке (до тех пор, пока
			мы не настроим специальную флэшку !!!тут будет ссылка на описание процесса, англоязычный источник!!!), бумага
			будет жизненно необходима. 
			
		<p>
			Еще один момент: по-умолчанию установщик LinuxMint (при выборе опции "Use the entire disk" !!!или как там
			она называется!!!) создает один большой раздел, и пихает туда и /, и /home. Что на первых порах расстраивает.
			Но беспокоитьс не стоит. Создание отдельного раздела для /home помогает только в одном: при переустановки 
			системы (не нужно возиться в переносом настроек программ и документов). Но никакой дополнительной защиты 
			от случайного повреждения данных это не дает. К тому же, при переустановке системы (по сути, установки
			на зашифрованный раздел), старое все равно придется (предварительно забэкапив) отформатировать. Или уж 
			перешифровывать домашний раздел после установки. В любом случае, возни будет много. Да и насколько проще 
			с одним-единственным разделом! В случае возникновения аварийной ситуации один раздел будет намного проще 
			смонтировать при загрузке с Live-CD.
			
		
	
		<p>
			Все-таки скажу немного слов о разбиении на разделы. Здесь предполагается, что при установке LinuxMint
			используется пункты Erase disk and install LinuxMint (!!!или как он там называется!!!) и 
			Encrypt LinuxMint installation. Так что каким образом
			огранизовано разбиение на разделы (т.е. включена ли в биос GPT или по-старинке MBR) - не важно, при установке
			будет задействован LVM. Тут можно спросить: как же так, ведь принято создавать два раздела - один для '/', 
			второй для '/home'. На самом деле при шифровании всего диска это не имеет значения. Если что-то сломается,
			то полетят оба раздела. Но насколько проще подключить зашифрованный том при загрузке с LIVE CD , если томов 
			всего одна штука!
			
		<p>
			Еще перед установкой системы нужно включить все возможные устройства в BIOS. Это необходимо сделать для того,
			чтобы установщик LinuxMint нашел и установил драйверы для как можно большего количества устройств. Ненужное
			устройство (например, Bluetooth) можно будет отключить в BIOS позже (конечно же, главная причина - 
			снижение энергопотребления). Удалить драйверы тоже можно будет потом.
			Но лучше оставить драйверы (разве только убрать их из автоматической загрузки). Много места на диске они не 
			занимают. Мало ли понадобиться тот же Bluetooth или драйвер 3G модема. Включить в BIOS (пароль от BIOS
			вспоминать же не придет) устройство - дело одной
			минуты.
			
		<h2>Все-таки несколько слов о разметке диска</h2>
		
		<p>
			Часто в Интернете можно встретить устаревшие рекомендации по ускорению жесткого диска (про SSD ничего не 
			знаю, знаю только, что толку от SSD мало в пересчете на цену. Рискну предположить, что чтобы почувствовать 
			разницу между HDD и SSD нужно установить как минимум два твердотельных накопителя, чтобы данные 
			читались/записывались одновременно на оба диска - parallel raid или как эта штука называется, и чтобы SSD были
			подключены через шину PCI-Express. Да, скорости у SATA II и SATA III с лихвой хватит, но когда говорят о 
			скорости передачи данных, то имеют ввиду именно скорость, т.е. "крейсерскую" скорость. Очевидно, что для 
			настольного компьютера большее значение имеет задержка перед операцией чтения/записи. Последовательный 
			интерфейс, какой бы быстрый он ни был, не может обеспечить низкую задержку !!!хрень какая-то - надо 
			погуглить!!! А у шины PCI-Express линий - хоть отбавляй).
			
			Какие же можно встретить заблуждения?
			
			<ol>
				<li>
					<p>
						Системный раздел (он же '/') нужно создавать небольшого размера. Не знаю, откуда берет начало эта 
						традиция. Может из простой аналогии, что в маленьком стоге сена иголку найти проще, чем в большом?
						Т.е. если вдруг нам понадобился некоторый файл (небольшой файл), то мол на маленьком разделе он 
						быстрее отыщется. В принципе, логично. И так оно и было во времена MS-DOS. Система, будучи 
						установленной на жестком диске со всеми драйверами, прикладными программами и т.п. занимала 
						от силы мегабайт 200. Но при этом файлы по-большей части оставались неизменными. Программы тогда 
						обновлялись редко, вручную. Прикладные программы, если и создавали в процессе работы временные файлы,
						то делали это не так часто, как современные приложения (уже наверное даже в самой пустяковой 
						программе используется БД SQLite для хранения пары-тройки параметров конфигурации). Плюс еще само
						устройство DOS: каждой программе - свой каталог, в котором хранятся и исполняемые файлы, и настройки,
						и модули. Другое дело современный Linux: файлы, принадлежащие одной и той же программе, размазаны по
						всему диску. Так что как диск не дефрагментируй, никак не получится собрать рядом файлы, принадлежащие
						одной программе.
					
					<p>
						В общем, все вышесказанное приводит к мысли, что чем больше свободного места на разделе - тем
						лучше.
						Файловая система Ext4 в 
						дефрагментации не нуждается, но только лишь потому, что меры по предотвращению фрагментации 
						принимаются в самом начале записи файла на диск.  У файловой системы появляется больше возможностей для выбора. Например, есть большой
						кусок непрерывного свободного пространства - отлично, разместим там увесистый файл. И т.д. и т.п.
						(тут уместно будет всмопнит Windows - там для успешной дефрагментации требовалось не менее 15%
						свободного места на диске. Вполне возможно, что это было вызвано ограничениями реализации 
						штатного дефраментатора - в самом деле, почему не 10%, а именно 15%. Но рациональное зерно в этом
						есть).
						
						Вероятно, современным файловым
						системам (всякие там ZFS, т.е. те, что применяют copy-on-write - !!!!нужно погуглить и 
						проверить!!!) свободное место вовсе не помешает. Так что вывод такой: если планируется 
						использовать 20 ГБ для системы (а примерно столько и требуется LinuxMint в редакции с Cinnamon),
						то лучше создать раздел минимум на 40ГБ.
				
				<li>
					<p>
						Расположение раздела на диске играет роль.
						
					<p>
						На самом деле нет. Да, давным-давно кластеры на диске в угловом	измерении они были одинаковые. 
						Из-за этого они были неодинаковые в декартовых координатах - на краю диска кластеры получались
						большими, чем в начале (ведь диаметр внешней окружности больше внутренней). Т.е. образом данные
						с края диска читались, при прочих равных условиях, медленнее, чем из начала или середины. В 
						современных дисках кластеры имеют одинаковый размер, а следовательно, равномерно распределены
						по поверхности диска. Теперь получается наоборот - лучше создавать раздел в конце диска. Да, 
						угловая скорость вращения диска что на окружности, что у шпинделя одинаковая. Но вот линейная
						скорость на окружности больше. А поскольку кластеры одинаковых декартовых размеров, то и читаться
						данные с внешнего края диска будут быстрее! Но по этому поводу заморачиваться не нужно. Нет
						никакой гарантии, отсчет кластеров (а сейчас как известно, используется линейная адресация - 
						ОС видит весь диск как большой байтовый массив) начинается с внутреннего края диска. Возможно, 
						что начинается он как раз в внешнего. Кроме этого, 
						нет никакой гарантии, что выделенный нами раздел будет находится на непрерывной области поверхности
						одного блина. Пусть мы создадим раздел, скажем на 300ГБ, начиная с конца диска. Может случиться так,
						что он начнется реально на диске с его внешнего края, 280ГБ разместятся на одной поверхности
						одной пластины, а кусочек объемом 20ГБ попадет на другую пластину, начиная от шпинделя. Дело
						в том, что даже в рамках одной модели жесткого диска, конкретные экземпляры могут сильно отличаться.
						Вот к примеру, хотел производитель X сделать диск на 1ТБ. Из всей партии получилось, что 5% 
						винчестеров глючат. Разбирать и переделывать - долго и дорого. Выкинуть на свалку - тоже невыгодно.
						Вот начинают "чинить" такие диски модификацией прошивки. Отключили одну пластину - получился
						диск на 500ГБ - можно продать. Или если изначально планировалось сделать диск на 2ТБ, то может 
						выйти, что реально рабочие поверхности располагаются через одну, как в слоеном пироге. Или даже
						хуже: зоны скажем так, неуверенного чтения/записи (ну деформировалось немного коромысло головки 
						при сборке), в середине диска могут быть исключены из обращения на уровне прошивки. Конечно, 
						у дорогих серверных моделей, которые закупают серьезные организации, такое вряд ли встретишь. 
						Равно как и во всяких MacBook'ах, которые стоят в пять раз дороже, чем ходовые ноутбуки - 
						все подбирается в таких случаях индивидуально.
						
					<p>
						Так что танцевать вокруг геометрии жесткого диска - пустое дело (равно как и со всякой рандомизацией/
						уменьшением износа SSD - пустое дело - хотя я не сильно разбираюсь в этом вопросе). Лучше уделить
						внимание простой и понятной разметке. Например, разбить диск так, чтобы программы вроде fdisk 
						показывали "круглые" числа. Тогда и восстановить таблицу разделов (GPT и т.д.) можно будет 
						по памяти, без всяких утилит и тетрадных записей.
						
				<li>
					<p>SSD - для системы, HDD - для файлопомойки
					
					<p>
						Тут будут чисто мои суждения. Они никак не подкреплены практикой, потому что я ни разу не работал
						с SSD. Но идея простая: систему установить на быстрый диск, чтобы она работала быстро. А 
						некритичные к скорости программы, например, торрент-клиент, на медленный (скорость работы того же
						торрент-клиента определяется в решающей степени скоростью работы сети, а не жесткого диска). Но
						это немного не так. Да, в случае с медленным чтением, например, просмотр фильма, жесткий диск
						роли не играет (все равно человек не воспринимает фильм быстрее, чем он читается с диска). То же
						и с копированием - какая разница, скопируете вы файл за одну минуту или за 55 секунд (тем более,
						что скорость упрется в скорость шины USB - типичная ситуация для внешних накопителей). Но в 
						случае хитроумных программ (тот же торрент-клиент) все по-другому. "Умные" программы пишут на 
						диск кусочками, в несколько потоков. Ясное дело, что торрент-клиент будет ждать, пока данные 
						окажутся на диске. А это значит, что его буферы записи будут занимать место в оперативной памяти.
						Вспомогательные данные тоже будут висеть в кэше процессора до тех пор, пока очередь записи на 
						диск не освободится. Так что если уж решили ставить SSD, то откажитесь от HDD полностью.
			</ol>
			
		<h2>О бедном swap'е замолвите слово</h2>
		
		<p>
			Здесь речь пойдет о спецефичной Линуксовой фиче. Но для начала совершим краткую экскурсию в мир windows.
			
			В Windows вместо раздела подкачки используется файл подкачки pagefile.sys. Размеры этого файла можно менять в широких
			пределах. А для гибернации используется hiberfile.sys !!!надо уточнить!!!. Размер hiberfile.sys равен объему
			оперативной памяти. 
			
			В Linux обычно используется не файл подкачки, а раздел подкачки (хотя можно задействовать и файл, и то и 
			другое одновременно). Причем этот раздел не имеет файловой системы. То, что данные по "сырому" 
			пространству пишутся быстрее - очевидно. Но неочевиден тот факт, что раздел подкачки используется для хранения
			содержимого ОЗУ при переходе компьютера в гибернацию. Т.о. чтобы компьютер мог спокойно уснуть, нужно
			чтобы объем раздела подкачки превышал объем ОЗУ. Во сколько раз, зависит от конкретной ситуации. Пусть у нас
			есть ноутбук с объемом ОЗУ 2 ГБ. Тогда минимум 2ГБ понадобиться, для перехода в гибернацию. Но как только 
			что-то засвопится, то ноутбук заснуть не сможет: на своп-разделе просто не останется места. 
			Но лучше выделить под swap 4 ГБ. В этом случае тоже можно попасть в просак. Но только только в том случае,
			если засвопится более 2 ГБ. Чтобы столько данных выгрузилось в своп нужно очень сильно постараться. Скорее
			всего, что задолго до этого компьютер станет так глубоко задумываться, что поможет только спасительный 
			hard reset.
			
			Интересный вопрос: можно ли отключить своп (современные компьютеры с объемом ОЗУ 4 ГБ и без свопа
			чувствуют себя неплохо, потратить столько памяти можно разве что при использовании виртуаьных машин или 
			за декодированием видео каким-нибудь )
			и при этом оставить 
			гибернацию работающей? Т.е. чтобы раздел
			подкачки служил только целями гибернации, а система не могла выталкивать туда страницы?
			Надо проверить. Но
			насколько я помню из опыта использования LinuxMint, при отключении свопа swapoff -a гибернация перестает 
			работать вовсе.
			
			Самое обидное, что при шифровании диска "из коробки" установщик LinuxMint создает раздел swap как раз равным
			объему ОЗУ, но совершенно не годится для ноутбука. Придется либо самостоятельно настраивать зашифрованные 
			разделы (а заодно провести много приятных минут с LVM и LUKS), либо наращивать своп за счет файла подкачки, 
			что не замедлит сказаться на производительности. Либо провести еще больше времени за курением мануалов 
			к cgroups (т.е. настроить квоты таким образом, чтобы только программа гибернации могла писать в swap, 
			см. выше). Но проще всего настроить vm.swapiness=0 - на ядрах старше !!!не помню, какая тут версия!!! такое
			значение опции отрубает swap нафиг (конечно, как-то страшновато сидеть с двумя гигабайтами ОЗУ и без свопа,
			но, с другой стороны, интересно, что из этого получится).
			
		<p>
			Будьте готовы к тому, что в вашем любимом дистрибутиве после установки (а может быть, и до ее начала, 
			особенно актуально в случае ноутбуков), не заработает какое-нибудь жизненно важное устройство. Ннапример, 
			WiFi (хотя к этом все уже давно привыкли) или 3G-модем (систему перед началом настройки нужно обновить в 
			первую очередь!) или даже тачпад (особую радость доставляют установщики с GUI - а таких большинство сейчас -
			вообще фиг установишь систему). Так что желательно запастить Ethernet-кабелем, мышкой (проводная на всякий 
			случай) и несколькими установочными флэшками (а в случае наличия в компе оптического привода загрузочный
			диск не помешает). Ведь если вы записывали загрузочные флэшки в Линуксе, наверняка они глючные.
			
		
		<h2>Пара замечаний о Systemd</h2>	
			
		<p>
			Может сложиться впечатление, что новые релизы Ubuntu лучше, чем старые. Да, в новых версиях новые драйверы,
			новые программы и т.д. В старой Убунте может не оказаться драйвера нужного устройства. Но все-таки, лучше, 
			когда устройство не работает вовсе, чем когда оно работает, но отваливается время от времени. Например, 
			в ноутбуке Acer !!!уточнить модель!!! в Ubuntu 16.04 глючит апплет для Network Manager'а. После выхода ноутбука
			из спящего режима или гибернации апплет перестает показывать индикатор мощности сигнала и перестает показывать
			доступные WiFi-сети. Чтобы все заработало, нужно "прибить" аппет и запустить его снова. Вполне возможно, что
			этот глюк вызван окружением рабочего стола (у меня Openbox). Но более вероятно, что Network Manager прослушивает
			происходящие в системе события. И после выхода компьютера из спящего режима апплет сам себя перезапускает
			(или повторно сканирует WiFi-сети). Systemd, видимо, просто не рассылает такие сообщения. В любом случае, 
			Systemd доставит больше хлопот, чем пользы (в том числе и в плане потребления ресурсов).
		
		
		
		
						
		<p>
			
			В <a href="how-to-set-up-offline-software-repository-part-1.html#note-apt-get-approach">части 1</a> 
			говорилось, что при использовании <strong>apt-get</strong> для скачивания будут доступны только пакеты, 
			соответствующие архитектуре компьютера, на который они загружаются. Но это не так. Даже "сидя" на 32-х битном
			дистрибутиве, скачать пакеты для 64-х битного дистрибутива возмножно. Достаточно добавить маленький суффикс 
			к имени
			пакета.
		
		<p>
			Пусть мы используем 32-х битный дистрибутив. Посмотрим, действительно ли это так:
<pre>
$ dpkg --print-architecture
i386
</pre>		

		<p>
			Теперь глянем, для каких еще архитектур есть доступные пакеты:
<pre>
$ dpkg --print-foreign-architectures
</pre>
		<p>
			И в ответ не получим ничего. Что ж, неудивительно: на 64-х битный дистрибутив можно установить 32-х битную
			программу, но наоборот - нельзя. Придеться добавить архитектуру (практического смысла в этом нет, просто 
			сделаем	это для демонстрации скачивания пакетов):
<pre>
$ sudo dpkg --add-architecture amd64
$ dpkg --print-foreign-architectures
amd64
</pre>
		<p>
			C 64-х битными пакетами вроде бы разобрались. А как насчет архитектур ARM, PowerPC и т.д.? В принципе, пакеты
			для этих архитектур есть в <a href="https://www.debian.org/releases/stable/">репозиториях Debian</a>, но не
			в Ubuntu и не в LinuxMint. Так что ограничимся <strong>i386</strong> и <strong>amd64</strong>.
		
		<p>
			Скачаем уже что-нибудь, например, текстовый редактор Vim для 64-х битного дистрибутива (не забыв
			перед этим выполнить <code>sudo apt-get update</code>):
<pre>
$ apt-get download vim:amd64
$ ls
vim_2%3a7.4.052-1ubuntu3.1_amd64.deb
</pre>

		<p>
			Для пущей уверенности можно зайти в свежескачанный <i>.deb</i>-файл с помощью 
			<a href="https://midnight-commander.org/">Midnight Commander</a>'а и убедиться правильности архитектуры, что
			и продемонстрировано на <a href="#illustration-1">рисунке 1</a>:
			
		<h4 id="illustration-1">Рисунок 1 - Примерное содержимое файла <i>INFO</i> внутри <i>.deb</i>-пакета</h4>
		<p>
			<img src="illustrations/vim-deb-contents.png" width="640px">

		<p>
			Чтобы скачать не только готовый двоичный пакет, но и исходные тексты придеться сначала добавить 
			соответствующие	ссылки. Но не в файл <i>/etc/apt/sources.list</i>. В Ubuntu (а следовательно, и в LinuxMint)
			для источников ПО есть каталог <i>/etc/apt/sources.list.d</i>. А уже в нем находятся файлы, которые содержат
			ссылки определенной категории. Посмотрим, что уже есть:
<pre>
$ ls -alh /etc/apt/sources.list.d/
total 24K
drwxr-xr-x 2 root root 4,0K Apr  2 11:23 .
drwxr-xr-x 6 root root 4,0K Apr  2 11:23 ..
-rw-r--r-- 1 root root   78 May 24  2016 bro.list
-rw-r--r-- 1 root root   59 Nov 27  2014 getdeb.list
-rw-r--r-- 1 root root  140 Apr  2 11:23 mc3man-trusty-media-trusty.list
-rw-r--r-- 1 root root  529 Nov 27  2014 official-package-repositories.list
</pre>

		<p>
			Откуда взялся файл <i>getdeb.list</i> я не знаю. Да и содержит этот файл единственную строчку, являющуюся 
			комментарием. <i>bro.list</i> и <i>mc3man-trusty-media-trusty.list</i> соответствуют сторонним репозиториям.
			А вот <i>official-package-repositories.list</i> - это список оригинальных репозиториев (по крайней 
			мере, так следует из названия). Посмотрим на его содержимое:
<pre>
$ cat /etc/apt/sources.list.d/official-package-repositories.list 
# Do not edit this file manually, use Software Sources instead.

deb http://packages.linuxmint.com rebecca main upstream import  #id:linuxmint_main
deb http://extra.linuxmint.com rebecca main #id:linuxmint_extra

deb http://archive.ubuntu.com/ubuntu trusty main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse

deb http://security.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse
deb http://archive.canonical.com/ubuntu/ trusty partner
</pre>			

		<p>
			Все вполне предсказуемо. Будет логичным предположение, что для подключения репозиториев с исходными текстами 
			потребуется создать еще один файл внутри каталога <i>/etc/apt/sources.list.d/</i> и напихать в него ссылок.
			Но угрожающий комментарий о нежелательности ручного редактирования файла наводит на мысль задействовать-таки
			утилиту с графическим интерфейсом. Найти и запустить ее не так уж сложно: 
			<code>gksudo software-sources</code>. Перед нами предстанет картинка, приведенная на 
			<a href="#illustration-2">рисунке 2</a>:
			
		<h4 id="illustration-2">
			Рисунок 2 - Управление источниками ПО посредством утилиты с графическим интерфейсом
		</h4>
		<p>
			<img src="illustrations/software-sources.png" width="640px">
			
		<p>
			Ставим флажок напротив <em>Enable source code repositories</em>, закрываем окно и на всякий случай делаем
			в консоли <code>sudo apt-get update</code> (выполнить команду в терминале будет надежнее, чем кликнуть по 
			кнопке <em>Update the cache</em> в правом верхнем углу окна уже просто потому, что в терминале мы увидим 
			информационные сообщения, и не придеться лезь в файл журнала). В выводе должны появиться строчки вроде 
			<em>... http://archive.ubuntu.com trusty/main Sources ...</em>.	А в каталоге <i>/etc/apt/sources.list.d</i> 
			появится новый файл <i>official-source-repositories.list</i> следующего содержания:
<pre>
deb-src http://packages.linuxmint.com rebecca main upstream import 

deb-src http://extra.linuxmint.com rebecca main

deb-src http://archive.ubuntu.com/ubuntu trusty main restricted universe multiverse
deb-src http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse

deb-src http://security.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse
deb-src http://archive.canonical.com/ubuntu/ trusty partner
</pre>			

		<p>
			Чтобы скачать исходный текст программы достаточно выполнить такую команду (для примера скачаем исходные 
			тексты редактора Vim):			
<pre>
$ apt-get source vim
</pre>

		<p>
			Посмотрим, что же реально скачалось:
<pre>
$ ls -1
vim-7.4.052
vim_7.4.052-1ubuntu3.1.debian.tar.gz
vim_7.4.052-1ubuntu3.1.dsc
vim_7.4.052.orig.tar.gz
</pre>

		<p>
			Именно то, что надо. Подробно останавливаться на описании скачанного не будем (дополнительные сведения можно
			почерпнуть в <code>man apt-get</code>). Очевидно, что указывать архитектуру при скачивании исходных текстов 
			не требуется.
			
		<p>
			В целом алгоритм создания собственного репозитория простой:
			<ol>
				<li>
					Cоставляем список архитектур (в нашем случае их будет всего две: <strong>i386</strong> и 
					<strong>amd64</strong>).
				
				<li>
					Составляем список пакетов для скачивания.

				<li>
					Для каждого пакета из списка выполняем:
					<ul>
						<li><code>apt-get source &lt;имя_пакета&gt;</code>
						<li><code>apt-get download &lt;имя_пакета&gt;:i386</code>
						<li><code>apt-get download &lt;имя_пакета&gt;:amd64</code>
					 </ul>
			</ol>
		<p>
			О том, как получить список всех доступных пакетов уже подробно рассказано в ответе на вопрос 
<a href="https://askubuntu.com/questions/160897/how-do-i-search-for-available-packages-from-the-command-line">
	How do I search for available packages from the command-line?</a>. 
	
		<p>
			Остается только определиться, каким именно образом мы будем складировать скачанное добро. 
			
		<p>
			Можно поступить просто:	разложить скачанное в два каталога: один - для двоичных пакетов, другой - для 
			исходных текстов.
			
		<p>
			Можно разбить на категории. Узнать, к какой категории (впрочем, они довольно условны) относится тот или иной
			пакет можно с помощью команды <strong>apt-cache</strong>. Например, 			
<pre>
$ apt-cache show vim
Package: vim
Priority: optional
Section: editors
...
</pre>
		<p>
			Как видим, Vim относится к категории текстовых редакторов. В принципе, такое разбиение на группы нам вполне 
			подходит. Но, поскольку мы создает собственный репозиторий, лучше будет сохранить информацию о том, откуда 
			был скачан тот или иной пакет. Т.е. чтобы наш репозиторий повторял структуру официального репозитория Ubuntu
			(LinuxMint и т.д.). Как же получить информацию о том, откуда реально будет скачиваться тот или иной пакет?
			
		<p>
			Для начала попробуем воспользоваться командой <strong>apt-cache</strong>:
<pre>
$ apt-cache showpkg vim
Package: vim
Versions: 
2:7.4.052-1ubuntu3.1 (/var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty-updates_main_binary-i386_Packages) 
(/var/lib/apt/lists/security.ubuntu.com_ubuntu_dists_trusty-security_main_binary-i386_Packages) 
(/var/lib/dpkg/status)
 Description Language: 
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages
                  MD5: 59e8b8f7757db8b53566d5d119872de8
 Description Language: en
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_i18n_Translation-en
                  MD5: 59e8b8f7757db8b53566d5d119872de8

2:7.4.052-1ubuntu3 (/var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-i386_Packages)
 Description Language: 
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages
                  MD5: 59e8b8f7757db8b53566d5d119872de8
 Description Language: en
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_i18n_Translation-en
                  MD5: 59e8b8f7757db8b53566d5d119872de8
...
</pre>
		<p>
			Из строчек вроде 
			<em>/var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages</em>
			можно вычленить имя каталога из оригинального репозитория. 
			<em>archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages</em> подоздрительно похоже на 
			уже упоминавшуюся в <a href="how-to-set-up-offline-software-repository-part-1.html#table-1">части 1</a> 
			строчку <em>archive.ubuntu.com/ubuntu trusty main</em>, только записанное в немного другом порядке и с 
			символами 
			подчеркивания вместо слеша. В принципе, такого рода строчек достаточно, чтобы восстановить структуру 
			каталогов 
			оринигального репозитория. 
			
			
		<h2>Кажется, мы придумали кое-что получше</h2>
		
		<p>
			А именно: использование команды <strong>apt-get</strong>
			c опцией <code>--print-uris</code>. Т.о. можно узнать ссылку на оригинальный файл (сам же пакет при 
			использовании
			этого параметра загружен на будет, подробности см. в <code>man apt-get</code>). Например, узнаем, где  
			в оригинальном репозитории расположен двоичный пакет редактора Vim:
			
<pre>
$ apt-get --print-uris download vim
'http://archive.ubuntu.com/ubuntu/pool/main/v/vim/vim_7.4.052-1ubuntu3.1_i386.deb' ...
</pre>			
		<p>
			Т.о. последний подход лучше всех вышеперечисленных. Но, как всегда, при работе с параметром 
			<code>--print-uris</code> есть несколько нюансов. 
			
		<p>
			Во-первых, лучше всего ставить параметр перед действием 
			в командной строке. Да,
			команды 
			<ul>
				<li><code>apt-get --print-uris download vim</code>
				<li><code>apt-get download --print-uris vim</code>
				<li><code>apt-get download vim --print-uris</code>
			</ul>
			выдадут одинаковый результат. Но все же лучше будет
			разместить <code>--print-uris</code> сразу после <code>apt-get</code>.
		
		<p>
			Во-вторых, <code>apt-get --print-uris download ...</code> ничего не напечатает, если пакет уже загружен в 
			текущий	каталог. Проверим это вживую (в начале каждой строки стоит ее порядковый номер для удобства):	
<pre>
1	$ apt-get --print-uris download vim
'http://archive.ubuntu.com/ubuntu/pool/main/v/vim/vim_7.4.052-1ubuntu3.1_i386.deb' ...
2	$ apt-get download vim
Get:1 http://archive.ubuntu.com/ubuntu/ trusty-updates/main vim i386 2:7.4.052-1ubuntu3.1 [876 kB]
Fetched 876 kB in 1s (498 kB/s)
3	$ apt-get --print-uris download vim
4	$ rm vim_2%3a7.4.052-1ubuntu3.1_i386.deb 
5	$ apt-get --print-uris download vim
 	'http://archive.ubuntu.com/ubuntu/pool/main/v/vim/vim_7.4.052-1ubuntu3.1_i386.deb' ...
</pre>			
		<p>
			Как видим, команда №3 ничего не напечатала (к моменту ее выполнения пакет уже был скачан в текущий каталог). 
			Но после
			удаления файла пакета Vim из текущего каталога команда №5 напечатала ссылку как ни в чем не бывало 
			<sup id="footnote-1-top"><a href="#footnote-1-bottom">[1]</a></sup>.		

        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Ссылки, которые выдает <code>apt-get --print-uris download ...</code> можно использовать напрямую,
						т.е. можно использовать для скачивания не <strong>apt-get</strong>, а, например, <strong>wget</strong>.
						Но лучше использовать все-таки <strong>apt-get</strong>. И не потому что это более элегантно (особенно
						в случае скачивания исходных текстов - поди разберись, что там за три файла), а потому, что 
						<strong>apt-get</strong> еще проверяет контрольные суммы и т.д.
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
