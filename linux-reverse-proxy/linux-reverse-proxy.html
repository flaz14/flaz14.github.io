<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Reverse-proxy в Linux своими ногами</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/#linux-reverse-proxy" title="Перейти к оглавлению">&larr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href="http://flaz14.github.io/linux-reverse-proxy/linux-reverse-proxy.html">
				Reverse-proxy в Linux своими ногами
			</a>
		</h1>
		
		<h3>[2018, Февраль]</h3>

		<h2>Вспоминаем</h2>
		
		<p>
			Дурацкое название подходит очень хорошо этой заметке. Давным-давно я настраивал reverse-proxy для сервера
			Tomcat. Сейчас постараюсь вспомнить и рассказать, как это было.
		
		<p>
			Был удаленный компьютер (Amazon EC2 instance). На нем был запущен сервер приложений Tomcat. Мне захотелось 
			сделать так, чтобы каждый, кто обратится к приложению на удаленном компьютере через порт 8080, попадал на 
			мой компьютер. Подобная задача решается одной строчкой:	командой <strong>ssh</strong>. Но не все так просто 
			оказалось...
		
		<p>
			На удаленном сервере у меня были права суперпользователя. Так что делать я мог все, что угодно. Проблема 
			была в том, что ssh-демон был настроен так, что не разрешал выставлять порт наружу. Т.е. войти в ssh-туннель
			можно было только с самого удаленного сервера. 
			
		<p>
			Было два варианта: 
			<ol>
				<li>
					Править конфигурационные файлы демона ssh. Это чревато. Во-первых, можно все испортить нафиг одной
					неверной строкой. Во-вторых, у удаленного сервера были админы, которые следили за такого рода
					изменениями.
				
				<li>
					Сделать цепочку из туннелей с помощью какой-нибудь другой программы, кроме ssh. Один конец 
					вспомогательного туннеля можно было выставить наружу на порту 8080, а другой - "пристыковать" к 
					обычному ssh-туннелю, который слушает на локальном (<em>lo</em>) сетевом интерфейсе.
			</ol>

		<p>
			Я остановился на втором способе как наиболее простом (проще, чем конфиги) и безопасном (перестал быть нужен
			reverse-proxy - нажал в консоли <kbd>Ctrl</kbd> + <kbd>C</kbd>, удалил вспомогательный софт - и все стало, 
			как было).
		
		<h2>Netcat устарел</h2>
		
		<p>
			С помощью netcat (здесь и далее имеется ввиду <em>OpenBSD netcat</em>) возможно сделать двунаправленный 
			туннель (если задействовать именованные каналы). А чтобы туннель оставался рабочим (когда клиент закрывает 
			TCP-соединение, то netcat завершает работу) стоит поместить запуск netcat внутрь бесконечного цикла в 
			shell-скрипте. У такого подхода есть существенный недостаток: невозможность нескольких одновременных (т.е. 
			по-настоящему параллельных) соединений. Это очень важно для полноценного прокси, особенно, если нужно 
			просматривать через него странички в браузере.
		
		<p>
			В новых вариациях netcat (<a href="https://nmap.org/ncat/">Ncat</a> и т.п.) все по-новому. Но стоит обратить
			внимание на еще одну утилиту: <a href="http://www.dest-unreach.org/socat/">Socat</a>. Это очень мощная 
			программа, и ее применение не ограничивается одними лишь сетевыми соединениями. 
		
		<h2>Решаем задачу</h2>
		
		<p>
			<ol>
				<li>
					<p>
						Устанавливаем на удаленном компьютере socat:

<pre>
sudo yum install socat
</pre>

				<li>
					<p>
						Останавливаем на удаленном компьютере Tomcat.
				
				<li>
					<p>
						Запускаем Tomcat на локальном компьютере.
				
				<li>
					<p>
						Открываем ssh-туннель между локальным компьютером и удаленным. На локальном компьютере будем 
						использовать порт 8080 (именно этот порт занимает Tomcat с настройками по умолчанию). На 
						удаленном же компьютере задействуем порт 8079:

<pre>
ssh -R "8079:localhost:8080" -N user@ec2-instance.mycompany.com
</pre>						
				
				<li>
					<p>
						Запускаем socat на удаленном сервере. Даже права суперпользователя не нужны. Особенность здесь в
						том, что открывать порт 8080 нужно по протоколу IPv6. Дело в том, что на серверах Amazon трафик 
						с привычного для внешнего мира порта 80 перебрасывается (через балансировщик нагрузки) на порт 
						8080 сервера EC2 именно по протоколу IPv6 (т.е. Tomcat вообще не обслуживает IPv4, по крайней 
						мере, для приложений; может, административные задачи, удаленная отладка и т.п. доступны и по 
						IPv4). На этом этапе мы на удаленном компьютере выставляем наружу, как ни в чем ни бывало, порт 
						8080:

<pre>
socat TCP6-LISTEN:8080,fork TCP:localhost:8079
</pre>

					<p>
						Параметр <strong>fork</strong> играет ключевую роль. Именно благодаря ему socat не 
						"отваливается",	как это делает обычный netcat.
				
				<li>
					<p>
						Проверяем со своего компьютера, что перенаправление действительно работает, т.е. опрашиваем 
						удаленный сервер через балансировщик нагрузки и смотрим логи Tomcat'а на локальной машине:

<pre>
curl http://public.mycompany.com/application/version
</pre>
					
					<p>
						Для убедительности можно повторить запрос несколько раз. И глянуть открытые порты на удаленном 
						сервере напоследок, например, так:

<pre>
netstat -ntl | grep 8080
</pre>
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="http://validator.w3.org/check?uri=referer">
					<img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" 
					height="31" width="88">
				</a>
			</big>
		</h1>
	</body>
</html>
