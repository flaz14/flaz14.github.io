<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Как сделать off-line репозиторий ПО для LinuxMint 17.1. Часть 2</title>
	</head>

	<body>
		<h1>
			<big>
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>

		<hr>

		<h1>
			<a href=
		"http://flaz14.github.io/how-to-hide-non-mounted-drives/how-to-hide-non-mounted-drives-part-1.html">
				Как сделать off-line репозиторий ПО для LinuxMint 17.1. Часть 2
			</a>
		</h1>
		
		<h3>[2017, Июнь]</h3>

		<h3>
			<a href="how-to-set-up-offline-software-repository-part-1.html">Часть 1</a>
			|
			<a href="how-to-set-up-offline-software-repository-part-3.html">Часть 3</a>
			|
			<a href="how-to-set-up-offline-software-repository-part-4.html">Часть 4</a>			
			|
			<a href=
		"https://github.com/flaz14/flaz14.github.io/tree/master/this_source_code_does_not_exist_yet">
				Исходный код
			</a>
		</h3>

		<h2></h2>
		
		<p>
			В <a href="how-to-set-up-offline-software-repository-part-1.html#note-apt-get-approach">части 1</a> 
			говорилось, что при использовании <strong>apt-get</strong> для скачивания будут доступны только пакеты, 
			соответствующие архитектуре компьютера, на который они загружаются. Но это не так. Даже "сидя" на 32-х битном
			дистрибутиве, скачать пакеты для 64-х битного дистрибутива. Достаточно добавить маленький суффикс к имени
			пакета.
		
		<p>
			Пусть мы используем LinuxMint 17.1 32bit. Посмотрим, действительно ли это так:
			
			
			Например, чтобы скачать vim для 64-битного дистрибутива можно воспользоваться такой командой:
<pre>
$ dpkg --print-architecture
i386
</pre>

		<p>
			Теперь глянем, пакеты для каких еще архитектур доступны:
<pre>
$ dpkg --print-foreign-architectures
</pre>
		<p>
			И в ответ не получим ничего. Что ж, неудивительно. Если в 64-х битный дистрибутив можно установить 32-х битную
			программу, то наоборот - нет. Придется добавить архитектуру (практического смысла в этом нет, просто сделаем
			это для демонстрации скачивания пакетов):
<pre>
$ sudo dpkg --add-architecture amd64
$ dpkg --print-foreign-architectures
amd64
</pre>
		<p>
			C 64-х битными пакетами вроде бы разобрались. А как насчет архитектур ARM, PowerPC и т.д.? В принципе, пакеты
			для этих архитектур есть в <a href="https://www.debian.org/releases/stable/">репозиториях Debian</a>, но не
			в Ubuntu (и следовательно, LinuxMint). Так что ограничимся <strong>i386</strong> и <strong>amd64</strong>.
		
		<p>
			Скачаем уже что-нибудь, например, текстовый редактор <em>Vim</em> для 64-х битного дистрибутива (не забыв
			перед этим выполнить <code>sudo apt-get update</code>):
<pre>
$ apt-get download vim:amd64
$ ls
vim_2%3a7.4.052-1ubuntu3.1_amd64.deb
</pre>

		<p>
			Для пущей уверенности можно зайти в свежескачанный .deb-файл с помощью Midnight Commander'а !!!тут будет
			ссылка на официальный сайт!!! и убедиться в правильной архитектуре:
			
!!!тут будет скриншот файла INFO!!!

		<p>
			Чтобы скачать не только готовый двоичный пакет, но и исходные тексты придеться сначала добавить соответствующий
			ссылки. Но не в файл <i>/etc/apt/sources.list</i>. В Ubuntu (а следовательно, и LinuxMint) для источников
			ПО есть каталог <i>/etc/apt/sources.list.d</i>. А уже в нем находятся файлы, которые содержат ссылки определенной
			категории (!!!ссылки - неправильный термин, нужно подобрать что-то более подходящее!!!).
			Посмотрим что уже есть:
<pre>
$ ls -alh /etc/apt/sources.list.d/
total 24K
drwxr-xr-x 2 root root 4,0K Apr  2 11:23 .
drwxr-xr-x 6 root root 4,0K Apr  2 11:23 ..
-rw-r--r-- 1 root root   78 May 24  2016 bro.list
-rw-r--r-- 1 root root   59 Nov 27  2014 getdeb.list
-rw-r--r-- 1 root root  140 Apr  2 11:23 mc3man-trusty-media-trusty.list
-rw-r--r-- 1 root root  529 Nov 27  2014 official-package-repositories.list
</pre>

		<p>
			Откуда взялся getdeb.list я не знаю. Да и содержит этот файл единственную строчку, являющуюся комментарием.
			bro.list и mc3man-trusty-media-trusty.list соответствуют репозиториям сторонних пакетов. А вот 
			<i>official-package-repositories.list</i> - это список оригинальных репозиториев (по крайней мере, так следует
			из названия). Посмотрим на содержимое файла:
<pre>
$ cat /etc/apt/sources.list.d/official-package-repositories.list 
# Do not edit this file manually, use Software Sources instead.

deb http://packages.linuxmint.com rebecca main upstream import  #id:linuxmint_main
deb http://extra.linuxmint.com rebecca main #id:linuxmint_extra

deb http://archive.ubuntu.com/ubuntu trusty main restricted universe multiverse
deb http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse

deb http://security.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse
deb http://archive.canonical.com/ubuntu/ trusty partner
</pre>			
			
		<p>
			Все вполне предсказуемо. Будет логично предположить, что для подключения репозиториев с исходными текстами ПО
			потребуется создать еще один файл внутри каталога <i>/etc/apt/sources.list.d/</i> и напихать в него ссылок.
			Но угрожающий комментарий о нежелательности ручного редактирования файла наводит на мысль задействовать-таки
			утилиту с графическим интерфейсом. Найти и запустить ее не так уж сложно: 
			<code>$ gksudo software-sources</code>. Перед нами предстанет картинка, приведенная на рисунке
			
			!!!тут будет скриншот программы с выделенной галочкой!!!
			
			Ставим флажок напротив <em>Enable source code repositories</em>, закрываем окно и на всякий случай делаем
			в консоли <code>$ sudo apt-get update</code> (это будет надежнее, чем кликать по кнопке <em>Update the cache</em>
			в правом верхнем углу окна уже просто потому, за логом придется лезть в файл, а в случае с командной
			строкой мы увидим его прямо в консоли). В выводе должны появиться
			строчки вроде <em>... http://archive.ubuntu.com trusty/main Sources ...</em>.
			
			А в каталоге <i>/etc/apt/sources.list.d</i> появится новый файл <i>official-source-repositories.list</i>
			следующего содержания:
<pre>
deb-src http://packages.linuxmint.com rebecca main upstream import 

deb-src http://extra.linuxmint.com rebecca main

deb-src http://archive.ubuntu.com/ubuntu trusty main restricted universe multiverse
deb-src http://archive.ubuntu.com/ubuntu trusty-updates main restricted universe multiverse

deb-src http://security.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse
deb-src http://archive.canonical.com/ubuntu/ trusty partner
</pre>			

		<p>
			Чтобы скачать исходный текст программы достаточно выполнить такую команду (для примера скачаем исходные тексты
			редактора Vim):
			
<pre>
$ apt-get source vim
</pre>

		<p>
			Посмотрим, что же реально скачалось:
<pre>
$ ls -1
vim-7.4.052
vim_7.4.052-1ubuntu3.1.debian.tar.gz
vim_7.4.052-1ubuntu3.1.dsc
vim_7.4.052.orig.tar.gz
</pre>

		<p>
			Да, то, что надо. Подробно останавливаться на описании скачанного не будем (дополнительные сведения можно
			найти в <code>man apt-get</code>). Очевидно, что указывать архитектуру при скачивании исходных текстов не
			нужно.
			
		<p>
			В целом алгоритм создания собственного репозитория простой:
			1. Cоставляем список архитектур (в нашем случае их будет всего две: <strong>i386</strong> и <strong>amd64</strong>)
			2. Составляем список пакетов для скачивания
			3. Для каждой пары пакет-архитектура выполняем:	apt-get download имя_пакета:архитектура
			4. Для каждого пакета из списка выполняем: apt-get source имя_пакета
				
		<p>
			О том, как получить список всех доступных пакетов уже подробно рассказано в ответе на вопрос 
<a href="https://askubuntu.com/questions/160897/how-do-i-search-for-available-packages-from-the-command-line">
	How do I search for available packages from the command-line?</a>. 
	
		<p>
			Остается только определиться, каким именно образом мы будем складывать скачанное добро. 
			
			Можно поступить просто:
			разложить скачанное по двук каталогам: один - для двоичных пакетов, другой - для исходных текстов.
			
			Можно разбить на категории. Узнать, к какой категории (впрочем, они условны) относится тот или иной пакет 
			можно с помощью команды <strong>apt-cache</strong>. Например, 
				
<pre>
$ apt-cache show vim
Package: vim
Priority: optional
Section: editors
...
</pre>
		<p>
			Как видим, vim относится к категории текстовых редакторов. В принципе, такое разбиение на группы вполне подходит.
			Но, поскольку мы создает собственный репозиторий, лучше будет сохранить информацию о том, откуда скачан тот 
			или иной пакет. Т.е. чтобы наш репозиторий повторял структуру репозитория Ubuntu (LinuxMint и т.д.). Как 
			получить информацию о том, откуда реально будет скачиваться тот или иной пакет?
			
			Для начала попробуем воспользоваться командой <strong>apt-cache</strong>:
<pre>
$ apt-cache showpkg vim
Package: vim
Versions: 
2:7.4.052-1ubuntu3.1 (/var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty-updates_main_binary-i386_Packages) (/var/lib/apt/lists/security.ubuntu.com_ubuntu_dists_trusty-security_main_binary-i386_Packages) (/var/lib/dpkg/status)
 Description Language: 
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages
                  MD5: 59e8b8f7757db8b53566d5d119872de8
 Description Language: en
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_i18n_Translation-en
                  MD5: 59e8b8f7757db8b53566d5d119872de8

2:7.4.052-1ubuntu3 (/var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-i386_Packages)
 Description Language: 
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages
                  MD5: 59e8b8f7757db8b53566d5d119872de8
 Description Language: en
                 File: /var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_i18n_Translation-en
                  MD5: 59e8b8f7757db8b53566d5d119872de8
...
</pre>
		<p>
			Из строчек вроде <em>/var/lib/apt/lists/archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages</em>
			можно вычленить имя каталога из оригинального репозитория. 
			<em>archive.ubuntu.com_ubuntu_dists_trusty_main_binary-amd64_Packages</em> подоздрительно похоже на 
			уже упоминавшуюся в части 1 строчку (!!!тут будет ссылка на таблицу в части 1!!!) 
			<em>archive.ubuntu.com/ubuntu trusty main</em>, только записанное в немного другом порядке и с символами 
			подчеркивания вместо слеша. В принципе, такого рода строчек достаточно, чтобы восстановить структуру каталогов 
			оринигального репозитория. Но есть способ получше. А именно: использование командый <strong>apt-get</strong>
			c опцией <code>--print-uris</code>. Т.о. можно узнать ссылку на оригинальный файл (сам же пакет при использовании
			этого параметра загружен на будет, подробности см. в <code>man apt-get</code>). Например, узнаем, где же 
			в оригинальном репозитории расположен двоичный пакет редактора vim:
			
<pre>
$ apt-get --print-uris download vim
'http://archive.ubuntu.com/ubuntu/pool/main/v/vim/vim_7.4.052-1ubuntu3.1_i386.deb' vim_2%3a7.4.052-1ubuntu3.1_i386.deb 876244 SHA256:9f02c80049eaea735d8b1a199b55ca3adac5ebc3fd27da6316f6d438f89d07d8
</pre>			
		<p>
			Т.о. последний подход лучше всех вышеперечисленных. Но, как всегда, при работе с параметром <code>--print-uris</code>
			есть несколько нюансов. Во-первых, лучше всего ставить параметр перед действием в командной строке. Да,
			команды <code>apt-get --print-uris download vim</code>, <code>apt-get download --print-uris vim</code> и 
			<code>apt-get download vim --print-uris</code> выдадут одинаковый результат. Но на всякий случай лучше будет
			разместить <code>--print-uris</code> сразу после <code>apt-get</code>.
			
			Во-вторых, <code>apt-get --print-uris download ...</code> ничего не выдаст, если пакет уже загружен в текущий
			каталог. Проверим это вживую (в начале каждой строки стоит ее порядковый номер для удобства):	
<pre>
1. $ apt-get --print-uris download vim
'http://archive.ubuntu.com/ubuntu/pool/main/v/vim/vim_7.4.052-1ubuntu3.1_i386.deb' vim_2%3a7.4.052-1ubuntu3.1_i386.deb 876244 SHA256:9f02c80049eaea735d8b1a199b55ca3adac5ebc3fd27da6316f6d438f89d07d8
2. $ apt-get download vim
Get:1 http://archive.ubuntu.com/ubuntu/ trusty-updates/main vim i386 2:7.4.052-1ubuntu3.1 [876 kB]
Fetched 876 kB in 1s (498 kB/s)
3. $ apt-get --print-uris download vim
4. $ rm vim_2%3a7.4.052-1ubuntu3.1_i386.deb 
5. $ apt-get --print-uris download vim
'http://archive.ubuntu.com/ubuntu/pool/main/v/vim/vim_7.4.052-1ubuntu3.1_i386.deb' vim_2%3a7.4.052-1ubuntu3.1_i386.deb 876244 SHA256:9f02c80049eaea735d8b1a199b55ca3adac5ebc3fd27da6316f6d438f89d07d8
</pre>			
		<p>
			Как видим, команда №3 ничего не напечатала (к этому моменту пакет уже был скачан в текущий каталог). Но после
			удаления файла пакета vim из текущего каталога команда №5 напечатал ссылку как ни в чем не бывало [1].
			

		
			
			
			
			
		
			
			
		


	
			

			



		
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		<p>
			Разобьем решение задачи на несколько этапов:
			<ol>
				<li>
					Просмотрим архив Ubuntu начиная с самого верхнего уровня и соберем все ссылки на все файлы.
							
				<li>
					Скачаем файлы. В первую очередь, скачаем контрольные суммы и цифровые подписи, а затем собственно 
					ПО.
					
				<li>
					Проверим контрольные суммы и цифровые подписи.
			</ol>
				
		<p>
			Будем использовать Python. И обращаться к таким программам, как <strong>wget</strong> по мере необходимости.
			Все настройки будем хранить в самом скрипте, в том числе и указание на расположение скачанных файлов. 
			Скачивание будет происходить в автоматическом режиме. Интерактивности не будет. Но мы позаботимся о 
			возможных разрывах Интернет-соединения, докачке файлов и т.п.
			
        <p>
			__________
			<ol>
				<li id="footnote-1-bottom">
					<p>
						<a href="#footnote-1-top" title="Перейти к основному тексту">&uarr;</a> 
						Ссылки, которые выдает <code>apt-get --print-uris download ...</code> можно использовать напрямую,
						т.е. можно использовать для скачивания не <strong>apt-get</strong>, а, например, <strong>wget</strong>.
						Но лучше использовать все-таки <strong>apt-get</strong>. И не потому что это более элегантно (особенно
						в случае скачивания исходных текстов - поди разберись, что там за три файла), а потому, что 
						<strong>apt-get</strong> еще проверяет контрольные суммы и т.д.

				<li id="footnote-2-bottom">
					<p>
						<a href="#footnote-2-top" title="Перейти к основному тексту">&uarr;</a> 
						Я так и не разобрался, что все это значит: <i>udisks</i>, <i>GVfs</i>, 
			</ol>

		<hr>

		<h1>
			<big>
				<a href="#" title="Перейти к началу страницы">&uarr;</a>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				<a href="/" title="Перейти на главную страницу">&#8962;</a>
			</big>
		</h1>
	</body>
</html>
